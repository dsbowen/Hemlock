{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hemlock Hemlock aspires to be the most powerful and flexible way to create online studies, with applications in marketing and behavioral science research. If the installation and quickstart instructions don't make sense to you, check out the tutorial . Contact If you're a marketing, political advertising, or other for-profit company, see my contact page for details on hiring me as a consultant and purchasing a commercial license. If you're an academic or non-profit researcher interested in using hemlock, see my contact page for contact details and collaboration policy. Why hemlock? If you're an academic researcher interested in using hemlock, but aren't sure if it's worth your time to learn it, read this . Installation $ pip install hemlock-survey Quickstart Create a file app.py in the root directory of your project: import eventlet eventlet . monkey_patch () from hemlock import Branch , Page , Label , create_app , route @route ( '/survey' ) def start (): return Branch ( Page ( Label ( 'Hello, World!' ), terminal = True ) ) app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run your app: $ python3 app.py And navigate to http://localhost:5000/ in your browser. Citation @software{bowen2021hemlock, author = {Dillon Bowen}, title = {Hemlock}, url = {https://dsbowen.github.io/hemlock/}, date = {2021-02-13}, } License Users must cite this package in any publications which use it. It is licensed with the Hemlock Research License . The license permits free use for academic research, and requires written permission from hemlock's author, Dillon Bowen, for commercial use.","title":"Home"},{"location":"#hemlock","text":"Hemlock aspires to be the most powerful and flexible way to create online studies, with applications in marketing and behavioral science research. If the installation and quickstart instructions don't make sense to you, check out the tutorial .","title":"Hemlock"},{"location":"#contact","text":"If you're a marketing, political advertising, or other for-profit company, see my contact page for details on hiring me as a consultant and purchasing a commercial license. If you're an academic or non-profit researcher interested in using hemlock, see my contact page for contact details and collaboration policy.","title":"Contact"},{"location":"#why-hemlock","text":"If you're an academic researcher interested in using hemlock, but aren't sure if it's worth your time to learn it, read this .","title":"Why hemlock?"},{"location":"#installation","text":"$ pip install hemlock-survey","title":"Installation"},{"location":"#quickstart","text":"Create a file app.py in the root directory of your project: import eventlet eventlet . monkey_patch () from hemlock import Branch , Page , Label , create_app , route @route ( '/survey' ) def start (): return Branch ( Page ( Label ( 'Hello, World!' ), terminal = True ) ) app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run your app: $ python3 app.py And navigate to http://localhost:5000/ in your browser.","title":"Quickstart"},{"location":"#citation","text":"@software{bowen2021hemlock, author = {Dillon Bowen}, title = {Hemlock}, url = {https://dsbowen.github.io/hemlock/}, date = {2021-02-13}, }","title":"Citation"},{"location":"#license","text":"Users must cite this package in any publications which use it. It is licensed with the Hemlock Research License . The license permits free use for academic research, and requires written permission from hemlock's author, Dillon Bowen, for commercial use.","title":"License"},{"location":"acknowledgements/","text":"Acknowledgements I would like to thank my friends, family, and mentors for supporting me throughout hemlock's development, with special thanks to the following individuals: Sarah Reed, who has contributed more to hemlock than anyone else. Her contributions include referring me to resources and APIs, discussing countless design decisions, testing the API, and being a constant source of support and encouragement. Luke Sabor, for being the first to complete the hemlock tutorial and giving me invaluable feedback along the way. Raman Thadani, for being the second to complete the hemlock tutorial and giving me invaluable feedback along the way, and for drafting the Mac setup instructions. I created hemlock as a free tool for academic and non-profit researchers. I'm grateful that Sarah, Luke, and Raman share this spirit, assisting in their spare time, compensated only by my gratitude.","title":"Acknowledgements"},{"location":"acknowledgements/#acknowledgements","text":"I would like to thank my friends, family, and mentors for supporting me throughout hemlock's development, with special thanks to the following individuals: Sarah Reed, who has contributed more to hemlock than anyone else. Her contributions include referring me to resources and APIs, discussing countless design decisions, testing the API, and being a constant source of support and encouragement. Luke Sabor, for being the first to complete the hemlock tutorial and giving me invaluable feedback along the way. Raman Thadani, for being the second to complete the hemlock tutorial and giving me invaluable feedback along the way, and for drafting the Mac setup instructions. I created hemlock as a free tool for academic and non-profit researchers. I'm grateful that Sarah, Luke, and Raman share this spirit, assisting in their spare time, compensated only by my gratitude.","title":"Acknowledgements"},{"location":"app/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Application factory and settings hemlock.app. init_app def hemlock.app. init_app ( ) [source] Create database tables and initialize data storage models hemlock.app. push_app_context def hemlock.app. push_app_context ( ) [source] Push an app context for debugging in shell or notebook. Returns: app : flask.app.Flask Examples from hemlock import push_app_context app = push_app_context () Out: <Flask 'hemlock.app'> hemlock.app. create_app def hemlock.app. create_app ( settings=settings ) [source] Create a Hemlock application. Parameters: settings : dict Default settings for the application, extensions, and models. Returns: app : flask.app.Flask Examples In this example, we add a back button to every page in our survey. from hemlock import Page , create_app , settings settings [ 'Page' ] . update ({ 'back' : True }) app = create_app () app . app_context () . push () Page () . preview ()","title":"Setting and initialization"},{"location":"app/#application-factory-and-settings","text":"","title":"Application factory and settings"},{"location":"app/#hemlockappinit_app","text":"def hemlock.app. init_app ( ) [source] Create database tables and initialize data storage models","title":"hemlock.app.init_app"},{"location":"app/#hemlockapppush_app_context","text":"def hemlock.app. push_app_context ( ) [source] Push an app context for debugging in shell or notebook. Returns: app : flask.app.Flask","title":"hemlock.app.push_app_context"},{"location":"app/#examples","text":"from hemlock import push_app_context app = push_app_context () Out: <Flask 'hemlock.app'>","title":"Examples"},{"location":"app/#hemlockappcreate_app","text":"def hemlock.app. create_app ( settings=settings ) [source] Create a Hemlock application. Parameters: settings : dict Default settings for the application, extensions, and models. Returns: app : flask.app.Flask","title":"hemlock.app.create_app"},{"location":"app/#examples_1","text":"In this example, we add a back button to every page in our survey. from hemlock import Page , create_app , settings settings [ 'Page' ] . update ({ 'back' : True }) app = create_app () app . app_context () . push () Page () . preview ()","title":"Examples"},{"location":"changelog/","text":"Changelog 0.0.51 Fixed bug in make_list tool Added break in Slider template to leave space for tooltip by default 0.0.50 Markdown syntax for page text Added and updated value comparisons for validate function bank Added value comparisons to submit function bank 0.0.49 Lots of updates since 0.0.22. Here are just the few I remember. moved from the BeautifulSoup architecture to a classic Jinja architecture for dramatically faster page rendering many additional question polymorphs, including Bootstrap range sliders and accompanying Likert functionality improved page caching improved web socket connectivity improved redundancy for workers and long-loading pages improved page previewing resolved to maintain a better changelog 0.0.22 added support for embedded dash apps CLI 0.0.17 added setup-venv command for easier virtual environment setup on Windows git bash 0.0.20 fixed Submit.match and Validate.match bug: now requires full match instead of partial match improved number inputs and added step attribute","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#0051","text":"Fixed bug in make_list tool Added break in Slider template to leave space for tooltip by default","title":"0.0.51"},{"location":"changelog/#0050","text":"Markdown syntax for page text Added and updated value comparisons for validate function bank Added value comparisons to submit function bank","title":"0.0.50"},{"location":"changelog/#0049","text":"Lots of updates since 0.0.22. Here are just the few I remember. moved from the BeautifulSoup architecture to a classic Jinja architecture for dramatically faster page rendering many additional question polymorphs, including Bootstrap range sliders and accompanying Likert functionality improved page caching improved web socket connectivity improved redundancy for workers and long-loading pages improved page previewing resolved to maintain a better changelog","title":"0.0.49"},{"location":"changelog/#0022","text":"added support for embedded dash apps","title":"0.0.22"},{"location":"changelog/#cli-0017","text":"added setup-venv command for easier virtual environment setup on Windows git bash","title":"CLI 0.0.17"},{"location":"changelog/#0020","text":"fixed Submit.match and Validate.match bug: now requires full match instead of partial match improved number inputs and added step attribute","title":"0.0.20"},{"location":"checklist/","text":"Checklist This is a checklist of the steps involved in initializing, editing, and deploying a hemlock project. This will make sense after you go through the tutorial . Initialize $ hlk init <my-project-name> <my-github-username> <my-github-token> $ cd <my-project-name> $ hlk setup-venv <my-operating-system> Edit Iterate quickly on the blackboard: $ jupyter notebook # open blackboard.ipynb, Kernel >> Change kernel >> <my-project-name> Edit survey files: $ code survey.py Run locally: $ hlk serve Debug: $ hlk debug Deploy Deploy and test using free resources: $ hlk deploy Destroy the test app: $ heroku apps:destroy -a <my-app-name> Change app.json from: { \"addons\" : [ \"heroku-postgresql:hobby-dev\" ], \"formation\" : { \"web\" : { \"quantity\" : 1 , \"size\" : \"free\" } }, ... to: { \"addons\" : [ \"heroku-postgresql:standard-0\" ], \"formation\" : { \"web\" : { \"quantity\" : 10 , \"size\" : \"standard-1x\" } }, ... Deploy 'for real': hlk deploy # make sure to set the PASSWORD environment variable","title":"Checklist"},{"location":"checklist/#checklist","text":"This is a checklist of the steps involved in initializing, editing, and deploying a hemlock project. This will make sense after you go through the tutorial .","title":"Checklist"},{"location":"checklist/#initialize","text":"$ hlk init <my-project-name> <my-github-username> <my-github-token> $ cd <my-project-name> $ hlk setup-venv <my-operating-system>","title":"Initialize"},{"location":"checklist/#edit","text":"Iterate quickly on the blackboard: $ jupyter notebook # open blackboard.ipynb, Kernel >> Change kernel >> <my-project-name> Edit survey files: $ code survey.py Run locally: $ hlk serve Debug: $ hlk debug","title":"Edit"},{"location":"checklist/#deploy","text":"Deploy and test using free resources: $ hlk deploy Destroy the test app: $ heroku apps:destroy -a <my-app-name> Change app.json from: { \"addons\" : [ \"heroku-postgresql:hobby-dev\" ], \"formation\" : { \"web\" : { \"quantity\" : 1 , \"size\" : \"free\" } }, ... to: { \"addons\" : [ \"heroku-postgresql:standard-0\" ], \"formation\" : { \"web\" : { \"quantity\" : 10 , \"size\" : \"standard-1x\" } }, ... Deploy 'for real': hlk deploy # make sure to set the PASSWORD environment variable","title":"Deploy"},{"location":"contact/","text":"Contact For-profit and political research If you're a marketing, political advertising, or other for-profit company interested in using hemlock, email me (Dillon Bowen) at dsbowen@wharton.upenn.edu with the subject heading Hemlock for-profit . You may either: Hire me as a consultant to make surveys for you. Purchase a Hemlock Commercial License for developers at your company. Non-profit and academic research If you're an academic or non-profit researcher interested in using hemlock for your research, email me (Dillon Bowen) at dsbowen@wharton.upenn.edu with the subject heading Hemlock research . Collaboration policy I appreciate that you may be wary of investing the time required to learn hemlock upfront, so for a limited time I am offering to make studies for you using hemlock free of charge (subject to my time constraints as a PhD candidate). In return, I expect that you will: Cite hemlock in any publications which result from our collaboration. Mention hemlock in any talks related to our collaboration (e.g. \"we created our studies using hemlock; a python package for behavioral science research\"). Include a link to the hemlock documentation, https://dsbowen.github.io/hemlock/ , in any slide decks related to our collaboration. If you would like me to make multiple studies, or a single complex study which requires me to build new features or extensions, you should add me as a co-author. Feature requests and bugs If you would like to submit a feature request, report a bug, or have any other suggestions for improving hemlock, open an issue on github here .","title":"Contact"},{"location":"contact/#contact","text":"","title":"Contact"},{"location":"contact/#for-profit-and-political-research","text":"If you're a marketing, political advertising, or other for-profit company interested in using hemlock, email me (Dillon Bowen) at dsbowen@wharton.upenn.edu with the subject heading Hemlock for-profit . You may either: Hire me as a consultant to make surveys for you. Purchase a Hemlock Commercial License for developers at your company.","title":"For-profit and political research"},{"location":"contact/#non-profit-and-academic-research","text":"If you're an academic or non-profit researcher interested in using hemlock for your research, email me (Dillon Bowen) at dsbowen@wharton.upenn.edu with the subject heading Hemlock research .","title":"Non-profit and academic research"},{"location":"contact/#collaboration-policy","text":"I appreciate that you may be wary of investing the time required to learn hemlock upfront, so for a limited time I am offering to make studies for you using hemlock free of charge (subject to my time constraints as a PhD candidate). In return, I expect that you will: Cite hemlock in any publications which result from our collaboration. Mention hemlock in any talks related to our collaboration (e.g. \"we created our studies using hemlock; a python package for behavioral science research\"). Include a link to the hemlock documentation, https://dsbowen.github.io/hemlock/ , in any slide decks related to our collaboration. If you would like me to make multiple studies, or a single complex study which requires me to build new features or extensions, you should add me as a co-author.","title":"Collaboration policy"},{"location":"contact/#feature-requests-and-bugs","text":"If you would like to submit a feature request, report a bug, or have any other suggestions for improving hemlock, open an issue on github here .","title":"Feature requests and bugs"},{"location":"debug/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Debugger The debugger sends 'AI participants' through the survey. The AI participants attempt to break the survey by clicking random objects and entering random responses. Notes If your app is running on a different local host port than 5000, set the url root as an environment variable before opening the python shell in your second terminal: $ export ULR_ROOT=http://localhost:xxxx If your application import is not app.app , set the import as an enviornment variable before opening the python shell in your second terminal: $ export APP_IMPORT=path.to.app AI participants run in batches of specified sizes. For local debugging, I recommend a batch size of 1. For production debugging, you can safely go up to 3. Examples This example debugs an app locally. In survey.py : from hemlock import Branch , Page , Label , route @route ( '/survey' ) def start (): x = 1 / 0 return Branch ( Page ( Label ( 'Hello World' ), terminal = True )) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app ) Open a terminal and run the app with: $ python app.py $ or python3 app.py Open a second terminal and open the python shell with: $ python # or python3 Run the debugger in the second terminal: >>> from hemlock.debug import AIParticipant, debug >>> debug() The debugger will open a chromedriver and attempt to complete the survey. The first terminal window will display this error: File \"/home/<username>/hemlock/survey.py\", line 9, in start x = 1/0 ZeroDivisionError: division by zero hemlock.debug. debug def hemlock.debug. debug ( num_batches=1, batch_size=1 ) [source] Run the debugger. Parameters: num_batches : int, default=1 Number of batches of AI participants to run. batch_size : int, default=1 Number of AI participants to run per batch. Returns: result : bool True if all AI participants in all batches run sucessfully. Otherwise, the program will crash. Notes When called from the command line tool, num_batches and batch_size are passed as strings. hemlock.debug. run_batch def hemlock.debug. run_batch ( batch_size=1 ) [source] Run a batch of AI participants. Parameters: batch_size : int, default=1 Number of AI participants to run in this batch. Returns: result : bool True if all AI participants in this batch run successfully. Otherwise, the program will crash. hemlock.debug. run_participant def hemlock.debug. run_participant ( ) [source] Run a single AI participant through the survey. Assert that the participant does not encounter failures or errors. Returns: result : bool True if the participant ran successfully.","title":"Debugging"},{"location":"debug/#debugger","text":"The debugger sends 'AI participants' through the survey. The AI participants attempt to break the survey by clicking random objects and entering random responses.","title":"Debugger"},{"location":"debug/#notes","text":"If your app is running on a different local host port than 5000, set the url root as an environment variable before opening the python shell in your second terminal: $ export ULR_ROOT=http://localhost:xxxx If your application import is not app.app , set the import as an enviornment variable before opening the python shell in your second terminal: $ export APP_IMPORT=path.to.app AI participants run in batches of specified sizes. For local debugging, I recommend a batch size of 1. For production debugging, you can safely go up to 3.","title":"Notes"},{"location":"debug/#examples","text":"This example debugs an app locally. In survey.py : from hemlock import Branch , Page , Label , route @route ( '/survey' ) def start (): x = 1 / 0 return Branch ( Page ( Label ( 'Hello World' ), terminal = True )) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app ) Open a terminal and run the app with: $ python app.py $ or python3 app.py Open a second terminal and open the python shell with: $ python # or python3 Run the debugger in the second terminal: >>> from hemlock.debug import AIParticipant, debug >>> debug() The debugger will open a chromedriver and attempt to complete the survey. The first terminal window will display this error: File \"/home/<username>/hemlock/survey.py\", line 9, in start x = 1/0 ZeroDivisionError: division by zero","title":"Examples"},{"location":"debug/#hemlockdebugdebug","text":"def hemlock.debug. debug ( num_batches=1, batch_size=1 ) [source] Run the debugger. Parameters: num_batches : int, default=1 Number of batches of AI participants to run. batch_size : int, default=1 Number of AI participants to run per batch. Returns: result : bool True if all AI participants in all batches run sucessfully. Otherwise, the program will crash.","title":"hemlock.debug.debug"},{"location":"debug/#notes_1","text":"When called from the command line tool, num_batches and batch_size are passed as strings.","title":"Notes"},{"location":"debug/#hemlockdebugrun_batch","text":"def hemlock.debug. run_batch ( batch_size=1 ) [source] Run a batch of AI participants. Parameters: batch_size : int, default=1 Number of AI participants to run in this batch. Returns: result : bool True if all AI participants in this batch run successfully. Otherwise, the program will crash.","title":"hemlock.debug.run_batch"},{"location":"debug/#hemlockdebugrun_participant","text":"def hemlock.debug. run_participant ( ) [source] Run a single AI participant through the survey. Assert that the participant does not encounter failures or errors. Returns: result : bool True if the participant ran successfully.","title":"hemlock.debug.run_participant"},{"location":"manifesto/","text":"Why Hemlock? I invented Hemlock to increase the speed and quality of social science research. During the first year of my Ph.D., I spent hundreds of hours creating behavior experiments in Qualtrics. I remember the tediousness of copying and pasting blocks of questions, the struggle of implementing branching logic, and the frustration of updating hundreds of nearly-identical questions whenever my advisor wanted to modify the phrasing. My experience wasn't unique. Every social science Ph.D. student, research assistant, and professor spends hundreds of hours, year after year, mired in a monotonous struggle with a GUI that looks like it was downloaded from a bootlegged floppy disk. Throughout my Ph.D., I've worked with dozens of intelligent, hard-working colleagues, research assistants, and professors. They have better things to do with their time than shuffle question blocks or implement conditional logic using a drop-down menu. So do you. Qualtrics is an unacceptable waste of your time. Hemlock is the solution. Another lesson I learned as a first-year Ph.D. student is that most social science research today is dull and useless. Social science researchers picked 98% of the low-hanging fruit between 1970 and 1990. Because there's almost nothing left on the lowest branches, it takes a combination of exceptional skill and luck to discover something new and worthwhile. Why don't we reach beyond the lowest branches of our discipline? The answer, in part, is antiquated technology. It breaks my heart to see my colleagues imagine an exciting research idea, only to dilute it beyond recognition so they can implement it in Qualtrics. If the technology you're using limits your imagination and ambition, you need to use better technology. Hemlock is the solution. The 3 day challenge Set aside three days to learn python and Hemlock. Expect to struggle but resolve to push through. In March 2019, I was sitting at my computer, furiously hacking away at the next great Hemlock feature. Next door, I heard my colleague talking to Qualtrics support, trying to implement a new survey design. She had spent the last two days on the phone with Qualtrics, desperately trying to fix what should have been a simple problem. I knocked on her door and asked what she was trying to do. In 10 minutes, I coded her survey as specified and sent her a link. She was excited. \"How did you do that?\" she asked. I invited her to my computer and proudly displayed my python file. \"Ugh, I have to learn how to code?\" she said audibly, then walked away and redialed Qualtrics support. Coding is scary. I get it. As an undergrad, I retook computer science 101 three times because I failed it twice and gave up majoring in computer science as a Sophomore. But I decided to overcome my fear of coding as a Ph.D. student because I was tired of Qualtrics wasting my time and stifling my imagination. If you're an intermediate-level programmer (e.g., comfortable with R, new to python), I estimate it will take you three full days to learn the basics of python and Hemlock. Three days sounds like a long time. But if you set aside the time now and put in the effort, Hemlock will save you hundreds of hours throughout your career and enable you to shatter boundaries in your field.","title":"Why hemlock?"},{"location":"manifesto/#why-hemlock","text":"I invented Hemlock to increase the speed and quality of social science research. During the first year of my Ph.D., I spent hundreds of hours creating behavior experiments in Qualtrics. I remember the tediousness of copying and pasting blocks of questions, the struggle of implementing branching logic, and the frustration of updating hundreds of nearly-identical questions whenever my advisor wanted to modify the phrasing. My experience wasn't unique. Every social science Ph.D. student, research assistant, and professor spends hundreds of hours, year after year, mired in a monotonous struggle with a GUI that looks like it was downloaded from a bootlegged floppy disk. Throughout my Ph.D., I've worked with dozens of intelligent, hard-working colleagues, research assistants, and professors. They have better things to do with their time than shuffle question blocks or implement conditional logic using a drop-down menu. So do you. Qualtrics is an unacceptable waste of your time. Hemlock is the solution. Another lesson I learned as a first-year Ph.D. student is that most social science research today is dull and useless. Social science researchers picked 98% of the low-hanging fruit between 1970 and 1990. Because there's almost nothing left on the lowest branches, it takes a combination of exceptional skill and luck to discover something new and worthwhile. Why don't we reach beyond the lowest branches of our discipline? The answer, in part, is antiquated technology. It breaks my heart to see my colleagues imagine an exciting research idea, only to dilute it beyond recognition so they can implement it in Qualtrics. If the technology you're using limits your imagination and ambition, you need to use better technology. Hemlock is the solution.","title":"Why Hemlock?"},{"location":"manifesto/#the-3-day-challenge","text":"Set aside three days to learn python and Hemlock. Expect to struggle but resolve to push through. In March 2019, I was sitting at my computer, furiously hacking away at the next great Hemlock feature. Next door, I heard my colleague talking to Qualtrics support, trying to implement a new survey design. She had spent the last two days on the phone with Qualtrics, desperately trying to fix what should have been a simple problem. I knocked on her door and asked what she was trying to do. In 10 minutes, I coded her survey as specified and sent her a link. She was excited. \"How did you do that?\" she asked. I invited her to my computer and proudly displayed my python file. \"Ugh, I have to learn how to code?\" she said audibly, then walked away and redialed Qualtrics support. Coding is scary. I get it. As an undergrad, I retook computer science 101 three times because I failed it twice and gave up majoring in computer science as a Sophomore. But I decided to overcome my fear of coding as a Ph.D. student because I was tired of Qualtrics wasting my time and stifling my imagination. If you're an intermediate-level programmer (e.g., comfortable with R, new to python), I estimate it will take you three full days to learn the basics of python and Hemlock. Three days sounds like a long time. But if you set aside the time now and put in the effort, Hemlock will save you hundreds of hours throughout your career and enable you to shatter boundaries in your field.","title":"The 3 day challenge"},{"location":"security/","text":"Security features Heroku and Amazon Web Services The location of your data depends on your method of deployment. In the tutorial, I suggest deploying through heroku, which in turn deploys your application using AWS cloud computing. Both have extensive security infrastructures. Read more about heroku security and AWS security . Secure Sockets Layer (SSL) certification Hemlock-CLI's hlk production command, which scales your application in a production environment before distribution to participants, automatically creates an SSL certificate for your application. Hemlock uses flask talisman , developed by Google Cloud Platform, to force HTTPS requests. Hemlock's default content security policy allows application content from only the following third parties: Google API JQuery JSDeliver Bootstrap Password protection Hemlock users should password protect their applications before distribution to participants. This can be done simply with: from hemlock import settings settings [ 'password' ] = '<my-secret-password>' Hemlock will encrypt your password with the werkzeug password hash utility . Note. Be sure not to have your password set in a public code repository while your application is in production. Cross-site request forgery (CSRF) protection Hemlock uses flask download button to protect your data from CSRF attacks. This package employs a standard CSRF prevention technique; it stores a strongly random temporary CSRF authentication token in your browser's session, then authenticates the token when you issue a request to download your data.","title":"Security"},{"location":"security/#security-features","text":"","title":"Security features"},{"location":"security/#heroku-and-amazon-web-services","text":"The location of your data depends on your method of deployment. In the tutorial, I suggest deploying through heroku, which in turn deploys your application using AWS cloud computing. Both have extensive security infrastructures. Read more about heroku security and AWS security .","title":"Heroku and Amazon Web Services"},{"location":"security/#secure-sockets-layer-ssl-certification","text":"Hemlock-CLI's hlk production command, which scales your application in a production environment before distribution to participants, automatically creates an SSL certificate for your application. Hemlock uses flask talisman , developed by Google Cloud Platform, to force HTTPS requests. Hemlock's default content security policy allows application content from only the following third parties: Google API JQuery JSDeliver Bootstrap","title":"Secure Sockets Layer (SSL) certification"},{"location":"security/#password-protection","text":"Hemlock users should password protect their applications before distribution to participants. This can be done simply with: from hemlock import settings settings [ 'password' ] = '<my-secret-password>' Hemlock will encrypt your password with the werkzeug password hash utility . Note. Be sure not to have your password set in a public code repository while your application is in production.","title":"Password protection"},{"location":"security/#cross-site-request-forgery-csrf-protection","text":"Hemlock uses flask download button to protect your data from CSRF attacks. This package employs a standard CSRF prevention technique; it stores a strongly random temporary CSRF authentication token in your browser's session, then authenticates the token when you issue a request to download your data.","title":"Cross-site request forgery (CSRF) protection"},{"location":"functions/compile/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Compile functions hemlock.functions.compile. call_method def hemlock.functions.compile. call_method ( obj, method_name, *args, **kwargs ) [source] Calls one of the object's methods. Parameters: obj : Object whose methods will be called. method_name : str Names of the method to call. *args, **kwargs : Arguments and keyword arguments to pass to the method. Examples from hemlock import Compile as C , Page , push_app_context app = push_app_context () p = Page ( error = 'Error message' , compile = C . call_method ( 'clear_error' )) p . preview () . _compile () . preview () hemlock.functions.compile. clear_error def hemlock.functions.compile. clear_error ( obj ) [source] Calls the object's clear_error method. Parameters: obj : Object whose clear_error method will be called. Examples from hemlock import Compile as C , Page , push_app_context app = push_app_context () p = Page ( error = 'Error message' , compile = C . clear_error ()) p . preview () . _compile () . preview () hemlock.functions.compile. clear_response def hemlock.functions.compile. clear_response ( obj ) [source] Calls the object's clear_response method. Parameters: obj : Object whose clear_response method will be called. Examples from hemlock import Compile as C , Input , Page , push_app_context app = push_app_context () p = Page ( Input ( response = 'Hello World' ), compile = C . clear_response ()) p . preview () . _compile () . preview () hemlock.functions.compile. shuffle def hemlock.functions.compile. shuffle ( obj, *attrs ) [source] Shuffle an object's attributes. Parameters: obj : Objects whose attributes should be shuffled. *attrs : str Names of attributes to shuffle. Notes If the object is a hemlock.Page , the default shuffled attribute is its questions . If the object is a hemlock.ChoiceQuestion , the default shuffled attribute is its choices . Examples from hemlock import Compile as C , Label , Page , push_app_context app = push_app_context () p = Page ( * ( Label ( 'Label {} ' . format ( i )) for i in range ( 4 )), compile = C . shuffle () ) p . preview () . _compile () . preview ()","title":"Compile"},{"location":"functions/compile/#compile-functions","text":"","title":"Compile functions"},{"location":"functions/compile/#hemlockfunctionscompilecall_method","text":"def hemlock.functions.compile. call_method ( obj, method_name, *args, **kwargs ) [source] Calls one of the object's methods. Parameters: obj : Object whose methods will be called. method_name : str Names of the method to call. *args, **kwargs : Arguments and keyword arguments to pass to the method.","title":"hemlock.functions.compile.call_method"},{"location":"functions/compile/#examples","text":"from hemlock import Compile as C , Page , push_app_context app = push_app_context () p = Page ( error = 'Error message' , compile = C . call_method ( 'clear_error' )) p . preview () . _compile () . preview ()","title":"Examples"},{"location":"functions/compile/#hemlockfunctionscompileclear_error","text":"def hemlock.functions.compile. clear_error ( obj ) [source] Calls the object's clear_error method. Parameters: obj : Object whose clear_error method will be called.","title":"hemlock.functions.compile.clear_error"},{"location":"functions/compile/#examples_1","text":"from hemlock import Compile as C , Page , push_app_context app = push_app_context () p = Page ( error = 'Error message' , compile = C . clear_error ()) p . preview () . _compile () . preview ()","title":"Examples"},{"location":"functions/compile/#hemlockfunctionscompileclear_response","text":"def hemlock.functions.compile. clear_response ( obj ) [source] Calls the object's clear_response method. Parameters: obj : Object whose clear_response method will be called.","title":"hemlock.functions.compile.clear_response"},{"location":"functions/compile/#examples_2","text":"from hemlock import Compile as C , Input , Page , push_app_context app = push_app_context () p = Page ( Input ( response = 'Hello World' ), compile = C . clear_response ()) p . preview () . _compile () . preview ()","title":"Examples"},{"location":"functions/compile/#hemlockfunctionscompileshuffle","text":"def hemlock.functions.compile. shuffle ( obj, *attrs ) [source] Shuffle an object's attributes. Parameters: obj : Objects whose attributes should be shuffled. *attrs : str Names of attributes to shuffle.","title":"hemlock.functions.compile.shuffle"},{"location":"functions/compile/#notes","text":"If the object is a hemlock.Page , the default shuffled attribute is its questions . If the object is a hemlock.ChoiceQuestion , the default shuffled attribute is its choices .","title":"Notes"},{"location":"functions/compile/#examples_3","text":"from hemlock import Compile as C , Label , Page , push_app_context app = push_app_context () p = Page ( * ( Label ( 'Label {} ' . format ( i )) for i in range ( 4 )), compile = C . shuffle () ) p . preview () . _compile () . preview ()","title":"Examples"},{"location":"functions/debug/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Debug functions Debug functions tell the AI participant what to do during debugging. They generally take a selenium webdriver as their first argument and a page or question as their second argument. Notes The following examples open a webdriver. After running the examples, close the driver with driver.close() . By default, the last debug function of a page navigates. To remove this, run page.debug.pop() . hemlock.functions.debug. forward def hemlock.functions.debug. forward ( driver, page, max_wait=30, wait_interval=3 ) [source] Click the forward button. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page Examples from hemlock import Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( debug = [ D . debug_questions (), D . forward ()] ) p . preview ( driver ) p . _debug ( driver ) hemlock.functions.debug. back def hemlock.functions.debug. back ( driver, page, max_wait=30, wait_interval=1 ) [source] Click the back button. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page Examples from hemlock import Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( debug = [ D . debug_questions (), D . back ()] ) p . preview ( driver ) p . _debug ( driver ) hemlock.functions.debug. send_keys def hemlock.functions.debug. send_keys ( driver, question, *keys, p_num=0.5 ) [source] Send the specified keys to the <textarea> or <input> . Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question *keys : Keys to send to the textarea or input. If empty, keys are randomly selected. p_num : float, default=.5 Probability of sending a random number if keys are not specified (as opposed to a random string). Notes This debug function is skipped if the question is not displayed. Examples from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Input ( debug = D . send_keys ( 'hello world' )), debug = D . debug_questions () ) p . preview ( driver ) p . _debug ( driver ) hemlock.functions.debug. send_datetime def hemlock.functions.debug. send_datetime ( driver, question, datetime_=None ) [source] Send a datetime.datetime object to an input. Inputs should be of type 'date', 'datetime-local', 'month', 'time', or 'week', Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question datetime_ : datetime.datetime or None, default=None The datetime object to send. If None , a date and time are chosen randomly. Notes This debug function is skipped if the question is not displayed. Examples from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver from datetime import datetime app = push_app_context () driver = chromedriver () p = Page ( Input ( type = 'date' , debug = D . send_datetime ( datetime . utcnow ())), debug = D . debug_questions () ) p . preview ( driver ) p . _debug ( driver ) hemlock.functions.debug. random_input def hemlock.functions.debug. random_input ( driver, question ) [source] Default debug function for input questions. This function sends a random string or number if the input takes text, or a random datetime.datetime object if the input takes dates or times. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Input hemlock.functions.debug. click_slider_range def hemlock.functions.debug. click_slider_range ( driver, slider, target=None, tol=0, max_iter=10, max_wait=3, wait_interval=1 ) [source] Click a Bootstrap-slider input. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver slider : hemlock.Slider target : float or None, default=None Target value to which the slider should be dragged. If None , a random target value will be chosen. tol : float, default=0 Tolerance for error if the slider cannot be dragged to the exact target. max_iter : int, default=10 Maximum number of iterations for the slider to reach the target. max_wait : int, default=3 Number of iterations to wait for javascript to load the slider. wait_interval : int, default=1 Number of seconds to wait each iteration. Examples from hemlock import Debug as D , Page , Slider , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Slider ( debug = D . click_slider_range ( 80 )), debug = D . debug_questions () ) p . preview ( driver ) p . _debug ( driver ) hemlock.functions.debug. drag_range def hemlock.functions.debug. drag_range ( driver, range_, target=None, tol=0, max_iter=10 ) [source] Drag a range slider to specified target value. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver range_ : hemlock.Range target : float or None, default=None Target value to which the slider should be dragged. If None , a random target value will be chosen. tol : float, default=0 Tolerance for error if the slider cannot be dragged to the exact target. max_iter : int, default=10 Maximum number of iterations for the slider to reach the target. Notes This debug function is skipped if the question is not displayed. Examples from hemlock import Debug as D , Page , Range , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Range ( debug = D . drag_range ( 80 )), debug = D . debug_questions () ) p . preview ( driver ) p . _debug ( driver ) hemlock.functions.debug. click_choices def hemlock.functions.debug. click_choices ( driver, question, *values, if_selected=None, max_clicks=5 ) [source] Click on choices or options. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.ChoiceQuestion *values : Values of the choices on which to click. If no choices are specified, the debugger will click on random choices. if_selected : bool or None, default=None Indicates that the choices will be clicked only if they are already selected. If False the choices will be clicked only if they are not already selected. If None the choices will be clicked whether or not they are selected. Notes Will not attempt to click choices or options which are not displayed. Examples from hemlock import Check , Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Check ( '<p>Click \"Yes\".</p>' , [ 'Yes' , 'No' , 'Maybe' ], debug = D . click_choices ( 'Yes' ) ), debug = D . debug_questions () ) p . preview ( driver ) p . _debug ( driver ) hemlock.functions.debug. clear_choices def hemlock.functions.debug. clear_choices ( driver, question ) [source] Clear selected choices. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.ChoiceQuestion Notes Intended only for questions in which multiple choices may be selected. Examples from hemlock import Check , Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Check ( \"<p>Which ice cream flavors do you like?</p>\" , [ 'Chocolate' , 'Vanilla' , 'Strawberry' ], default = 'Chocolate' , multiple = True , debug = D . clear_choices () ), debug = D . debug_questions () ) p . preview ( driver ) p . _debug ( driver )","title":"Debug"},{"location":"functions/debug/#debug-functions","text":"Debug functions tell the AI participant what to do during debugging. They generally take a selenium webdriver as their first argument and a page or question as their second argument.","title":"Debug functions"},{"location":"functions/debug/#notes","text":"The following examples open a webdriver. After running the examples, close the driver with driver.close() . By default, the last debug function of a page navigates. To remove this, run page.debug.pop() .","title":"Notes"},{"location":"functions/debug/#hemlockfunctionsdebugforward","text":"def hemlock.functions.debug. forward ( driver, page, max_wait=30, wait_interval=3 ) [source] Click the forward button. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page","title":"hemlock.functions.debug.forward"},{"location":"functions/debug/#examples","text":"from hemlock import Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( debug = [ D . debug_questions (), D . forward ()] ) p . preview ( driver ) p . _debug ( driver )","title":"Examples"},{"location":"functions/debug/#hemlockfunctionsdebugback","text":"def hemlock.functions.debug. back ( driver, page, max_wait=30, wait_interval=1 ) [source] Click the back button. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page","title":"hemlock.functions.debug.back"},{"location":"functions/debug/#examples_1","text":"from hemlock import Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( debug = [ D . debug_questions (), D . back ()] ) p . preview ( driver ) p . _debug ( driver )","title":"Examples"},{"location":"functions/debug/#hemlockfunctionsdebugsend_keys","text":"def hemlock.functions.debug. send_keys ( driver, question, *keys, p_num=0.5 ) [source] Send the specified keys to the <textarea> or <input> . Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question *keys : Keys to send to the textarea or input. If empty, keys are randomly selected. p_num : float, default=.5 Probability of sending a random number if keys are not specified (as opposed to a random string).","title":"hemlock.functions.debug.send_keys"},{"location":"functions/debug/#notes_1","text":"This debug function is skipped if the question is not displayed.","title":"Notes"},{"location":"functions/debug/#examples_2","text":"from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Input ( debug = D . send_keys ( 'hello world' )), debug = D . debug_questions () ) p . preview ( driver ) p . _debug ( driver )","title":"Examples"},{"location":"functions/debug/#hemlockfunctionsdebugsend_datetime","text":"def hemlock.functions.debug. send_datetime ( driver, question, datetime_=None ) [source] Send a datetime.datetime object to an input. Inputs should be of type 'date', 'datetime-local', 'month', 'time', or 'week', Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question datetime_ : datetime.datetime or None, default=None The datetime object to send. If None , a date and time are chosen randomly.","title":"hemlock.functions.debug.send_datetime"},{"location":"functions/debug/#notes_2","text":"This debug function is skipped if the question is not displayed.","title":"Notes"},{"location":"functions/debug/#examples_3","text":"from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver from datetime import datetime app = push_app_context () driver = chromedriver () p = Page ( Input ( type = 'date' , debug = D . send_datetime ( datetime . utcnow ())), debug = D . debug_questions () ) p . preview ( driver ) p . _debug ( driver )","title":"Examples"},{"location":"functions/debug/#hemlockfunctionsdebugrandom_input","text":"def hemlock.functions.debug. random_input ( driver, question ) [source] Default debug function for input questions. This function sends a random string or number if the input takes text, or a random datetime.datetime object if the input takes dates or times. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Input","title":"hemlock.functions.debug.random_input"},{"location":"functions/debug/#hemlockfunctionsdebugclick_slider_range","text":"def hemlock.functions.debug. click_slider_range ( driver, slider, target=None, tol=0, max_iter=10, max_wait=3, wait_interval=1 ) [source] Click a Bootstrap-slider input. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver slider : hemlock.Slider target : float or None, default=None Target value to which the slider should be dragged. If None , a random target value will be chosen. tol : float, default=0 Tolerance for error if the slider cannot be dragged to the exact target. max_iter : int, default=10 Maximum number of iterations for the slider to reach the target. max_wait : int, default=3 Number of iterations to wait for javascript to load the slider. wait_interval : int, default=1 Number of seconds to wait each iteration.","title":"hemlock.functions.debug.click_slider_range"},{"location":"functions/debug/#examples_4","text":"from hemlock import Debug as D , Page , Slider , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Slider ( debug = D . click_slider_range ( 80 )), debug = D . debug_questions () ) p . preview ( driver ) p . _debug ( driver )","title":"Examples"},{"location":"functions/debug/#hemlockfunctionsdebugdrag_range","text":"def hemlock.functions.debug. drag_range ( driver, range_, target=None, tol=0, max_iter=10 ) [source] Drag a range slider to specified target value. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver range_ : hemlock.Range target : float or None, default=None Target value to which the slider should be dragged. If None , a random target value will be chosen. tol : float, default=0 Tolerance for error if the slider cannot be dragged to the exact target. max_iter : int, default=10 Maximum number of iterations for the slider to reach the target.","title":"hemlock.functions.debug.drag_range"},{"location":"functions/debug/#notes_3","text":"This debug function is skipped if the question is not displayed.","title":"Notes"},{"location":"functions/debug/#examples_5","text":"from hemlock import Debug as D , Page , Range , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Range ( debug = D . drag_range ( 80 )), debug = D . debug_questions () ) p . preview ( driver ) p . _debug ( driver )","title":"Examples"},{"location":"functions/debug/#hemlockfunctionsdebugclick_choices","text":"def hemlock.functions.debug. click_choices ( driver, question, *values, if_selected=None, max_clicks=5 ) [source] Click on choices or options. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.ChoiceQuestion *values : Values of the choices on which to click. If no choices are specified, the debugger will click on random choices. if_selected : bool or None, default=None Indicates that the choices will be clicked only if they are already selected. If False the choices will be clicked only if they are not already selected. If None the choices will be clicked whether or not they are selected.","title":"hemlock.functions.debug.click_choices"},{"location":"functions/debug/#notes_4","text":"Will not attempt to click choices or options which are not displayed.","title":"Notes"},{"location":"functions/debug/#examples_6","text":"from hemlock import Check , Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Check ( '<p>Click \"Yes\".</p>' , [ 'Yes' , 'No' , 'Maybe' ], debug = D . click_choices ( 'Yes' ) ), debug = D . debug_questions () ) p . preview ( driver ) p . _debug ( driver )","title":"Examples"},{"location":"functions/debug/#hemlockfunctionsdebugclear_choices","text":"def hemlock.functions.debug. clear_choices ( driver, question ) [source] Clear selected choices. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.ChoiceQuestion","title":"hemlock.functions.debug.clear_choices"},{"location":"functions/debug/#notes_5","text":"Intended only for questions in which multiple choices may be selected.","title":"Notes"},{"location":"functions/debug/#examples_7","text":"from hemlock import Check , Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Check ( \"<p>Which ice cream flavors do you like?</p>\" , [ 'Chocolate' , 'Vanilla' , 'Strawberry' ], default = 'Chocolate' , multiple = True , debug = D . clear_choices () ), debug = D . debug_questions () ) p . preview ( driver ) p . _debug ( driver )","title":"Examples"},{"location":"functions/submit/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Submit functions hemlock.functions.submit. correct_choices def hemlock.functions.submit. correct_choices ( question, *values ) [source] Convert the question's data to a 0-1 indicator that the participant selected the correct choice(s). Parameters: question : hemlock.ChoiceQuestion *values : Values of the correct choices. Notes If the participant can only select one choice, indicate whether the participant selected one of the correct choices. Examples from hemlock import Check , Submit as S , push_app_context app = push_app_context () check = Check ( '<p>Select the correct choice.</p>' , [ 'correct' , 'incorrect' , 'also incorrect' ], submit = S . correct_choices ( 'correct' ) ) check . response = check . choices [ 0 ] check . _submit () . data Out: 1 hemlock.functions.submit. data_type def hemlock.functions.submit. data_type ( question, new_type, *args, **kwargs ) [source] Convert the quesiton's data to a new type. If the question's data cannot be converted, it is changed to None . Parameters: question : hemlock.Question new_type : class *args, **kwargs : Arguments and keyword arguments to pass to the new_type constructor. Examples from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = '1' , submit = S . data_type ( int )) inpt . _submit () inpt . data , isinstance ( inpt . data , int ) Out: (1, True) hemlock.functions.submit. match def hemlock.functions.submit. match ( question, pattern ) [source] Convert the question's data to a 0-1 indicator that the data matches the pattern. Parameters: question : hemlock.Question pattern : str or hemlock.Question Regex pattern to match. If this is a Question , the pattern is the question's response '. Examples from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = 'hello world' , submit = S . match ( 'hello *' )) inpt . _submit () . data Out: 1 hemlock.functions.submit. eq def hemlock.functions.submit. eq ( question, value, data_type=None ) [source] Convert the question's data to a 0-1 indicator that the question's data equals the given value. Parameters: question : hemlock.Question value : Value that the data should equal. If a Question , then value.data is used. data_type : class or None, default=None Expected type of data. If None , the type of value will be used. Examples from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = 50 , submit = S . eq ( 50 )) inpt . _submit () inpt . data Out: 1 hemlock.functions.submit. neq def hemlock.functions.submit. neq ( question, value, data_type=None ) [source] Convert the question's data to a 0-1 indicator that the question's data does not equal the given value. Parameters: question : hemlock.Question value : Value that the data should not equal. If a Question , then value.data is used. data_type : class or None, default=None Expected type of data. If None , the type of value will be used. Examples from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = 50 , submit = S . neq ( 50 )) inpt . _submit () inpt . data Out: 0 hemlock.functions.submit. max def hemlock.functions.submit. max ( question, max, data_type=None ) [source] Convert the question's data to a 0-1 indicator that the question's data is less than the maximum value. Parameters: question : hemlock.Question max : Maximum value. If a Question , then max.data is used. data_type : class or None, default=None Expected type of data. If None , the type of max will be used. Examples from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = 101 , submit = S . max ( 100 )) inpt . _submit () inpt . data Out: 0 hemlock.functions.submit. min def hemlock.functions.submit. min ( question, min, data_type=None ) [source] Convert the question's data to a 0-1 indicator that the question's data is greater than the minimum value. Parameters: question : hemlock.Question min : Minimum value. If a Question , then min.data is used. data_type : class or None, default=None Expected type of data. If None , the type of min will be used. Examples from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data =- 1 , submit = S . min ( 0 )) inpt . _submit () inpt . data Out: 0 hemlock.functions.submit. range def hemlock.functions.submit. range ( question, min, max, data_type=None ) [source] Convert the question's data to a 0-1 indicator that the question's data is within the range of [min, max] . Parameters: question : hemlock.Question min : Minimum value. If a Question , then min.data is used. max : Maximum value. If a Question , then max.data is used. data_type : class or None, default=None Expected type of data. If None , the type of min and max will be used. Examples from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = 50 , submit = S . range ( 0 , 100 )) inpt . _submit () inpt . data Out: 1","title":"Submit"},{"location":"functions/submit/#submit-functions","text":"","title":"Submit functions"},{"location":"functions/submit/#hemlockfunctionssubmitcorrect_choices","text":"def hemlock.functions.submit. correct_choices ( question, *values ) [source] Convert the question's data to a 0-1 indicator that the participant selected the correct choice(s). Parameters: question : hemlock.ChoiceQuestion *values : Values of the correct choices.","title":"hemlock.functions.submit.correct_choices"},{"location":"functions/submit/#notes","text":"If the participant can only select one choice, indicate whether the participant selected one of the correct choices.","title":"Notes"},{"location":"functions/submit/#examples","text":"from hemlock import Check , Submit as S , push_app_context app = push_app_context () check = Check ( '<p>Select the correct choice.</p>' , [ 'correct' , 'incorrect' , 'also incorrect' ], submit = S . correct_choices ( 'correct' ) ) check . response = check . choices [ 0 ] check . _submit () . data Out: 1","title":"Examples"},{"location":"functions/submit/#hemlockfunctionssubmitdata_type","text":"def hemlock.functions.submit. data_type ( question, new_type, *args, **kwargs ) [source] Convert the quesiton's data to a new type. If the question's data cannot be converted, it is changed to None . Parameters: question : hemlock.Question new_type : class *args, **kwargs : Arguments and keyword arguments to pass to the new_type constructor.","title":"hemlock.functions.submit.data_type"},{"location":"functions/submit/#examples_1","text":"from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = '1' , submit = S . data_type ( int )) inpt . _submit () inpt . data , isinstance ( inpt . data , int ) Out: (1, True)","title":"Examples"},{"location":"functions/submit/#hemlockfunctionssubmitmatch","text":"def hemlock.functions.submit. match ( question, pattern ) [source] Convert the question's data to a 0-1 indicator that the data matches the pattern. Parameters: question : hemlock.Question pattern : str or hemlock.Question Regex pattern to match. If this is a Question , the pattern is the question's response '.","title":"hemlock.functions.submit.match"},{"location":"functions/submit/#examples_2","text":"from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = 'hello world' , submit = S . match ( 'hello *' )) inpt . _submit () . data Out: 1","title":"Examples"},{"location":"functions/submit/#hemlockfunctionssubmiteq","text":"def hemlock.functions.submit. eq ( question, value, data_type=None ) [source] Convert the question's data to a 0-1 indicator that the question's data equals the given value. Parameters: question : hemlock.Question value : Value that the data should equal. If a Question , then value.data is used. data_type : class or None, default=None Expected type of data. If None , the type of value will be used.","title":"hemlock.functions.submit.eq"},{"location":"functions/submit/#examples_3","text":"from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = 50 , submit = S . eq ( 50 )) inpt . _submit () inpt . data Out: 1","title":"Examples"},{"location":"functions/submit/#hemlockfunctionssubmitneq","text":"def hemlock.functions.submit. neq ( question, value, data_type=None ) [source] Convert the question's data to a 0-1 indicator that the question's data does not equal the given value. Parameters: question : hemlock.Question value : Value that the data should not equal. If a Question , then value.data is used. data_type : class or None, default=None Expected type of data. If None , the type of value will be used.","title":"hemlock.functions.submit.neq"},{"location":"functions/submit/#examples_4","text":"from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = 50 , submit = S . neq ( 50 )) inpt . _submit () inpt . data Out: 0","title":"Examples"},{"location":"functions/submit/#hemlockfunctionssubmitmax","text":"def hemlock.functions.submit. max ( question, max, data_type=None ) [source] Convert the question's data to a 0-1 indicator that the question's data is less than the maximum value. Parameters: question : hemlock.Question max : Maximum value. If a Question , then max.data is used. data_type : class or None, default=None Expected type of data. If None , the type of max will be used.","title":"hemlock.functions.submit.max"},{"location":"functions/submit/#examples_5","text":"from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = 101 , submit = S . max ( 100 )) inpt . _submit () inpt . data Out: 0","title":"Examples"},{"location":"functions/submit/#hemlockfunctionssubmitmin","text":"def hemlock.functions.submit. min ( question, min, data_type=None ) [source] Convert the question's data to a 0-1 indicator that the question's data is greater than the minimum value. Parameters: question : hemlock.Question min : Minimum value. If a Question , then min.data is used. data_type : class or None, default=None Expected type of data. If None , the type of min will be used.","title":"hemlock.functions.submit.min"},{"location":"functions/submit/#examples_6","text":"from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data =- 1 , submit = S . min ( 0 )) inpt . _submit () inpt . data Out: 0","title":"Examples"},{"location":"functions/submit/#hemlockfunctionssubmitrange","text":"def hemlock.functions.submit. range ( question, min, max, data_type=None ) [source] Convert the question's data to a 0-1 indicator that the question's data is within the range of [min, max] . Parameters: question : hemlock.Question min : Minimum value. If a Question , then min.data is used. max : Maximum value. If a Question , then max.data is used. data_type : class or None, default=None Expected type of data. If None , the type of min and max will be used.","title":"hemlock.functions.submit.range"},{"location":"functions/submit/#examples_7","text":"from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = 50 , submit = S . range ( 0 , 100 )) inpt . _submit () inpt . data Out: 1","title":"Examples"},{"location":"functions/validate/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Validation functions These are built-in functions to validate a participant's response to a question. They return None if the response is valid, and an error message if the repsonse is invalid. hemlock.functions.validate. response_type def hemlock.functions.validate. response_type ( question, resp_type ) [source] Validate that the response can be converted to a given type. Parameters: question : hemlock.Question resp_type : class The required type of response. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . response_type ( float )) inpt . _validate () inpt . error Out: Please enter a number. hemlock.functions.validate. require def hemlock.functions.validate. require ( question ) [source] Require a response to this question. Parameters: question : hemlock.Question Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = None , validate = V . require ()) inpt . _validate () inpt . error Out: Please respond to this question. hemlock.functions.validate. is_in def hemlock.functions.validate. is_in ( question, valid_set, resp_type=None ) [source] Validate that the question response is in a set of valid responses. Parameters: question : hemlock.Question valid_set : iterable Set of valid responses. resp_type : class or None, default=None Type of response expected; should match the type of elements in valid_set . Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'earth' , validate = V . is_in (( 'wind' , 'fire' ))) inpt . _validate () inpt . error Out: Please enter wind or fire. hemlock.functions.validate. is_not_in def hemlock.functions.validate. is_not_in ( question, invalid_set, resp_type=None ) [source] Validate that the question response is not in a set of invalid responses. Parameters: question : hemlock.Question invalid_set : iterable Set of invalid responses. resp_type : class or None, default=None Type of response expected; should match the type of elements in invalid_set . Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'earth' , validate = V . is_not_in (( 'earth' , 'wind' , 'fire' )) ) inpt . _validate () inpt . error Out: Please do not enter earth, wind, or fire. hemlock.functions.validate. eq def hemlock.functions.validate. eq ( question, value, resp_type=None ) [source] Validate that the response equals the given value. Parameters: question : hemlock.Question value : Value that the response should equal. If a Question , then value.data is used. resp_type : class or None, default=None Expected type of response. If None , the type of value will be used. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '51' , validate = V . eq ( 50 )) inpt . _validate () inpt . error Out: 'Please enter 50' hemlock.functions.validate. neq def hemlock.functions.validate. neq ( question, value, resp_type=None ) [source] Validate that the response does not equal the given value. Parameters: question : hemlock.Question value : Value that the response should not equal. If a Question , then value.data is used. resp_type : class or None, default=None Expected type of response. If None , the type of value will be used. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '50' , validate = V . neq ( 50 )) inpt . _validate () inpt . error Out: 'Please do not enter 50' hemlock.functions.validate. max def hemlock.functions.validate. max ( question, max, resp_type=None ) [source] Validate that the response does not exceed a maximum value. Parameters: question : hemlock.Question max : Maximum value. If a Question , then max.data is the maximum value. resp_type : class or None, default=None Expected type of response. If None , the type of max will be used. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '101' , validate = V . max ( 100 )) inpt . _validate () inpt . error Out: Please enter a response less than 100. hemlock.functions.validate. min def hemlock.functions.validate. min ( question, min, resp_type=None ) [source] Validate that the response does not deceed a minumum value. Parameters: question : hemlock.Question min : Minimum value. If a Question , then min.data is the minimum value. resp_type : class or None, default=None Expected type of response. If None , the type of min will be used. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '-1' , validate = V . min_val ( 0 )) inpt . _validate () inpt . error Out: Please enter a response greater than 0. hemlock.functions.validate. range def hemlock.functions.validate. range ( question, min, max, resp_type=None ) [source] Validate that the response is in a given range. Parameters: question : hemlock.Question min : Minimum value for the question response. If a Question , then min.data is the minimum value. max : Maximum value for the question response. If a Question , then max.data is the maximum value. resp_type : class or None, default=None Expected type of response. If None , the expected response type is the type of min and max , which must be of the same type. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '101' , validate = V . range ( 0 , 100 )) inpt . _validate () inpt . error Out: Please enter a response between 0 and 100. hemlock.functions.validate. exact_len def hemlock.functions.validate. exact_len ( question, len_ ) [source] Validates the exact length of the repsonse. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question len_ : int Required length of the response. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . exact_len ( 5 )) inpt . _validate () inpt . error Out: Please enter exactly 5 characters. hemlock.functions.validate. max_len def hemlock.functions.validate. max_len ( question, max_ ) [source] Validates the maximum length of the response. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question max_ : int Maximum length of the response. Notes A response of None is assumed to satisfy the max length validation. Use Validate.require to require a response that is not None . Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . max_len ( 5 )) inpt . _validate () inpt . error Out: Please enter at most 5 characters. hemlock.functions.validate. min_len def hemlock.functions.validate. min_len ( question, min_ ) [source] Valiadates the minimum length of the response. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question min_ : int Minimum length of the response. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . min_len ( 15 )) inpt . _validate () inpt . error Out: Please enter at least 15 characters. hemlock.functions.validate. range_len def hemlock.functions.validate. range_len ( question, min_, max_ ) [source] Validates the range of the response length. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question min_ : int Minimum response length. max_ : int Maximum response length. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . range_len ( 5 , 10 )) inpt . _validate () inpt . error Out: Please enter 5 to 10 characters. hemlock.functions.validate. exact_words def hemlock.functions.validate. exact_words ( question, nwords ) [source] Validate the exact number of words in the response. Parameters: question : hemlock.Question nwords : int Required number of words. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . exact_words ( 1 )) inpt . _validate () inpt . error Out: Please enter exactly 1 word. hemlock.functions.validate. max_words def hemlock.functions.validate. max_words ( question, max_ ) [source] Validates the maximum number of words in the response. Parameters: question : hemlock.Question max_ : int Maximum number of words. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . max_words ( 1 )) inpt . _validate () inpt . error Out: Please enter at most 1 word. hemlock.functions.validate. min_words def hemlock.functions.validate. min_words ( question, min_ ) [source] Validates the minimum number of words in the repsonse. Parameters: question : hemlock.Question min_ : int Minimum number of words. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . min_words ( 3 )) inpt . _validate () inpt . error Out: Please enter at least 3 words. hemlock.functions.validate. range_words def hemlock.functions.validate. range_words ( question, min_, max_ ) [source] Validates the number of words falls in a given range. Parameters: question : hemlock.Question min_ : int Minumum number of words. max_ : int Maximum number of words. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . range_words ( 3 , 5 )) inpt . _validate () inpt . error Out: Please enter between 3 and 5 words. hemlock.functions.validate. exact_decimals def hemlock.functions.validate. exact_decimals ( question, ndec ) [source] Validates the exact number of decimals. Parameters: question : hemlock.Question ndec : int Required number of decimals. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1' , validate = V . exact_decimals ( 2 )) inpt . _validate () inpt . error Out: Please enter a number with exactly 2 decimals. hemlock.functions.validate. max_decimals def hemlock.functions.validate. max_decimals ( question, max_ ) [source] Validates the maximum number of decimals. Parameters: question : hemlock.Question max_ : int Maximum number of decimals. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1.123' , validate = V . max_decimals ( 2 )) inpt . _validate () inpt . error Out: Please enter a number with at most 2 decimals. hemlock.functions.validate. min_decimals def hemlock.functions.validate. min_decimals ( question, min_ ) [source] Validates the minumum number of decimals. Parameters: question : hemlock.Question min_ : int Minumum number of decimals. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1' , validate = V . min_decimals ( 2 )) inpt . _validate () inpt . error Out: Please enter a number with at least 2 decimals. hemlock.functions.validate. range_decimals def hemlock.functions.validate. range_decimals ( question, min_, max_ ) [source] Validates the number of decimals are in a given range. Parameters: question : hemlock.Question min_ : int Minimum number of decimals. max_ : int Maximum number of decimals. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1.123' , validate = V . range_decimals ( 0 , 2 )) inpt . _validate () inpt . error Out: Please enter a number with 0 to 2 decimals. hemlock.functions.validate. match def hemlock.functions.validate. match ( question, pattern ) [source] Validate that the response matches the regex pattern. Parameters: question : hemlock.Question pattern : str or hemlock.Question Regex pattern to match. If this is a Question , the pattern is the question's response '. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . match ( 'goodbye *' )) inpt . _validate () inpt . error Out: Please enter a response with the correct pattern. hemlock.functions.validate. correct_choices def hemlock.functions.validate. correct_choices ( question, *values ) [source] Validate that selected choice(s) is correct. Parameters: question : hemlock.Question *values : Values of the correct choices. Examples from hemlock import Check , Validate as V , push_app_context app = push_app_context () check = Check ( '<p>Select the correct choice.</p>' , [ 'correct' , 'incorrect' , 'also incorrect' ], validate = V . correct_choices ( 'correct' ), ) check . response = check . choices [ 1 ] check . _validate () check . error Out: Please select the correct choice.","title":"Validate"},{"location":"functions/validate/#validation-functions","text":"These are built-in functions to validate a participant's response to a question. They return None if the response is valid, and an error message if the repsonse is invalid.","title":"Validation functions"},{"location":"functions/validate/#hemlockfunctionsvalidateresponse_type","text":"def hemlock.functions.validate. response_type ( question, resp_type ) [source] Validate that the response can be converted to a given type. Parameters: question : hemlock.Question resp_type : class The required type of response.","title":"hemlock.functions.validate.response_type"},{"location":"functions/validate/#examples","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . response_type ( float )) inpt . _validate () inpt . error Out: Please enter a number.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidaterequire","text":"def hemlock.functions.validate. require ( question ) [source] Require a response to this question. Parameters: question : hemlock.Question","title":"hemlock.functions.validate.require"},{"location":"functions/validate/#examples_1","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = None , validate = V . require ()) inpt . _validate () inpt . error Out: Please respond to this question.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidateis_in","text":"def hemlock.functions.validate. is_in ( question, valid_set, resp_type=None ) [source] Validate that the question response is in a set of valid responses. Parameters: question : hemlock.Question valid_set : iterable Set of valid responses. resp_type : class or None, default=None Type of response expected; should match the type of elements in valid_set .","title":"hemlock.functions.validate.is_in"},{"location":"functions/validate/#examples_2","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'earth' , validate = V . is_in (( 'wind' , 'fire' ))) inpt . _validate () inpt . error Out: Please enter wind or fire.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidateis_not_in","text":"def hemlock.functions.validate. is_not_in ( question, invalid_set, resp_type=None ) [source] Validate that the question response is not in a set of invalid responses. Parameters: question : hemlock.Question invalid_set : iterable Set of invalid responses. resp_type : class or None, default=None Type of response expected; should match the type of elements in invalid_set .","title":"hemlock.functions.validate.is_not_in"},{"location":"functions/validate/#examples_3","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'earth' , validate = V . is_not_in (( 'earth' , 'wind' , 'fire' )) ) inpt . _validate () inpt . error Out: Please do not enter earth, wind, or fire.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidateeq","text":"def hemlock.functions.validate. eq ( question, value, resp_type=None ) [source] Validate that the response equals the given value. Parameters: question : hemlock.Question value : Value that the response should equal. If a Question , then value.data is used. resp_type : class or None, default=None Expected type of response. If None , the type of value will be used.","title":"hemlock.functions.validate.eq"},{"location":"functions/validate/#examples_4","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '51' , validate = V . eq ( 50 )) inpt . _validate () inpt . error Out: 'Please enter 50'","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidateneq","text":"def hemlock.functions.validate. neq ( question, value, resp_type=None ) [source] Validate that the response does not equal the given value. Parameters: question : hemlock.Question value : Value that the response should not equal. If a Question , then value.data is used. resp_type : class or None, default=None Expected type of response. If None , the type of value will be used.","title":"hemlock.functions.validate.neq"},{"location":"functions/validate/#examples_5","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '50' , validate = V . neq ( 50 )) inpt . _validate () inpt . error Out: 'Please do not enter 50'","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidatemax","text":"def hemlock.functions.validate. max ( question, max, resp_type=None ) [source] Validate that the response does not exceed a maximum value. Parameters: question : hemlock.Question max : Maximum value. If a Question , then max.data is the maximum value. resp_type : class or None, default=None Expected type of response. If None , the type of max will be used.","title":"hemlock.functions.validate.max"},{"location":"functions/validate/#examples_6","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '101' , validate = V . max ( 100 )) inpt . _validate () inpt . error Out: Please enter a response less than 100.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidatemin","text":"def hemlock.functions.validate. min ( question, min, resp_type=None ) [source] Validate that the response does not deceed a minumum value. Parameters: question : hemlock.Question min : Minimum value. If a Question , then min.data is the minimum value. resp_type : class or None, default=None Expected type of response. If None , the type of min will be used.","title":"hemlock.functions.validate.min"},{"location":"functions/validate/#examples_7","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '-1' , validate = V . min_val ( 0 )) inpt . _validate () inpt . error Out: Please enter a response greater than 0.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidaterange","text":"def hemlock.functions.validate. range ( question, min, max, resp_type=None ) [source] Validate that the response is in a given range. Parameters: question : hemlock.Question min : Minimum value for the question response. If a Question , then min.data is the minimum value. max : Maximum value for the question response. If a Question , then max.data is the maximum value. resp_type : class or None, default=None Expected type of response. If None , the expected response type is the type of min and max , which must be of the same type.","title":"hemlock.functions.validate.range"},{"location":"functions/validate/#examples_8","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '101' , validate = V . range ( 0 , 100 )) inpt . _validate () inpt . error Out: Please enter a response between 0 and 100.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidateexact_len","text":"def hemlock.functions.validate. exact_len ( question, len_ ) [source] Validates the exact length of the repsonse. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question len_ : int Required length of the response.","title":"hemlock.functions.validate.exact_len"},{"location":"functions/validate/#examples_9","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . exact_len ( 5 )) inpt . _validate () inpt . error Out: Please enter exactly 5 characters.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidatemax_len","text":"def hemlock.functions.validate. max_len ( question, max_ ) [source] Validates the maximum length of the response. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question max_ : int Maximum length of the response.","title":"hemlock.functions.validate.max_len"},{"location":"functions/validate/#notes","text":"A response of None is assumed to satisfy the max length validation. Use Validate.require to require a response that is not None .","title":"Notes"},{"location":"functions/validate/#examples_10","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . max_len ( 5 )) inpt . _validate () inpt . error Out: Please enter at most 5 characters.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidatemin_len","text":"def hemlock.functions.validate. min_len ( question, min_ ) [source] Valiadates the minimum length of the response. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question min_ : int Minimum length of the response.","title":"hemlock.functions.validate.min_len"},{"location":"functions/validate/#examples_11","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . min_len ( 15 )) inpt . _validate () inpt . error Out: Please enter at least 15 characters.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidaterange_len","text":"def hemlock.functions.validate. range_len ( question, min_, max_ ) [source] Validates the range of the response length. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question min_ : int Minimum response length. max_ : int Maximum response length.","title":"hemlock.functions.validate.range_len"},{"location":"functions/validate/#examples_12","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . range_len ( 5 , 10 )) inpt . _validate () inpt . error Out: Please enter 5 to 10 characters.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidateexact_words","text":"def hemlock.functions.validate. exact_words ( question, nwords ) [source] Validate the exact number of words in the response. Parameters: question : hemlock.Question nwords : int Required number of words.","title":"hemlock.functions.validate.exact_words"},{"location":"functions/validate/#examples_13","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . exact_words ( 1 )) inpt . _validate () inpt . error Out: Please enter exactly 1 word.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidatemax_words","text":"def hemlock.functions.validate. max_words ( question, max_ ) [source] Validates the maximum number of words in the response. Parameters: question : hemlock.Question max_ : int Maximum number of words.","title":"hemlock.functions.validate.max_words"},{"location":"functions/validate/#examples_14","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . max_words ( 1 )) inpt . _validate () inpt . error Out: Please enter at most 1 word.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidatemin_words","text":"def hemlock.functions.validate. min_words ( question, min_ ) [source] Validates the minimum number of words in the repsonse. Parameters: question : hemlock.Question min_ : int Minimum number of words.","title":"hemlock.functions.validate.min_words"},{"location":"functions/validate/#examples_15","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . min_words ( 3 )) inpt . _validate () inpt . error Out: Please enter at least 3 words.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidaterange_words","text":"def hemlock.functions.validate. range_words ( question, min_, max_ ) [source] Validates the number of words falls in a given range. Parameters: question : hemlock.Question min_ : int Minumum number of words. max_ : int Maximum number of words.","title":"hemlock.functions.validate.range_words"},{"location":"functions/validate/#examples_16","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . range_words ( 3 , 5 )) inpt . _validate () inpt . error Out: Please enter between 3 and 5 words.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidateexact_decimals","text":"def hemlock.functions.validate. exact_decimals ( question, ndec ) [source] Validates the exact number of decimals. Parameters: question : hemlock.Question ndec : int Required number of decimals.","title":"hemlock.functions.validate.exact_decimals"},{"location":"functions/validate/#examples_17","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1' , validate = V . exact_decimals ( 2 )) inpt . _validate () inpt . error Out: Please enter a number with exactly 2 decimals.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidatemax_decimals","text":"def hemlock.functions.validate. max_decimals ( question, max_ ) [source] Validates the maximum number of decimals. Parameters: question : hemlock.Question max_ : int Maximum number of decimals.","title":"hemlock.functions.validate.max_decimals"},{"location":"functions/validate/#examples_18","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1.123' , validate = V . max_decimals ( 2 )) inpt . _validate () inpt . error Out: Please enter a number with at most 2 decimals.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidatemin_decimals","text":"def hemlock.functions.validate. min_decimals ( question, min_ ) [source] Validates the minumum number of decimals. Parameters: question : hemlock.Question min_ : int Minumum number of decimals.","title":"hemlock.functions.validate.min_decimals"},{"location":"functions/validate/#examples_19","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1' , validate = V . min_decimals ( 2 )) inpt . _validate () inpt . error Out: Please enter a number with at least 2 decimals.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidaterange_decimals","text":"def hemlock.functions.validate. range_decimals ( question, min_, max_ ) [source] Validates the number of decimals are in a given range. Parameters: question : hemlock.Question min_ : int Minimum number of decimals. max_ : int Maximum number of decimals.","title":"hemlock.functions.validate.range_decimals"},{"location":"functions/validate/#examples_20","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1.123' , validate = V . range_decimals ( 0 , 2 )) inpt . _validate () inpt . error Out: Please enter a number with 0 to 2 decimals.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidatematch","text":"def hemlock.functions.validate. match ( question, pattern ) [source] Validate that the response matches the regex pattern. Parameters: question : hemlock.Question pattern : str or hemlock.Question Regex pattern to match. If this is a Question , the pattern is the question's response '.","title":"hemlock.functions.validate.match"},{"location":"functions/validate/#examples_21","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . match ( 'goodbye *' )) inpt . _validate () inpt . error Out: Please enter a response with the correct pattern.","title":"Examples"},{"location":"functions/validate/#hemlockfunctionsvalidatecorrect_choices","text":"def hemlock.functions.validate. correct_choices ( question, *values ) [source] Validate that selected choice(s) is correct. Parameters: question : hemlock.Question *values : Values of the correct choices.","title":"hemlock.functions.validate.correct_choices"},{"location":"functions/validate/#examples_22","text":"from hemlock import Check , Validate as V , push_app_context app = push_app_context () check = Check ( '<p>Select the correct choice.</p>' , [ 'correct' , 'incorrect' , 'also incorrect' ], validate = V . correct_choices ( 'correct' ), ) check . response = check . choices [ 1 ] check . _validate () check . error Out: Please select the correct choice.","title":"Examples"},{"location":"models/bases/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Common bases and mixins hemlock. Base class hemlock. Base ( **kwargs ) [source] Base for all Hemlock models. Interits from sqlalchemy_modelid.ModelIdBase . Parameters: **kwargs : You can set any attribute by passing it as a keyword argument. Attributes: name : str or None, default=None Used primarily as a filter for database querying. hemlock. BranchingBase Attributes: navigate : callabe or None, default=None A callable which returns the next branch. hemlock. Data Polymorphic base for all objects which contribute data to the dataframe. Data elements 'pack' their data and return it to their participant, who in turn sends it to the data store. Attributes: data : sqlalchemy_mutable.MutableType, default=None Data this element contributes to the dataframe. data_rows : int, default=1 Number of rows this data element contributes to the dataframe for its participant. If negative, this data element will 'fill in' any emtpy rows at the end of the dataframe with its most recent value. index : int or None, default=None Order in which this data element appears in its parent; usually a hemlock.Branch , hemlock.Page , or hemlock.Question . var : str or None, default=None Variable name associated with this data element. If None , the data will not be recorded. record_order : bool, default=False Indicates that the order of this data element should be recorded in the datafame. The order is the order in which this element appeared relative to other elements with the same variable name. record_index : bool, default=False Indicates that the index of this data element should be recorded in the dataframe. The index is the order in which this element appeared relative to other elements with the same parent. For example, the index of a question is the order in which the question appeared on its page. record_choice_index : bool, default=False Indicates that the index of this data element's choices should be recorded in the dataframe. For example, a hemlock.Check question has multiple choices that the participant can select. The index of a choice is its index in the question's choice list.","title":"Bases"},{"location":"models/bases/#common-bases-and-mixins","text":"","title":"Common bases and mixins"},{"location":"models/bases/#hemlockbase","text":"class hemlock. Base ( **kwargs ) [source] Base for all Hemlock models. Interits from sqlalchemy_modelid.ModelIdBase . Parameters: **kwargs : You can set any attribute by passing it as a keyword argument. Attributes: name : str or None, default=None Used primarily as a filter for database querying.","title":"hemlock.Base"},{"location":"models/bases/#hemlockbranchingbase","text":"Attributes: navigate : callabe or None, default=None A callable which returns the next branch.","title":"hemlock.BranchingBase"},{"location":"models/bases/#hemlockdata","text":"Polymorphic base for all objects which contribute data to the dataframe. Data elements 'pack' their data and return it to their participant, who in turn sends it to the data store. Attributes: data : sqlalchemy_mutable.MutableType, default=None Data this element contributes to the dataframe. data_rows : int, default=1 Number of rows this data element contributes to the dataframe for its participant. If negative, this data element will 'fill in' any emtpy rows at the end of the dataframe with its most recent value. index : int or None, default=None Order in which this data element appears in its parent; usually a hemlock.Branch , hemlock.Page , or hemlock.Question . var : str or None, default=None Variable name associated with this data element. If None , the data will not be recorded. record_order : bool, default=False Indicates that the order of this data element should be recorded in the datafame. The order is the order in which this element appeared relative to other elements with the same variable name. record_index : bool, default=False Indicates that the index of this data element should be recorded in the dataframe. The index is the order in which this element appeared relative to other elements with the same parent. For example, the index of a question is the order in which the question appeared on its page. record_choice_index : bool, default=False Indicates that the index of this data element's choices should be recorded in the dataframe. For example, a hemlock.Check question has multiple choices that the participant can select. The index of a choice is its index in the question's choice list.","title":"hemlock.Data"},{"location":"models/branch/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Branch hemlock. Branch class hemlock. Branch ( *pages, **kwargs ) [source] Branches are stacked in a participant's branch stack. A branch contains a queue of pages which it displays to its participant. Inherits from hemlock.models.Base . Parameters: *pages : hemlock.Page Pages which belong to this branch. Attributes: index : int or None, default=None Order in which this branch appears in its participant's branch stack. Relationships: part : hemlock.Participant Participant to whose branch stack this page belongs. origin_branch : hemlock.Branch The branch from which this branch originated. next_branch : hemlock.Branch The branch which originated from this branch. origin_page : hemlock.Page The page from which this branch originated. Note that branches can originate from other branches or pages. pages : list of hemlock.Page The queue of pages belonging to this branch. start_page : hemlock.Page or None The first page in the page queue, if non-empty. current_page : hemlock.Page Current page of this branch (head of the page queue). embedded : list of hemlock.Embedded Embedded data elements. data_elements : list of hemlock.DataElement All data elements belonging to this branch, in order of embedded data then page data. navigate : hemlock.Navigate Navigate function which returns a new branch once the participant has reached the end of this branch (i.e. the end of the page queue associated with this branch). navigate_worker : hemlock.Worker Worker which handles complex navigate functions. Examples from hemlock import Branch , Label , Page , push_app_context app = push_app_context () Branch ( Page ( Label ( 'Hello World' )), Page ( Label ( 'Hello Moon' )), Page ( Label ( 'Hello Star' )) ) . preview () This will open all of the branch's pages in separate tabs. Methods preview ( self, driver=None ) [source] Preview the page queue in the a browser window. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver or None, default=None Driver to preview page debugging. If None , the page will be opened in a web browser. Returns: self : helock.Branch view_nav ( self ) [source] Print this branch's page queue for debugging purposes. Returns: self : hemlock.Branch","title":"Branch"},{"location":"models/branch/#branch","text":"","title":"Branch"},{"location":"models/branch/#hemlockbranch","text":"class hemlock. Branch ( *pages, **kwargs ) [source] Branches are stacked in a participant's branch stack. A branch contains a queue of pages which it displays to its participant. Inherits from hemlock.models.Base . Parameters: *pages : hemlock.Page Pages which belong to this branch. Attributes: index : int or None, default=None Order in which this branch appears in its participant's branch stack. Relationships: part : hemlock.Participant Participant to whose branch stack this page belongs. origin_branch : hemlock.Branch The branch from which this branch originated. next_branch : hemlock.Branch The branch which originated from this branch. origin_page : hemlock.Page The page from which this branch originated. Note that branches can originate from other branches or pages. pages : list of hemlock.Page The queue of pages belonging to this branch. start_page : hemlock.Page or None The first page in the page queue, if non-empty. current_page : hemlock.Page Current page of this branch (head of the page queue). embedded : list of hemlock.Embedded Embedded data elements. data_elements : list of hemlock.DataElement All data elements belonging to this branch, in order of embedded data then page data. navigate : hemlock.Navigate Navigate function which returns a new branch once the participant has reached the end of this branch (i.e. the end of the page queue associated with this branch). navigate_worker : hemlock.Worker Worker which handles complex navigate functions.","title":"hemlock.Branch"},{"location":"models/branch/#examples","text":"from hemlock import Branch , Label , Page , push_app_context app = push_app_context () Branch ( Page ( Label ( 'Hello World' )), Page ( Label ( 'Hello Moon' )), Page ( Label ( 'Hello Star' )) ) . preview () This will open all of the branch's pages in separate tabs.","title":"Examples"},{"location":"models/branch/#methods","text":"preview ( self, driver=None ) [source] Preview the page queue in the a browser window. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver or None, default=None Driver to preview page debugging. If None , the page will be opened in a web browser. Returns: self : helock.Branch view_nav ( self ) [source] Print this branch's page queue for debugging purposes. Returns: self : hemlock.Branch","title":"Methods"},{"location":"models/embedded/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Embedded data and timers hemlock. Embedded class hemlock. Embedded ( var=None, data=None, data_rows=1, **kwargs ) [source] Embedded data belong to a branch or page. Use embedded data to manually input data to the dataframe; as opposed to recording data from participant responses. Polymorphic with hemlock.models.Data . Parameters: var : str or None, default=None Variable name associated with this data element. If None , the data will not be recorded. data : sqlalchemy_mutable.MutableType Data this element contributes to the dataframe. data_rows : int, default=1 Number of rows this data element contributes to the dataframe for its participant. If negative, this data element will 'fill in' any emtpy rows at the end of the dataframe with its most recent value. Relationships: participant : hemlock.Participant or None The participant to whom this data element belongs. branch : hemlock.Branch or None The branch to which the embedded data element belongs. page : hemlock.Page or None The page to which this embedded data element belongs. Examples from hemlock import Branch , Embedded , Page , Participant , push_app_context def start (): return Branch ( Page ()) app = push_app_context () part = Participant . gen_test_participant ( start ) part . embedded = [ Embedded ( 'Name' , 'Socrates' , data_rows =- 1 )] part . get_data () Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 4, 17, 57, 23, 854272)], 'StartTime': [datetime.datetime(2020, 7, 4, 17, 57, 23, 854272)], 'Status': ['InProgress'], 'Name': ['Socrates'], 'NameOrder': [0], 'NameIndex': [0]} hemlock. Timer class hemlock. Timer ( var=None, data_rows=1, **kwargs ) [source] Tracks how much time a participant spends in various parts of the survey. Inherits from hemlock.Embedded . Attributes: data : float or None Read only. Number of seconds for which the timer has been running. end_time : datetime.datetime or None Read only. If the timer is running, this is the current time. If the timer is paused, this is the time at which the timer was last paused. start_time : datetime.datetime or None The time at which the timer was started. state : str 'not started' , 'running ', or 'paused' . total_time : datetime.timedelta or None Read only. Total time the timer has been running. Examples from hemlock import Timer , push_app_context import time app = push_app_context () timer = Timer () print ( timer . state ) timer . start () print ( timer . state ) time . sleep ( 1 ) print ( timer . data ) timer . pause () print ( timer . state ) time . sleep ( 1 ) print ( timer . data ) Out: not started running 1.002405 paused 1.002983 Methods start ( self ) [source] Start the timer. Returns: self : hemlock.Timer pause ( self ) [source] Pause the timer. Returns: self : hemlock.Timer reset ( self ) [source] Reset all attributes to their default values. Returns: self : hemlock.Timer","title":"Embedded data and timers"},{"location":"models/embedded/#embedded-data-and-timers","text":"","title":"Embedded data and timers"},{"location":"models/embedded/#hemlockembedded","text":"class hemlock. Embedded ( var=None, data=None, data_rows=1, **kwargs ) [source] Embedded data belong to a branch or page. Use embedded data to manually input data to the dataframe; as opposed to recording data from participant responses. Polymorphic with hemlock.models.Data . Parameters: var : str or None, default=None Variable name associated with this data element. If None , the data will not be recorded. data : sqlalchemy_mutable.MutableType Data this element contributes to the dataframe. data_rows : int, default=1 Number of rows this data element contributes to the dataframe for its participant. If negative, this data element will 'fill in' any emtpy rows at the end of the dataframe with its most recent value. Relationships: participant : hemlock.Participant or None The participant to whom this data element belongs. branch : hemlock.Branch or None The branch to which the embedded data element belongs. page : hemlock.Page or None The page to which this embedded data element belongs.","title":"hemlock.Embedded"},{"location":"models/embedded/#examples","text":"from hemlock import Branch , Embedded , Page , Participant , push_app_context def start (): return Branch ( Page ()) app = push_app_context () part = Participant . gen_test_participant ( start ) part . embedded = [ Embedded ( 'Name' , 'Socrates' , data_rows =- 1 )] part . get_data () Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 4, 17, 57, 23, 854272)], 'StartTime': [datetime.datetime(2020, 7, 4, 17, 57, 23, 854272)], 'Status': ['InProgress'], 'Name': ['Socrates'], 'NameOrder': [0], 'NameIndex': [0]}","title":"Examples"},{"location":"models/embedded/#hemlocktimer","text":"class hemlock. Timer ( var=None, data_rows=1, **kwargs ) [source] Tracks how much time a participant spends in various parts of the survey. Inherits from hemlock.Embedded . Attributes: data : float or None Read only. Number of seconds for which the timer has been running. end_time : datetime.datetime or None Read only. If the timer is running, this is the current time. If the timer is paused, this is the time at which the timer was last paused. start_time : datetime.datetime or None The time at which the timer was started. state : str 'not started' , 'running ', or 'paused' . total_time : datetime.timedelta or None Read only. Total time the timer has been running.","title":"hemlock.Timer"},{"location":"models/embedded/#examples_1","text":"from hemlock import Timer , push_app_context import time app = push_app_context () timer = Timer () print ( timer . state ) timer . start () print ( timer . state ) time . sleep ( 1 ) print ( timer . data ) timer . pause () print ( timer . state ) time . sleep ( 1 ) print ( timer . data ) Out: not started running 1.002405 paused 1.002983","title":"Examples"},{"location":"models/embedded/#methods","text":"start ( self ) [source] Start the timer. Returns: self : hemlock.Timer pause ( self ) [source] Pause the timer. Returns: self : hemlock.Timer reset ( self ) [source] Reset all attributes to their default values. Returns: self : hemlock.Timer","title":"Methods"},{"location":"models/functions/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Function column types All of these classes inherit from sqlalchemy_mutable.partial . hemlock. Compile Helps compile a page or question html before it is rendered and displayed to a participant. Examples from hemlock import Compile as C , Input , Label , Page , push_app_context app = push_app_context () @C . register def greet ( greet_q , name_q ): greet_q . label = 'Hello {} !' . format ( name_q . response ) name_q = Input ( \"What's your name?\" ) p = Page ( Label ( compile = C . greet ( name_q ))) name_q . response = 'World' p . _compile () p . preview () hemlock. Debug class hemlock. Debug ( func, *args, p_exec=1.0, **kwargs ) [source] Run to help debug the survey. Examples from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () @D . register def greet ( driver , greet_q ): inpt = greet_q . input_from_driver ( driver ) inpt . clear () inpt . send_keys ( 'Hello World!' ) p = Page ( Input ( 'Enter a greeting.' , debug = D . greet ())) p . debug . pop ( - 1 ) # so the page won't navigate p . preview ( driver ) p . _debug ( driver ) Methods __call__ ( self, *args, **kwargs ) [source] hemlock. Validate class hemlock. Validate ( func, *args, error_msg=None, **kwargs ) [source] Validates a participant's response. Attributes: error_msg : str or None If the validate function returns an error message, error_msg is returned instead of the output of the validate function. You can set this by passing in an error_msg keyword argument to the constructor. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () @V . register def match ( inpt , pattern ): if inpt . response != pattern : return 'You entered \" {} \", not \" {} \"' . format ( inpt . response , pattern ) pattern = 'hello world' inpt = Input ( validate = V . match ( pattern )) inpt . response = 'goodbye moon' inpt . _validate () inpt . error Out: You entered \"goodbye moon\", not \"hello world\" Methods __call__ ( self, *args, **kwargs ) [source] hemlock. Submit Runs after a participant has successfully submitted a page. Examples from hemlock import Input , Submit as S , push_app_context app = push_app_context () @S . register def get_initials ( name_q ): names = name_q . response . split () name_q . data = '.' . join ([ name [ 0 ] for name in names ]) + '.' inpt = Input ( \"What's your name?\" , submit = S . get_initials ()) inpt . response = 'Andrew Yang' inpt . _submit () . data Out: A.Y. hemlock. Navigate Creates a new branch to which the participant will navigate. Examples from hemlock import Branch , Navigate as N , Page , Participant , push_app_context def start (): return Branch ( Page (), navigate = N . end ()) @N . register def end ( start_branch ): return Branch ( Page ( terminal = True )) app = push_app_context () part = Participant . gen_test_participant ( start ) part . view_nav () Out: <Branch 1> <Page 1> C C = current page T = terminal page In: part . forward () . view_nav () Out: <Branch 1> <Page 1> <Branch 2> <Page 2> C T C = current page T = terminal page","title":"Function column types"},{"location":"models/functions/#function-column-types","text":"All of these classes inherit from sqlalchemy_mutable.partial .","title":"Function column types"},{"location":"models/functions/#hemlockcompile","text":"Helps compile a page or question html before it is rendered and displayed to a participant.","title":"hemlock.Compile"},{"location":"models/functions/#examples","text":"from hemlock import Compile as C , Input , Label , Page , push_app_context app = push_app_context () @C . register def greet ( greet_q , name_q ): greet_q . label = 'Hello {} !' . format ( name_q . response ) name_q = Input ( \"What's your name?\" ) p = Page ( Label ( compile = C . greet ( name_q ))) name_q . response = 'World' p . _compile () p . preview ()","title":"Examples"},{"location":"models/functions/#hemlockdebug","text":"class hemlock. Debug ( func, *args, p_exec=1.0, **kwargs ) [source] Run to help debug the survey.","title":"hemlock.Debug"},{"location":"models/functions/#examples_1","text":"from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () @D . register def greet ( driver , greet_q ): inpt = greet_q . input_from_driver ( driver ) inpt . clear () inpt . send_keys ( 'Hello World!' ) p = Page ( Input ( 'Enter a greeting.' , debug = D . greet ())) p . debug . pop ( - 1 ) # so the page won't navigate p . preview ( driver ) p . _debug ( driver )","title":"Examples"},{"location":"models/functions/#methods","text":"__call__ ( self, *args, **kwargs ) [source]","title":"Methods"},{"location":"models/functions/#hemlockvalidate","text":"class hemlock. Validate ( func, *args, error_msg=None, **kwargs ) [source] Validates a participant's response. Attributes: error_msg : str or None If the validate function returns an error message, error_msg is returned instead of the output of the validate function. You can set this by passing in an error_msg keyword argument to the constructor.","title":"hemlock.Validate"},{"location":"models/functions/#examples_2","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () @V . register def match ( inpt , pattern ): if inpt . response != pattern : return 'You entered \" {} \", not \" {} \"' . format ( inpt . response , pattern ) pattern = 'hello world' inpt = Input ( validate = V . match ( pattern )) inpt . response = 'goodbye moon' inpt . _validate () inpt . error Out: You entered \"goodbye moon\", not \"hello world\"","title":"Examples"},{"location":"models/functions/#methods_1","text":"__call__ ( self, *args, **kwargs ) [source]","title":"Methods"},{"location":"models/functions/#hemlocksubmit","text":"Runs after a participant has successfully submitted a page.","title":"hemlock.Submit"},{"location":"models/functions/#examples_3","text":"from hemlock import Input , Submit as S , push_app_context app = push_app_context () @S . register def get_initials ( name_q ): names = name_q . response . split () name_q . data = '.' . join ([ name [ 0 ] for name in names ]) + '.' inpt = Input ( \"What's your name?\" , submit = S . get_initials ()) inpt . response = 'Andrew Yang' inpt . _submit () . data Out: A.Y.","title":"Examples"},{"location":"models/functions/#hemlocknavigate","text":"Creates a new branch to which the participant will navigate.","title":"hemlock.Navigate"},{"location":"models/functions/#examples_4","text":"from hemlock import Branch , Navigate as N , Page , Participant , push_app_context def start (): return Branch ( Page (), navigate = N . end ()) @N . register def end ( start_branch ): return Branch ( Page ( terminal = True )) app = push_app_context () part = Participant . gen_test_participant ( start ) part . view_nav () Out: <Branch 1> <Page 1> C C = current page T = terminal page In: part . forward () . view_nav () Out: <Branch 1> <Page 1> <Branch 2> <Page 2> C T C = current page T = terminal page","title":"Examples"},{"location":"models/page/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Page The survey 'flow' is: Compile. Execute a page's compile functions. By default, a page's first compile function runs its questions' compile methods in index order. Render. Render the page for the participant and wait for them to respond. Record response. Record the participant's response to every question on the page. This sets the response attribute of the questions. Validate. When the participant attempts to submit the page, validate the responses. As with the compile method, the validate method executes a page's validate functions in index order. By default, a page's first validate function runs its questions' validate methods in index order. Record data. Record the data associated with the participant's responses to every question on the page. This sets the data attribute of the questions. Submit. Execute the page's submit functions. By default, a page's first submit function runs its questions' submit methods in index order. Navigate. If the page has a navigate function, create a new branch originating from this page. hemlock. compile_questions def hemlock. compile_questions ( page ) [source] Execute the page's questions' compile methods in index order. Parameters: page : hemlock.Page hemlock. validate_questions def hemlock. validate_questions ( page ) [source] Execute the page's questions' validate methods in index order. Parameters: page : hemlock.Page hemlock. submit_questions def hemlock. submit_questions ( page ) [source] Execute the page's questions' submit methods in index order. Parameters: page : hemlock.Page hemlock. debug_questions def hemlock. debug_questions ( driver, page ) [source] Execute the page's questions' debug methods in random order. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page hemlock. navigate def hemlock. navigate ( driver, page, p_forward=0.8, p_back=0.1, sleep_time=3 ) [source] Randomly navigate forward or backward, or refresh the page. By default, it is executed after the default page debug function. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page p_forward : float, default=.8 Probability of clicking the forward button. p_back : float, default=.1 Probability of clicking the back button. sleep_time : float, default=3 Number of seconds to sleep if there is no forward or back button on the page. Notes The probability of refreshing the page is 1-p_forward-p_back . hemlock. Page class hemlock. Page ( *questions, extra_css=[], extra_js=[], delay_forward= None, **kwargs ) [source] Pages are queued in a branch. A page contains a list of questions which it displays to the participant in index order. It inherits from hemlock.model.BranchingBase . Parameters: *questions : list of hemlock.Question, default=[] Questions to be displayed on this page. template : str, default='hemlock/page-body.html' Template for the page body . extra_css : list, default=[] List of extra css elements to add to the default css. extra_js : list, default=[] List of extra javascript elements to add to the default javascript. delay_forward : int or None, default=None Number of milliseconds for which to hide the forward button when the page is first displayed. Attributes: back : str or None, default=None Text of the back button. If None , no back button will appear on the page. You may also set back to True , which will set the text to '<<' . back_btn_attrs : dict or None, default=None Dictionary of HTML attributes for the back button. banner : str or None Banner at the bottom of the page. cache_compile : bool, default=False Indicates that this page should cache the result of its compile functions. Specifically, it removes all compile functions and the compile worker from the page self self._compile is called. css : list List of css elements. direction_from : str or None, default=None Direction in which the participant navigated from this page. Possible values are 'back' , 'invalid' , or 'forward' . direction_to : str or None, default=None Direction in which the participant navigated to this page. Possible values are 'back' , 'invalid' , and 'forward' . error : str or None, default=None Error message. error_attrs : dict Dicitonary of HTML attributes for the error alert. forward : str or None, default='>>' Text of the forward button. If None , no forward button will appear on the page. You may also set forward to True , which will set the text to '>>' . forward_btn_attrs : dict Dictionary of HTML attributes for the forward button. g : misc, default=None A miscellaneous object. index : int or None, default=None Order in which this page appears in its branch's page queue. js : list List of javascript elements. navbar : str or None, default=None Navigation bar. terminal : bool, default=False Indicates that the survey terminates on this page. viewed : bool, default=False Indicates that the participant has viewed this page. Relationships: part : hemlock.Participant or None, default=None Participant to which this page belongs. Read only; derived from self. branch . branch : hemlock.Branch or None, default=None Branch to which this page belongs. next_branch : hemlock.Branch or None, default=None Branch which originated from this page. This is automatically set when this page runs its navigate function. back_to : hemlock.Page or None Page to which this page navigates when going back. If None , this page navigates back to the previous page. forward_to : hemlock.Page or None Page to which this page navigates when going forward. If None , this page navigates to the next page. embedded : list of hemlock.Embedded, default=[] List of embedded data elements. timer : hemlock.Timer or None, default=hemlock.Timer Tracks timing data for this page. 1. Timer can be set as a Timer object. 2. Setting timer to a str or None sets the timer object variable. 3. Setting timer to a tuple sets the timer object variable and data rows. 4. Setting timer to a dict sets the timer object attributes. The dict maps attribute names to values. questions : list of hemlock.Question, default=[] List of questions which this page displays to its participant. data_elements : list of hemlock.DataElement List of data elements which belong to this page; in order, self. timer , self.embedded , self.questions . compile : list of hemlock.Compile List of compile functions; run before the page is rendered. The default page compile function runs its questions' compile functions in index order. compile_worker : hemlock.Worker or None, default=None Worker which sends the compile functions to a Redis queue. validate : list of hemlock.Validate List of validate functions; run to validate participant responses. The default page validate function runs its questions' validate functions in index order. validate_worker : hemlock.Worker or None, default=None Worker which sends the validate functions to a Redis queue. submit : list of hemlock.Submit List of submit functions; run after participant responses have been validated. The default submit function runs its questions' submit functions in index order. submit_worker : hemlock.Worker or None, default=None Worker which sends the submit functions to a Redis queue. navigate : hemlock.Navigate or None, default=None Navigate function which returns a new branch originating from this page. navigate_worker : hemlock.Worker Worker which sends the navigate function to a Redis queue. debug_functions : list of hemlock.Debug List of debug functions; run during debugging. The default debug function runs its questions' debug functions in random order. Notes A CSS element can be any of the following: Link tag (str) e.g., '<link rel=\"stylesheet\" href=\"https://my-css-url\">' Href (str) e.g., \"https://my-css-url\" Style dictionary (dict) e.g., {'body': {'background': 'coral'}} The style dictionary maps a css selector to an attributes dictionary. The attributes dictionary maps attribute names to values. A javascript element can be any of the following: Attributes dictionary (dict) e.g., {'src': 'https://my-js-url'} JS code (str) Tuple of (attributes dictionary, js code) Examples from hemlock import Page , push_app_context app = push_app_context () Page ( Label ( 'Hello World' ) ) . preview () Methods clear_error ( self ) [source] Clear the error message from this page and all of its questions. Returns: self : hemlock.Page clear_response ( self ) [source] Clear the response from all of this page's questions. Returns: self : hemlock.Page convert_markdown ( self, string, strip_last_paragraph=False ) [source] Convert markdown-formatted string to HMTL. Parameters: string : str Markdown-formatted string. strip_last_paragraph : bool, default=False Strips the <p> tag from the last paragraph. This often prettifies the display. Returns: HTML : str HTML-formatted string. first_page ( self ) [source] Returns: is_first_page : bool Indicator that this is the first page in its participant's survey. last_page ( self ) [source] Returns: is_last_page : bool Indicator that this is the last page in its participant's survey. Notes This method assumes that if this page or its branch have a navigate function or next branch that this page is not the last (i.e. that the next branch will have pages). Avoid relying on this method if e.g. this page's navigate function may return an empty branch. is_valid ( self ) [source] Returns: valid : bool Indicator that all of the participant's responses are valid. That is, that there are no error messages on the page or any of its questions. preview ( self, driver=None, dir='tmp', filename='preview', suffix= '.html', overwrite=False ) [source] Preview the page in a browser window. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver or None, default=None Driver to preview page debugging. If None , the page will be opened in a web browser. dir : str, default='tmp' Directory to save the preview file. If the directory does not exist, this method creates it. filename : str, default='preview' Name of the preview file. suffix : str, default='.html' overwrite : bool, default=False Indicates to overwrite existing files of the same name. Returns: filepath : str Path to the preview file. Notes This method does not run the compile functions. view_nav ( self, indent=0 ) [source] Print the navigation starting at this page for debugging purposes. Parameters: indent : int, default=0 Starting indentation. Returns: self : hemlock.Page","title":"Page"},{"location":"models/page/#page","text":"The survey 'flow' is: Compile. Execute a page's compile functions. By default, a page's first compile function runs its questions' compile methods in index order. Render. Render the page for the participant and wait for them to respond. Record response. Record the participant's response to every question on the page. This sets the response attribute of the questions. Validate. When the participant attempts to submit the page, validate the responses. As with the compile method, the validate method executes a page's validate functions in index order. By default, a page's first validate function runs its questions' validate methods in index order. Record data. Record the data associated with the participant's responses to every question on the page. This sets the data attribute of the questions. Submit. Execute the page's submit functions. By default, a page's first submit function runs its questions' submit methods in index order. Navigate. If the page has a navigate function, create a new branch originating from this page.","title":"Page"},{"location":"models/page/#hemlockcompile_questions","text":"def hemlock. compile_questions ( page ) [source] Execute the page's questions' compile methods in index order. Parameters: page : hemlock.Page","title":"hemlock.compile_questions"},{"location":"models/page/#hemlockvalidate_questions","text":"def hemlock. validate_questions ( page ) [source] Execute the page's questions' validate methods in index order. Parameters: page : hemlock.Page","title":"hemlock.validate_questions"},{"location":"models/page/#hemlocksubmit_questions","text":"def hemlock. submit_questions ( page ) [source] Execute the page's questions' submit methods in index order. Parameters: page : hemlock.Page","title":"hemlock.submit_questions"},{"location":"models/page/#hemlockdebug_questions","text":"def hemlock. debug_questions ( driver, page ) [source] Execute the page's questions' debug methods in random order. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page","title":"hemlock.debug_questions"},{"location":"models/page/#hemlocknavigate","text":"def hemlock. navigate ( driver, page, p_forward=0.8, p_back=0.1, sleep_time=3 ) [source] Randomly navigate forward or backward, or refresh the page. By default, it is executed after the default page debug function. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page p_forward : float, default=.8 Probability of clicking the forward button. p_back : float, default=.1 Probability of clicking the back button. sleep_time : float, default=3 Number of seconds to sleep if there is no forward or back button on the page.","title":"hemlock.navigate"},{"location":"models/page/#notes","text":"The probability of refreshing the page is 1-p_forward-p_back .","title":"Notes"},{"location":"models/page/#hemlockpage","text":"class hemlock. Page ( *questions, extra_css=[], extra_js=[], delay_forward= None, **kwargs ) [source] Pages are queued in a branch. A page contains a list of questions which it displays to the participant in index order. It inherits from hemlock.model.BranchingBase . Parameters: *questions : list of hemlock.Question, default=[] Questions to be displayed on this page. template : str, default='hemlock/page-body.html' Template for the page body . extra_css : list, default=[] List of extra css elements to add to the default css. extra_js : list, default=[] List of extra javascript elements to add to the default javascript. delay_forward : int or None, default=None Number of milliseconds for which to hide the forward button when the page is first displayed. Attributes: back : str or None, default=None Text of the back button. If None , no back button will appear on the page. You may also set back to True , which will set the text to '<<' . back_btn_attrs : dict or None, default=None Dictionary of HTML attributes for the back button. banner : str or None Banner at the bottom of the page. cache_compile : bool, default=False Indicates that this page should cache the result of its compile functions. Specifically, it removes all compile functions and the compile worker from the page self self._compile is called. css : list List of css elements. direction_from : str or None, default=None Direction in which the participant navigated from this page. Possible values are 'back' , 'invalid' , or 'forward' . direction_to : str or None, default=None Direction in which the participant navigated to this page. Possible values are 'back' , 'invalid' , and 'forward' . error : str or None, default=None Error message. error_attrs : dict Dicitonary of HTML attributes for the error alert. forward : str or None, default='>>' Text of the forward button. If None , no forward button will appear on the page. You may also set forward to True , which will set the text to '>>' . forward_btn_attrs : dict Dictionary of HTML attributes for the forward button. g : misc, default=None A miscellaneous object. index : int or None, default=None Order in which this page appears in its branch's page queue. js : list List of javascript elements. navbar : str or None, default=None Navigation bar. terminal : bool, default=False Indicates that the survey terminates on this page. viewed : bool, default=False Indicates that the participant has viewed this page. Relationships: part : hemlock.Participant or None, default=None Participant to which this page belongs. Read only; derived from self. branch . branch : hemlock.Branch or None, default=None Branch to which this page belongs. next_branch : hemlock.Branch or None, default=None Branch which originated from this page. This is automatically set when this page runs its navigate function. back_to : hemlock.Page or None Page to which this page navigates when going back. If None , this page navigates back to the previous page. forward_to : hemlock.Page or None Page to which this page navigates when going forward. If None , this page navigates to the next page. embedded : list of hemlock.Embedded, default=[] List of embedded data elements. timer : hemlock.Timer or None, default=hemlock.Timer Tracks timing data for this page. 1. Timer can be set as a Timer object. 2. Setting timer to a str or None sets the timer object variable. 3. Setting timer to a tuple sets the timer object variable and data rows. 4. Setting timer to a dict sets the timer object attributes. The dict maps attribute names to values. questions : list of hemlock.Question, default=[] List of questions which this page displays to its participant. data_elements : list of hemlock.DataElement List of data elements which belong to this page; in order, self. timer , self.embedded , self.questions . compile : list of hemlock.Compile List of compile functions; run before the page is rendered. The default page compile function runs its questions' compile functions in index order. compile_worker : hemlock.Worker or None, default=None Worker which sends the compile functions to a Redis queue. validate : list of hemlock.Validate List of validate functions; run to validate participant responses. The default page validate function runs its questions' validate functions in index order. validate_worker : hemlock.Worker or None, default=None Worker which sends the validate functions to a Redis queue. submit : list of hemlock.Submit List of submit functions; run after participant responses have been validated. The default submit function runs its questions' submit functions in index order. submit_worker : hemlock.Worker or None, default=None Worker which sends the submit functions to a Redis queue. navigate : hemlock.Navigate or None, default=None Navigate function which returns a new branch originating from this page. navigate_worker : hemlock.Worker Worker which sends the navigate function to a Redis queue. debug_functions : list of hemlock.Debug List of debug functions; run during debugging. The default debug function runs its questions' debug functions in random order.","title":"hemlock.Page"},{"location":"models/page/#notes_1","text":"A CSS element can be any of the following: Link tag (str) e.g., '<link rel=\"stylesheet\" href=\"https://my-css-url\">' Href (str) e.g., \"https://my-css-url\" Style dictionary (dict) e.g., {'body': {'background': 'coral'}} The style dictionary maps a css selector to an attributes dictionary. The attributes dictionary maps attribute names to values. A javascript element can be any of the following: Attributes dictionary (dict) e.g., {'src': 'https://my-js-url'} JS code (str) Tuple of (attributes dictionary, js code)","title":"Notes"},{"location":"models/page/#examples","text":"from hemlock import Page , push_app_context app = push_app_context () Page ( Label ( 'Hello World' ) ) . preview ()","title":"Examples"},{"location":"models/page/#methods","text":"clear_error ( self ) [source] Clear the error message from this page and all of its questions. Returns: self : hemlock.Page clear_response ( self ) [source] Clear the response from all of this page's questions. Returns: self : hemlock.Page convert_markdown ( self, string, strip_last_paragraph=False ) [source] Convert markdown-formatted string to HMTL. Parameters: string : str Markdown-formatted string. strip_last_paragraph : bool, default=False Strips the <p> tag from the last paragraph. This often prettifies the display. Returns: HTML : str HTML-formatted string. first_page ( self ) [source] Returns: is_first_page : bool Indicator that this is the first page in its participant's survey. last_page ( self ) [source] Returns: is_last_page : bool Indicator that this is the last page in its participant's survey.","title":"Methods"},{"location":"models/page/#notes_2","text":"This method assumes that if this page or its branch have a navigate function or next branch that this page is not the last (i.e. that the next branch will have pages). Avoid relying on this method if e.g. this page's navigate function may return an empty branch. is_valid ( self ) [source] Returns: valid : bool Indicator that all of the participant's responses are valid. That is, that there are no error messages on the page or any of its questions. preview ( self, driver=None, dir='tmp', filename='preview', suffix= '.html', overwrite=False ) [source] Preview the page in a browser window. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver or None, default=None Driver to preview page debugging. If None , the page will be opened in a web browser. dir : str, default='tmp' Directory to save the preview file. If the directory does not exist, this method creates it. filename : str, default='preview' Name of the preview file. suffix : str, default='.html' overwrite : bool, default=False Indicates to overwrite existing files of the same name. Returns: filepath : str Path to the preview file.","title":"Notes"},{"location":"models/page/#notes_3","text":"This method does not run the compile functions. view_nav ( self, indent=0 ) [source] Print the navigation starting at this page for debugging purposes. Parameters: indent : int, default=0 Starting indentation. Returns: self : hemlock.Page","title":"Notes"},{"location":"models/participant/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Participant hemlock. Participant class hemlock. Participant ( **kwargs ) [source] The Participant class stores data for an individual survey participant and handles navigation for that participant. Inherits from hemlock.models.Base . Attributes: completed : bool, default=False Indicates that the participant has completed the survey. end_time : datetime.datetime Last time the participant submitted a page. g : dict, default={} Dictionary of miscellaneous objects. meta : dict, default={} Participant metadata, such as IP address. start_time : datetime.datetime Time at which the participant started he survey. status : str, default='InProgress' Participant's current status; 'InProgress' , 'TimedOut' , or 'Completed' . Read only; derived from self.completed and self.time_expired . time_expired : bool, default=False Indicates that the participant has exceeded their allotted time for the survey. updated : bool, default=True Indicates that the participant's data was updated after the last time their data was stored; if True , the participant's data will be re-stored when data are downloaded. Relationships: branch_stack : list of hemlock.Branch The participant's stack of branches. current_branch : hemlock.Branch Participant's current branch (head of self.branch_stack ). current_page : hemlock.Page Participant's current page (head of self.current_branch ). pages : list of hemlock.Page Pages belonging to the participant. embedded : list of hemlock.Embedded Embedded data elements belonging to the participant. data_elements : list of hemlock.DataElement List of all data elements belonging to the participant, ordered by id . Examples from hemlock import Branch , Label , Page , Participant , push_app_context def start (): return Branch ( Page ( Label ( '<p>Hello World</p>' ))) app = push_app_context () part = Participant . gen_test_participant ( start ) part . current_page . preview () Methods back ( self, back_to=None ) [source] Navigate back for debugging purposes. Parameters: back_to : hemlock.Page or None, default=None Navigate back to this page; if None , navigate back one page. Returns: self : hemlock.Participant forward ( self, forward_to=None ) [source] Navigate forward for debugging purposes. Parameters: forward_to : hemlock.Page or None, default=None Navigate forward to this page; if None , navigate forward one page. Returns: self : hemlock.Participant gen_test_participant ( gen_root=None ) [source] Generate a test participant for debugging purposes. Parameters: gen_root : callable or None, default=None Function to generate the root branch of the participant's tree. This should return a hemlock.Branch . Returns: part : hemlock.Participant get_data ( self ) [source] Returns: df : hemlock.models.private.DataFrame Data associated with the participant. Notes Data elements are added to the dataframe in the order in which they were created (i.e. by id). This is not necessarily the order in which they appeared to the Participant. Examples get_meta ( self ) [source] This is where it gets meta. Returns: meta : dict Participant's metadata, including the ID, end time, start time, and current status. view_nav ( self ) [source] View participant's branch stack. Returns: self : hemlock.Participant","title":"Participant"},{"location":"models/participant/#participant","text":"","title":"Participant"},{"location":"models/participant/#hemlockparticipant","text":"class hemlock. Participant ( **kwargs ) [source] The Participant class stores data for an individual survey participant and handles navigation for that participant. Inherits from hemlock.models.Base . Attributes: completed : bool, default=False Indicates that the participant has completed the survey. end_time : datetime.datetime Last time the participant submitted a page. g : dict, default={} Dictionary of miscellaneous objects. meta : dict, default={} Participant metadata, such as IP address. start_time : datetime.datetime Time at which the participant started he survey. status : str, default='InProgress' Participant's current status; 'InProgress' , 'TimedOut' , or 'Completed' . Read only; derived from self.completed and self.time_expired . time_expired : bool, default=False Indicates that the participant has exceeded their allotted time for the survey. updated : bool, default=True Indicates that the participant's data was updated after the last time their data was stored; if True , the participant's data will be re-stored when data are downloaded. Relationships: branch_stack : list of hemlock.Branch The participant's stack of branches. current_branch : hemlock.Branch Participant's current branch (head of self.branch_stack ). current_page : hemlock.Page Participant's current page (head of self.current_branch ). pages : list of hemlock.Page Pages belonging to the participant. embedded : list of hemlock.Embedded Embedded data elements belonging to the participant. data_elements : list of hemlock.DataElement List of all data elements belonging to the participant, ordered by id .","title":"hemlock.Participant"},{"location":"models/participant/#examples","text":"from hemlock import Branch , Label , Page , Participant , push_app_context def start (): return Branch ( Page ( Label ( '<p>Hello World</p>' ))) app = push_app_context () part = Participant . gen_test_participant ( start ) part . current_page . preview ()","title":"Examples"},{"location":"models/participant/#methods","text":"back ( self, back_to=None ) [source] Navigate back for debugging purposes. Parameters: back_to : hemlock.Page or None, default=None Navigate back to this page; if None , navigate back one page. Returns: self : hemlock.Participant forward ( self, forward_to=None ) [source] Navigate forward for debugging purposes. Parameters: forward_to : hemlock.Page or None, default=None Navigate forward to this page; if None , navigate forward one page. Returns: self : hemlock.Participant gen_test_participant ( gen_root=None ) [source] Generate a test participant for debugging purposes. Parameters: gen_root : callable or None, default=None Function to generate the root branch of the participant's tree. This should return a hemlock.Branch . Returns: part : hemlock.Participant get_data ( self ) [source] Returns: df : hemlock.models.private.DataFrame Data associated with the participant.","title":"Methods"},{"location":"models/participant/#notes","text":"Data elements are added to the dataframe in the order in which they were created (i.e. by id). This is not necessarily the order in which they appeared to the Participant.","title":"Notes"},{"location":"models/participant/#examples_1","text":"get_meta ( self ) [source] This is where it gets meta. Returns: meta : dict Participant's metadata, including the ID, end time, start time, and current status. view_nav ( self ) [source] View participant's branch stack. Returns: self : hemlock.Participant","title":"Examples"},{"location":"models/question/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Questions hemlock.Question and hemlock.ChoiceQuestion are 'question skeletons'; most useful when fleshed out. See section on question polymorphs. hemlock. Question class hemlock. Question ( label=None, extra_css=[], extra_js=[], form_group_class= ['card', 'form-group', 'question'], form_group_attrs={}, error_attrs={ 'class': ['alert', 'alert-danger']}, **kwargs ) [source] Base object for questions. Questions are displayed on their page in index order. It inherits from hemlock.models.Data . Parameters: label : str or None, default=None Question label. template : str, default='form-group.html' File name of question template. extra_css : list, default=[] List of extra CSS elements to add to the default CSS. extra_js : list, default=[] List of extra javascript elements to add to the default javascript. form_group_class : list, default=['card', 'form-group', 'question'] List of form group classes. form_group_attrs : dict, default={} Dictionary of HTML attribues for the form group tag. error_attrs : dict, default={'class' ['alert', 'alert-danger']} Dictionary of HTML attributes for the error alert. Attributes: append : str or None, default=None Text (usually) appended to the input tag. css : list, default=[] List of CSS elements. default : misc Default question response. error : str or None, default=None Error message. error_attrs : dict Set from the error_attrs parameter. form_group_class : list Set from the form_group_class parameter. form_group_attrs : dict Set from the form_group_attrs parameter. has_responded : bool, default=False Indicates that the participant has responded to this question. input_attrs : dict Dictionary of HTML attributes for the input tag. label : str or None, default=None Question label. prepend : str or None, default=None Text (usually) prepended to the input tag. response : misc Participant's response. template : str Set from the template parameter. Relationships: part : hemlock.Participant or None The participant to which this question belongs. Derived from self.page . branch : hemlock.Branch or None The branch to which this question belongs. Derived from self.page . page : hemlock.Page or None The page to which this question belongs. compile : list of hemlock.Compile, default=[] List of compile functions; run before the question is rendered. validate : list of hemlock.Validate, default=[] List of validate functions; run to validate the participant's response. submit : list of hemlock.Submit, default=[] List of submit functions; run after the participant's responses have been validated for all questions on a page. debug : list of hemlock.Debug, default=[] List of debug functions; run during debugging. The default debug function is unique to the question type. Notes A CSS element can be any of the following: Link tag (str) e.g., '<link rel=\"stylesheet\" href=\"https://my-css-url\">' Href (str) e.g., \"https://my-css-url\" Style dictionary (dict) e.g., {'body': {'background': 'coral'}} The style dictionary maps a css selector to an attributes dictionary. The attributes dictionary maps attribute names to values. A Javascript element can be any of the following: Attributes dictionary (dict) e.g., {'src': 'https://my-js-url'} JS code (str) Tuple of (attributes dictionary, js code) Methods clear_error ( self ) [source] Clear the error message. Returns: self : hemlock.Question clear_response ( self ) [source] Clear the response. Returns: self : hemlock.Question convert_markdown ( self, string, strip_last_paragraph=False ) [source] Convert markdown-formatted string to HMTL. Parameters: string : str Markdown-formatted string. strip_last_paragraph : bool, default=False Strips the <p> tag from the last paragraph. This often prettifies the display. Returns: HTML : str HTML-formatted string. hemlock. ChoiceQuestion class hemlock. ChoiceQuestion ( label=None, choices=[], template=None, **kwargs ) [source] A question which contains choices. Inherits from hemlock.Question . Parameters: label : str or None, default=None Question label. choices : list, default=[] Choices which belong to this question. List items are usually hemlock.Choice or hemlock.Option . template : str or None, default=None Template for the question body. Attributes: choices : list, default=[] Set from choices parameter. choice_cls : class, default=hemlock.Choice Class of the choices in the choices list. multiple : bool, default=False Indicates that the participant can select multiple choices. Notes A choice can be any of the following: Choice objects (type will depend on the choice question). str , treated as the choice label. (choice label, value) tuple. (choice label, value, name) tuple. Dictionary with choice keyword arguments.","title":"Question"},{"location":"models/question/#questions","text":"hemlock.Question and hemlock.ChoiceQuestion are 'question skeletons'; most useful when fleshed out. See section on question polymorphs.","title":"Questions"},{"location":"models/question/#hemlockquestion","text":"class hemlock. Question ( label=None, extra_css=[], extra_js=[], form_group_class= ['card', 'form-group', 'question'], form_group_attrs={}, error_attrs={ 'class': ['alert', 'alert-danger']}, **kwargs ) [source] Base object for questions. Questions are displayed on their page in index order. It inherits from hemlock.models.Data . Parameters: label : str or None, default=None Question label. template : str, default='form-group.html' File name of question template. extra_css : list, default=[] List of extra CSS elements to add to the default CSS. extra_js : list, default=[] List of extra javascript elements to add to the default javascript. form_group_class : list, default=['card', 'form-group', 'question'] List of form group classes. form_group_attrs : dict, default={} Dictionary of HTML attribues for the form group tag. error_attrs : dict, default={'class' ['alert', 'alert-danger']} Dictionary of HTML attributes for the error alert. Attributes: append : str or None, default=None Text (usually) appended to the input tag. css : list, default=[] List of CSS elements. default : misc Default question response. error : str or None, default=None Error message. error_attrs : dict Set from the error_attrs parameter. form_group_class : list Set from the form_group_class parameter. form_group_attrs : dict Set from the form_group_attrs parameter. has_responded : bool, default=False Indicates that the participant has responded to this question. input_attrs : dict Dictionary of HTML attributes for the input tag. label : str or None, default=None Question label. prepend : str or None, default=None Text (usually) prepended to the input tag. response : misc Participant's response. template : str Set from the template parameter. Relationships: part : hemlock.Participant or None The participant to which this question belongs. Derived from self.page . branch : hemlock.Branch or None The branch to which this question belongs. Derived from self.page . page : hemlock.Page or None The page to which this question belongs. compile : list of hemlock.Compile, default=[] List of compile functions; run before the question is rendered. validate : list of hemlock.Validate, default=[] List of validate functions; run to validate the participant's response. submit : list of hemlock.Submit, default=[] List of submit functions; run after the participant's responses have been validated for all questions on a page. debug : list of hemlock.Debug, default=[] List of debug functions; run during debugging. The default debug function is unique to the question type.","title":"hemlock.Question"},{"location":"models/question/#notes","text":"A CSS element can be any of the following: Link tag (str) e.g., '<link rel=\"stylesheet\" href=\"https://my-css-url\">' Href (str) e.g., \"https://my-css-url\" Style dictionary (dict) e.g., {'body': {'background': 'coral'}} The style dictionary maps a css selector to an attributes dictionary. The attributes dictionary maps attribute names to values. A Javascript element can be any of the following: Attributes dictionary (dict) e.g., {'src': 'https://my-js-url'} JS code (str) Tuple of (attributes dictionary, js code)","title":"Notes"},{"location":"models/question/#methods","text":"clear_error ( self ) [source] Clear the error message. Returns: self : hemlock.Question clear_response ( self ) [source] Clear the response. Returns: self : hemlock.Question convert_markdown ( self, string, strip_last_paragraph=False ) [source] Convert markdown-formatted string to HMTL. Parameters: string : str Markdown-formatted string. strip_last_paragraph : bool, default=False Strips the <p> tag from the last paragraph. This often prettifies the display. Returns: HTML : str HTML-formatted string.","title":"Methods"},{"location":"models/question/#hemlockchoicequestion","text":"class hemlock. ChoiceQuestion ( label=None, choices=[], template=None, **kwargs ) [source] A question which contains choices. Inherits from hemlock.Question . Parameters: label : str or None, default=None Question label. choices : list, default=[] Choices which belong to this question. List items are usually hemlock.Choice or hemlock.Option . template : str or None, default=None Template for the question body. Attributes: choices : list, default=[] Set from choices parameter. choice_cls : class, default=hemlock.Choice Class of the choices in the choices list. multiple : bool, default=False Indicates that the participant can select multiple choices.","title":"hemlock.ChoiceQuestion"},{"location":"models/question/#notes_1","text":"A choice can be any of the following: Choice objects (type will depend on the choice question). str , treated as the choice label. (choice label, value) tuple. (choice label, value, name) tuple. Dictionary with choice keyword arguments.","title":"Notes"},{"location":"models/worker/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Worker hemlock. Worker Workers simplify interaction with a Redis queue. A worker attaches to a branch or page, and is responsible for one of its methods (compile, validate, submit, or navigate). When the method for which a worker is responsible is called, the worker sends the method to a Redis queue. While the Redis queue is processing this method, the worker shows participants a loading page. When the Redis queue finishes processing this method, the worker sends the client to his next page. Worker inherits from flask_worker.WorkerMixin . Notes To run redis in production on heroku: 1. Declare a worker process In the root directory of your project, open Procfile . Add the line worker: rq worker -u $REDIS_URL hemlock-task-queue . Your Procfile should look like: web: gunicorn -k eventlet -w 1 app:app worker: rq worker -u $REDIS_URL hemlock-task-queue 2. Create a redis addon and provision worker processes In the root directory of your project, open app.json . To create a Redis addon, add {\"plan\": \"heroku-redis:hobby-dev\", \"options\": {\"version\": 5}} to your addons . To provision worker processes, add \"worker: {\"quantity\": 1, \"size\": \"hobby\"} to your formation . In sum, the top of app.json will look like: { \"addons\" : [ \"heroku-postgresql:hobby-dev\" , { \"plan\" : \"heroku-redis:hobby-dev\" } ], \"formation\" : { \"web\" : { \"quantity\" : 1 , \"size\" : \"hobby\" }, \"worker\" : { \"quantity\" : 1 , \"size\" : \"hobby\" } }, ... When scaling for production, I recommend using the premium-1 redis plan, quantity 5, size standard-1x. So app.json will look like: { \"addons\" : [ \"heroku-postgresql:standard-1x\" , { \"plan\" : \"heroku-redis:premium-1\" , \"options\" : { \"version\" : 5 }} ], \"formation\" : { \"web\" : { \"quantity\" : 10 , \"size\" : \"standard-1x\" }, \"worker\" : { \"quantity\" : 5 , \"size\" : \"standard-1x\" } }, ... Why redis 5? I recommend redis version 5, rather than the latest version 6. Heroku requires you to manually set up TLS authentication for redis 6, which is a complicated process, whereas you can bypass TLS authentication using redis 5. Examples In survey.py : from hemlock import Branch , Compile as C , Label , Page , route @route ( '/survey' ) def start (): return Branch ( Page ( Label ( 'Hello, World!' ) ), Page ( Label ( 'Goodbye, Moon!' , compile = C . complex_function ( seconds = 5 ) ), compile_worker = True , terminal = True ), ) @C . register def complex_function ( label , seconds ): import time for t in range ( seconds ): print ( 'Progress: {} %' . format ( round ( 100. * t / seconds ))) time . sleep ( 1 ) print ( 'Progress: 100%' ) Note that the second page (or rather, one of its questions), needs to run a complex compile function. We add a worker to it by setting compile_worker=True . Use a similar syntax to add validate, submit, and navigate workers. Our app.py is standard: import eventlet eventlet . monkey_patch () import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) To run the app locally, you will need to set the REDIS_URL environment variable and run a redis queue from your project's root directory. Redis on Windows Windows cannot run redis natively. To run redis on Windows, use Windows Subsystem for Linux . If using the hemlock template and hemlock-CLI: Open env.yaml and add the line REDIS_URL: redis:// . Open a second terminal in your project's root directory and run the redis queue with hlk rq . Run the app by entering hlk serve in your first terminal. If not using the template or hemlock-CLI: Set your environment variable with export REDIS_URL=redis:// . Open a second terminal in your project's root directory and enter rq worker hemlock-task-queue . Run the app by entering python3 app.py in your first terminal. Go to http://localhost:5000/ in your browser. Notice that, when you click past the first page, you see a loading gif before the second page is loaded. In your second terminal window, you should see: Progress: 0% ... Progress: 100%","title":"Worker"},{"location":"models/worker/#worker","text":"","title":"Worker"},{"location":"models/worker/#hemlockworker","text":"Workers simplify interaction with a Redis queue. A worker attaches to a branch or page, and is responsible for one of its methods (compile, validate, submit, or navigate). When the method for which a worker is responsible is called, the worker sends the method to a Redis queue. While the Redis queue is processing this method, the worker shows participants a loading page. When the Redis queue finishes processing this method, the worker sends the client to his next page. Worker inherits from flask_worker.WorkerMixin .","title":"hemlock.Worker"},{"location":"models/worker/#notes","text":"To run redis in production on heroku: 1. Declare a worker process In the root directory of your project, open Procfile . Add the line worker: rq worker -u $REDIS_URL hemlock-task-queue . Your Procfile should look like: web: gunicorn -k eventlet -w 1 app:app worker: rq worker -u $REDIS_URL hemlock-task-queue 2. Create a redis addon and provision worker processes In the root directory of your project, open app.json . To create a Redis addon, add {\"plan\": \"heroku-redis:hobby-dev\", \"options\": {\"version\": 5}} to your addons . To provision worker processes, add \"worker: {\"quantity\": 1, \"size\": \"hobby\"} to your formation . In sum, the top of app.json will look like: { \"addons\" : [ \"heroku-postgresql:hobby-dev\" , { \"plan\" : \"heroku-redis:hobby-dev\" } ], \"formation\" : { \"web\" : { \"quantity\" : 1 , \"size\" : \"hobby\" }, \"worker\" : { \"quantity\" : 1 , \"size\" : \"hobby\" } }, ... When scaling for production, I recommend using the premium-1 redis plan, quantity 5, size standard-1x. So app.json will look like: { \"addons\" : [ \"heroku-postgresql:standard-1x\" , { \"plan\" : \"heroku-redis:premium-1\" , \"options\" : { \"version\" : 5 }} ], \"formation\" : { \"web\" : { \"quantity\" : 10 , \"size\" : \"standard-1x\" }, \"worker\" : { \"quantity\" : 5 , \"size\" : \"standard-1x\" } }, ... Why redis 5? I recommend redis version 5, rather than the latest version 6. Heroku requires you to manually set up TLS authentication for redis 6, which is a complicated process, whereas you can bypass TLS authentication using redis 5.","title":"Notes"},{"location":"models/worker/#examples","text":"In survey.py : from hemlock import Branch , Compile as C , Label , Page , route @route ( '/survey' ) def start (): return Branch ( Page ( Label ( 'Hello, World!' ) ), Page ( Label ( 'Goodbye, Moon!' , compile = C . complex_function ( seconds = 5 ) ), compile_worker = True , terminal = True ), ) @C . register def complex_function ( label , seconds ): import time for t in range ( seconds ): print ( 'Progress: {} %' . format ( round ( 100. * t / seconds ))) time . sleep ( 1 ) print ( 'Progress: 100%' ) Note that the second page (or rather, one of its questions), needs to run a complex compile function. We add a worker to it by setting compile_worker=True . Use a similar syntax to add validate, submit, and navigate workers. Our app.py is standard: import eventlet eventlet . monkey_patch () import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) To run the app locally, you will need to set the REDIS_URL environment variable and run a redis queue from your project's root directory. Redis on Windows Windows cannot run redis natively. To run redis on Windows, use Windows Subsystem for Linux . If using the hemlock template and hemlock-CLI: Open env.yaml and add the line REDIS_URL: redis:// . Open a second terminal in your project's root directory and run the redis queue with hlk rq . Run the app by entering hlk serve in your first terminal. If not using the template or hemlock-CLI: Set your environment variable with export REDIS_URL=redis:// . Open a second terminal in your project's root directory and enter rq worker hemlock-task-queue . Run the app by entering python3 app.py in your first terminal. Go to http://localhost:5000/ in your browser. Notice that, when you click past the first page, you see a loading gif before the second page is loaded. In your second terminal window, you should see: Progress: 0% ... Progress: 100%","title":"Examples"},{"location":"questions/bases/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Base for input questions hemlock. InputBase class hemlock. InputBase ( *args, **kwargs ) [source] This base class provides methods useful for debugging. Additionally, when setting and getting attributes, it intercepts and automatically handles input tag HTML attribues. Methods input_from_driver ( self, driver=None ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.Webdriver Driver which will be used to select the input. Does not need to be Chrome. Returns: input : selenium.webdriver.remote.webelement.WebElement Web element of the <input> tag associated with this model. label_from_driver ( self, driver ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.Webdriver Driver which will be used to select the label. Does not need to be Chrome. Returns: label : selenium.webdriver.remote.webelement.WebElement Web element of the label tag associated with this model.","title":"Bases"},{"location":"questions/bases/#base-for-input-questions","text":"","title":"Base for input questions"},{"location":"questions/bases/#hemlockinputbase","text":"class hemlock. InputBase ( *args, **kwargs ) [source] This base class provides methods useful for debugging. Additionally, when setting and getting attributes, it intercepts and automatically handles input tag HTML attribues.","title":"hemlock.InputBase"},{"location":"questions/bases/#methods","text":"input_from_driver ( self, driver=None ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.Webdriver Driver which will be used to select the input. Does not need to be Chrome. Returns: input : selenium.webdriver.remote.webelement.WebElement Web element of the <input> tag associated with this model. label_from_driver ( self, driver ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.Webdriver Driver which will be used to select the label. Does not need to be Chrome. Returns: label : selenium.webdriver.remote.webelement.WebElement Web element of the label tag associated with this model.","title":"Methods"},{"location":"questions/blank/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Blank hemlock. Blank class hemlock. Blank ( label=None, template='hemlock/input.html', **kwargs ) [source] Fill in the blank question. Parameters: label : tuple, list, or None, default=None If the label is a tuple or list , the participant's response will fill in the blanks between items. template : str, default='hemlock/input.html' File name of the Jinja template. blank_empty : str, default='' String used to fill in the blank when the participant's response is empty. Examples from hemlock import Page , Blank Page ( Blank ( ( 'Hello, ' , '!' ), blank_empty = '_____' ) ) . preview () Enter 'World' in the input and the label will change to 'Hello, World!'.","title":"Blank"},{"location":"questions/blank/#blank","text":"","title":"Blank"},{"location":"questions/blank/#hemlockblank","text":"class hemlock. Blank ( label=None, template='hemlock/input.html', **kwargs ) [source] Fill in the blank question. Parameters: label : tuple, list, or None, default=None If the label is a tuple or list , the participant's response will fill in the blanks between items. template : str, default='hemlock/input.html' File name of the Jinja template. blank_empty : str, default='' String used to fill in the blank when the participant's response is empty.","title":"hemlock.Blank"},{"location":"questions/blank/#examples","text":"from hemlock import Page , Blank Page ( Blank ( ( 'Hello, ' , '!' ), blank_empty = '_____' ) ) . preview () Enter 'World' in the input and the label will change to 'Hello, World!'.","title":"Examples"},{"location":"questions/check/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Check hemlock. binary def hemlock. binary ( label=None, choices=['Yes', 'No'], inline=True, **kwargs ) [source] Creates a binary (yes/no) check question. Parameters: label : str, default=None choices : list, default=['Yes', 'No'] List of choice labels. inline : bool, default=True Indicates that choices should be displayed inline. **kwargs : Keyword arguments passed to Check constructor. Examples from hemlock import Page , binary , push_app_context app = push_app_context () Page ( binary ( 'Yes or no?' )) . preview () hemlock. Binary def hemlock. Binary ( *args, **kwargs ) [source] hemlock. Check class hemlock. Check ( label=None, choices=[], template='hemlock/check.html', **kwargs ) [source] Check questions use radio inputs if only one choice can be selected, or checkbox inputs if multiple choices can be selected. Inherits from hemlock.qpolymorphs.base.InputBase and hemlock.models.ChoiceQuestion . Its default debug function is click_choices . Parameters: label : str or None, default=None Check question label. choices : list of hemlock.Choice, str, tuple, or dict, default=[] Choices which participants can check. template : str, default='hemlock/check.html' File name of the Jinja template. Attributes: align : str, default='left' Alignment of the choice text. Value can be 'left' , 'center' , or 'right' . choices : list of hemlock.Choice Set from the choices parameter. inline : bool, default=False Indicates that choices should be inline , as opposed to vertical. multiple : bool, default=False Indicates that the participant may select multiple choices. Notes A choice can be input as any of the following: Choice object. str , treated as the choice label, value, and name. (choice label, value) tuple. (choice label, value, name) tuple. Dictionary with choice keyword arguments. Examples from hemlock import Check , Page , push_app_context app = push_app_context () Page ( Check ( 'Check one.' , [ 'Yes' , 'No' , 'Maybe' ])) . preview ()","title":"Check"},{"location":"questions/check/#check","text":"","title":"Check"},{"location":"questions/check/#hemlockbinary","text":"def hemlock. binary ( label=None, choices=['Yes', 'No'], inline=True, **kwargs ) [source] Creates a binary (yes/no) check question. Parameters: label : str, default=None choices : list, default=['Yes', 'No'] List of choice labels. inline : bool, default=True Indicates that choices should be displayed inline. **kwargs : Keyword arguments passed to Check constructor.","title":"hemlock.binary"},{"location":"questions/check/#examples","text":"from hemlock import Page , binary , push_app_context app = push_app_context () Page ( binary ( 'Yes or no?' )) . preview ()","title":"Examples"},{"location":"questions/check/#hemlockbinary_1","text":"def hemlock. Binary ( *args, **kwargs ) [source]","title":"hemlock.Binary"},{"location":"questions/check/#hemlockcheck","text":"class hemlock. Check ( label=None, choices=[], template='hemlock/check.html', **kwargs ) [source] Check questions use radio inputs if only one choice can be selected, or checkbox inputs if multiple choices can be selected. Inherits from hemlock.qpolymorphs.base.InputBase and hemlock.models.ChoiceQuestion . Its default debug function is click_choices . Parameters: label : str or None, default=None Check question label. choices : list of hemlock.Choice, str, tuple, or dict, default=[] Choices which participants can check. template : str, default='hemlock/check.html' File name of the Jinja template. Attributes: align : str, default='left' Alignment of the choice text. Value can be 'left' , 'center' , or 'right' . choices : list of hemlock.Choice Set from the choices parameter. inline : bool, default=False Indicates that choices should be inline , as opposed to vertical. multiple : bool, default=False Indicates that the participant may select multiple choices.","title":"hemlock.Check"},{"location":"questions/check/#notes","text":"A choice can be input as any of the following: Choice object. str , treated as the choice label, value, and name. (choice label, value) tuple. (choice label, value, name) tuple. Dictionary with choice keyword arguments.","title":"Notes"},{"location":"questions/check/#examples_1","text":"from hemlock import Check , Page , push_app_context app = push_app_context () Page ( Check ( 'Check one.' , [ 'Yes' , 'No' , 'Maybe' ])) . preview ()","title":"Examples"},{"location":"questions/choice/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Choices and Options The difference between hemlock.Choice and hemlock.Option is the former are for hemlock.Check questions, while latter are for hemlock.Select questions. The use of choice and option models is not due to any deep functional difference between them, but reflects the underlying html. hemlock. ChoiceBase class hemlock. ChoiceBase ( label=None, **kwargs ) [source] Base class for choices. Parameters: label : str or None, default=None Choice label. template : str Jinja template for the choice html. value : default=None Value of the choice if selected. e.g. a choice with label 'Yes' might have a value of 1 . If None , the label is used. For a question where only one choice can be selected, this is the value of the question's data if this choice is selected. For a question where multiple choices may be selected, data are one-hot encoded; the value is the suffix of the column name associated with the indicator variable that this choice was selected. name : default=None Name associated with this choice in the dataframe. If None , the label is used. Attributes: key : str Randomly generated from ascii letters and digits. label : str Set from the label parameter. value : Set from the value parameter. name : Set from the name parameter. Notes If passing value and name to contructor, these must be passed as keyword arguments Methods is_default ( self, question ) [source] Parameters: question : hemlock.Question The question to which this choice belongs. Returns: is_default : bool Indicate that this choice is (one of) its question's default choice(s). Notes The question's default choice(s) is the question's response if the participant responded to the question, or the question's default if the participant has not yet responded to the question. set_all ( self, val ) [source] Set the choice's label, name, and value. Parameters: val : Value to which the choice's label, name, and value should be set. Returns: self : hemlock.Choice dump ( self ) [source] load ( cls, state_dict ) [source] hemlock. ChoiceListTypeBase Methods process_bind_param ( self, choices, dialect ) [source] process_result_value ( self, state_dicts, dialect ) [source] hemlock. ChoiceListBase Converts items in a list of choices to the choice class. Methods convert ( cls, item ) [source] hemlock. Choice class hemlock. Choice ( label=None, template='hemlock/choice.html', **kwargs ) [source] Choices are displayed as part of their question (usually hemlock.Check ). Inherits from hemlock.ChoiceBase . Parameters: label : str or None, default=None Choice label. template : str, default='hemlock/choice.html' File name of the choice template. **kwargs : Set the choice's value and name using keyword arguments. Methods click ( self, driver, if_selected=None ) [source] Use a selenium webdriver to click on this choice. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. if_selected : bool or None, default=None Indicates that the choice will be clicked only if it is already selected. If False the choice will be clicked only if it is not already selected. If None the choice will be clicked whether or not it is selected. Returns: self : is_displayed ( self, driver ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. Returns: is_displayed : bool Indicates that this choice is visible in the browser. hemlock. ChoiceListType hemlock. ChoiceList hemlock. Option class hemlock. Option ( label=None, template='hemlock/option.html', **kwargs ) [source] Options are displayed as part of their question (usually hemlock.Select ). Inherits from hemlock.ChoiceBase . Its functionality is similar to hemlock.Choice , but for Select questions instead of Check questions. Parameters: label : str or None, default=None Choice label. template : str, default='hemlock/option.html' File name of the option template. **kwargs : Set the choice's value and name using keyword arguments. Methods click ( self, driver, if_selected=None ) [source] Use a selenium webdriver to click on this choice. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. if_selected : bool or None, default=None Indicates that the choice will be clicked only if it is already selected. If False the choice will be clicked only if it is not already selected. If None the choice will be clicked whether or not it is selected. Returns: self : is_displayed ( self, driver ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. Returns: is_displayed : bool Indicates that this choice is visible in the browser. hemlock. OptionListType hemlock. OptionList","title":"Choice"},{"location":"questions/choice/#choices-and-options","text":"The difference between hemlock.Choice and hemlock.Option is the former are for hemlock.Check questions, while latter are for hemlock.Select questions. The use of choice and option models is not due to any deep functional difference between them, but reflects the underlying html.","title":"Choices and Options"},{"location":"questions/choice/#hemlockchoicebase","text":"class hemlock. ChoiceBase ( label=None, **kwargs ) [source] Base class for choices. Parameters: label : str or None, default=None Choice label. template : str Jinja template for the choice html. value : default=None Value of the choice if selected. e.g. a choice with label 'Yes' might have a value of 1 . If None , the label is used. For a question where only one choice can be selected, this is the value of the question's data if this choice is selected. For a question where multiple choices may be selected, data are one-hot encoded; the value is the suffix of the column name associated with the indicator variable that this choice was selected. name : default=None Name associated with this choice in the dataframe. If None , the label is used. Attributes: key : str Randomly generated from ascii letters and digits. label : str Set from the label parameter. value : Set from the value parameter. name : Set from the name parameter.","title":"hemlock.ChoiceBase"},{"location":"questions/choice/#notes","text":"If passing value and name to contructor, these must be passed as keyword arguments","title":"Notes"},{"location":"questions/choice/#methods","text":"is_default ( self, question ) [source] Parameters: question : hemlock.Question The question to which this choice belongs. Returns: is_default : bool Indicate that this choice is (one of) its question's default choice(s).","title":"Methods"},{"location":"questions/choice/#notes_1","text":"The question's default choice(s) is the question's response if the participant responded to the question, or the question's default if the participant has not yet responded to the question. set_all ( self, val ) [source] Set the choice's label, name, and value. Parameters: val : Value to which the choice's label, name, and value should be set. Returns: self : hemlock.Choice dump ( self ) [source] load ( cls, state_dict ) [source]","title":"Notes"},{"location":"questions/choice/#hemlockchoicelisttypebase","text":"","title":"hemlock.ChoiceListTypeBase"},{"location":"questions/choice/#methods_1","text":"process_bind_param ( self, choices, dialect ) [source] process_result_value ( self, state_dicts, dialect ) [source]","title":"Methods"},{"location":"questions/choice/#hemlockchoicelistbase","text":"Converts items in a list of choices to the choice class.","title":"hemlock.ChoiceListBase"},{"location":"questions/choice/#methods_2","text":"convert ( cls, item ) [source]","title":"Methods"},{"location":"questions/choice/#hemlockchoice","text":"class hemlock. Choice ( label=None, template='hemlock/choice.html', **kwargs ) [source] Choices are displayed as part of their question (usually hemlock.Check ). Inherits from hemlock.ChoiceBase . Parameters: label : str or None, default=None Choice label. template : str, default='hemlock/choice.html' File name of the choice template. **kwargs : Set the choice's value and name using keyword arguments.","title":"hemlock.Choice"},{"location":"questions/choice/#methods_3","text":"click ( self, driver, if_selected=None ) [source] Use a selenium webdriver to click on this choice. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. if_selected : bool or None, default=None Indicates that the choice will be clicked only if it is already selected. If False the choice will be clicked only if it is not already selected. If None the choice will be clicked whether or not it is selected. Returns: self : is_displayed ( self, driver ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. Returns: is_displayed : bool Indicates that this choice is visible in the browser.","title":"Methods"},{"location":"questions/choice/#hemlockchoicelisttype","text":"","title":"hemlock.ChoiceListType"},{"location":"questions/choice/#hemlockchoicelist","text":"","title":"hemlock.ChoiceList"},{"location":"questions/choice/#hemlockoption","text":"class hemlock. Option ( label=None, template='hemlock/option.html', **kwargs ) [source] Options are displayed as part of their question (usually hemlock.Select ). Inherits from hemlock.ChoiceBase . Its functionality is similar to hemlock.Choice , but for Select questions instead of Check questions. Parameters: label : str or None, default=None Choice label. template : str, default='hemlock/option.html' File name of the option template. **kwargs : Set the choice's value and name using keyword arguments.","title":"hemlock.Option"},{"location":"questions/choice/#methods_4","text":"click ( self, driver, if_selected=None ) [source] Use a selenium webdriver to click on this choice. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. if_selected : bool or None, default=None Indicates that the choice will be clicked only if it is already selected. If False the choice will be clicked only if it is not already selected. If None the choice will be clicked whether or not it is selected. Returns: self : is_displayed ( self, driver ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. Returns: is_displayed : bool Indicates that this choice is visible in the browser.","title":"Methods"},{"location":"questions/choice/#hemlockoptionlisttype","text":"","title":"hemlock.OptionListType"},{"location":"questions/choice/#hemlockoptionlist","text":"","title":"hemlock.OptionList"},{"location":"questions/dashboard/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Dashboard hemlock. Dashboard class hemlock. Dashboard ( label=None, template='hemlock/dash.html', **kwargs ) [source] Embeds a dash app . Parameters: label : str or None, default=None Dashboard label. template : str, default='hemlock/dash.html' Template for the dashboard body. Attributes: src : str src attribute of the <iframe> tag. Examples In this example, we create a simple dash app in which participants click on a button. We embed this app in a hemlock survey, and record the number of times a participant clicked the button. Install dash with: $ hlk install dash Or: $ pip install dash In survey.py : from hemlock import Branch , Dashboard , Label , Page , route @route ( '/survey' ) def start (): return Branch ( Page ( Dashboard ( src = '/dashapp/' , var = 'n_clicks' ) ), Page ( Label ( 'The end.' ), terminal = True ) ) In app.py : import survey import dash import dash_core_components as dcc import dash_html_components as html from dash.dependencies import Input , Output from hemlock import Dashboard , create_app app = create_app () dash_app = dash . Dash ( server = app , routes_pathname_prefix = '/dashapp/' , external_stylesheets = [ 'https://codepen.io/chriddyp/pen/bWLwgP.css' ] ) dash_app . layout = html . Div ([ dcc . Location ( id = 'url' ), html . Button ( 'Click me!' , id = 'button' ), html . P ( id = 'click-tracker' ), ]) @dash_app . callback ( Output ( 'click-tracker' , 'children' ), [ Input ( 'url' , 'search' ), Input ( 'button' , 'n_clicks' )] ) def update_clicks ( search , n_clicks ): n_clicks = n_clicks or 0 Dashboard . record_response ( search , n_clicks ) return ' {} clicks' . format ( n_clicks ) if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app with: $ hlk serve Or: $ python app.py Then open your browser and navigate to http://localhost:5000/ . Methods get ( cls, search ) [source] Utility for retrieving a dashboard question in a dash callback. Parameters: search : str, formatted as URL query string Must have 'id' and 'key' parameters. Returns: dashboard : hemlock_dash.Dashboard Dashboard specified by the id in the search string. Examples ... import dash_core_components as dcc from hemlock import Dashboard app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), ... ]) @app . callback ( Output ( ... ), [ Input ( 'url' , 'search' ), ... ] ) def my_callback ( search , ... ): dashboard = Dashboard . get ( search ) record_response ( cls, search, response ) [source] Utility for writing the response attribute of the dashboard question. Parameters: search : str, formatted as URL query string Must have 'id' and 'key' parameters. response : Value to which to set the dash question's repsonse attribute. Returns: dashboard : hemlock_dash.Dashboard Dashboard specified by the id in the search string. Examples ```python ... import dash_core_components as dcc from hemlock import Dashboard app.layout = html.Div([ dcc.Location(id='url', refresh=False), ... ]) @app.callback( Output(...), [Input('url', 'search'), ...] ) def my_callback(search, ...): Dashboard.record_response(search, 'hello world') render_url ( self ) [source]","title":"Dashboard"},{"location":"questions/dashboard/#dashboard","text":"","title":"Dashboard"},{"location":"questions/dashboard/#hemlockdashboard","text":"class hemlock. Dashboard ( label=None, template='hemlock/dash.html', **kwargs ) [source] Embeds a dash app . Parameters: label : str or None, default=None Dashboard label. template : str, default='hemlock/dash.html' Template for the dashboard body. Attributes: src : str src attribute of the <iframe> tag.","title":"hemlock.Dashboard"},{"location":"questions/dashboard/#examples","text":"In this example, we create a simple dash app in which participants click on a button. We embed this app in a hemlock survey, and record the number of times a participant clicked the button. Install dash with: $ hlk install dash Or: $ pip install dash In survey.py : from hemlock import Branch , Dashboard , Label , Page , route @route ( '/survey' ) def start (): return Branch ( Page ( Dashboard ( src = '/dashapp/' , var = 'n_clicks' ) ), Page ( Label ( 'The end.' ), terminal = True ) ) In app.py : import survey import dash import dash_core_components as dcc import dash_html_components as html from dash.dependencies import Input , Output from hemlock import Dashboard , create_app app = create_app () dash_app = dash . Dash ( server = app , routes_pathname_prefix = '/dashapp/' , external_stylesheets = [ 'https://codepen.io/chriddyp/pen/bWLwgP.css' ] ) dash_app . layout = html . Div ([ dcc . Location ( id = 'url' ), html . Button ( 'Click me!' , id = 'button' ), html . P ( id = 'click-tracker' ), ]) @dash_app . callback ( Output ( 'click-tracker' , 'children' ), [ Input ( 'url' , 'search' ), Input ( 'button' , 'n_clicks' )] ) def update_clicks ( search , n_clicks ): n_clicks = n_clicks or 0 Dashboard . record_response ( search , n_clicks ) return ' {} clicks' . format ( n_clicks ) if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app with: $ hlk serve Or: $ python app.py Then open your browser and navigate to http://localhost:5000/ .","title":"Examples"},{"location":"questions/dashboard/#methods","text":"get ( cls, search ) [source] Utility for retrieving a dashboard question in a dash callback. Parameters: search : str, formatted as URL query string Must have 'id' and 'key' parameters. Returns: dashboard : hemlock_dash.Dashboard Dashboard specified by the id in the search string.","title":"Methods"},{"location":"questions/dashboard/#examples_1","text":"... import dash_core_components as dcc from hemlock import Dashboard app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), ... ]) @app . callback ( Output ( ... ), [ Input ( 'url' , 'search' ), ... ] ) def my_callback ( search , ... ): dashboard = Dashboard . get ( search ) record_response ( cls, search, response ) [source] Utility for writing the response attribute of the dashboard question. Parameters: search : str, formatted as URL query string Must have 'id' and 'key' parameters. response : Value to which to set the dash question's repsonse attribute. Returns: dashboard : hemlock_dash.Dashboard Dashboard specified by the id in the search string.","title":"Examples"},{"location":"questions/dashboard/#examples_2","text":"```python ... import dash_core_components as dcc from hemlock import Dashboard app.layout = html.Div([ dcc.Location(id='url', refresh=False), ... ]) @app.callback( Output(...), [Input('url', 'search'), ...] ) def my_callback(search, ...): Dashboard.record_response(search, 'hello world') render_url ( self ) [source]","title":"Examples"},{"location":"questions/download/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Download button See https://dsbowen.github.io/flask-download-btn/ for more details. hemlock. Download class hemlock. Download ( label=None, template='hemlock/download.html', **kwargs ) [source] Allows participants to download files. Inherits from flask_download_btn.DownloadBtnMixin and hemlock.Question . Parameters: label : str or None, default=None Download button label. template : str, default='hemlock/download.html' Download button body template. Examples from hemlock import Download , Page , push_app_context app = push_app_context () Page ( Download ( 'Click here to download a file.' , downloads = ( 'HELLO_WORLD_URL' , 'hello_world.txt' ) )) . preview () Replace 'HELLO_WORLD_URL' with your file download URL. Note that the download button will not download your file from a preview.","title":"Download"},{"location":"questions/download/#download-button","text":"See https://dsbowen.github.io/flask-download-btn/ for more details.","title":"Download button"},{"location":"questions/download/#hemlockdownload","text":"class hemlock. Download ( label=None, template='hemlock/download.html', **kwargs ) [source] Allows participants to download files. Inherits from flask_download_btn.DownloadBtnMixin and hemlock.Question . Parameters: label : str or None, default=None Download button label. template : str, default='hemlock/download.html' Download button body template.","title":"hemlock.Download"},{"location":"questions/download/#examples","text":"from hemlock import Download , Page , push_app_context app = push_app_context () Page ( Download ( 'Click here to download a file.' , downloads = ( 'HELLO_WORLD_URL' , 'hello_world.txt' ) )) . preview () Replace 'HELLO_WORLD_URL' with your file download URL. Note that the download button will not download your file from a preview.","title":"Examples"},{"location":"questions/file/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } File upload hemlock. upload_to_bucket def hemlock. upload_to_bucket ( file_ ) [source] Default hemlock.File submit function. Uploads a participant file to Google bucket. Parameters: file_ : hemlock.File hemlock. File class hemlock. File ( label=None, template='hemlock/file.html', **kwargs ) [source] Allows participants to upload files. Inherits from hemlock.qpolymorphs.InputBase and hemlock.Question . Parameters: label : str or None, default=None Upload file label. template : str, default='hemlock/file.html' Template for the file upload body. Attributes: allowed_extensions : list Allowed file extensions, e.g. ['.png','.jpeg'] . filename : str Name of the file as stored in the Google bucket. Examples Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket, and GOOGLE_APPLICATION_CREDENTIALS to the name of your Google application credentials JSON file . export BUCKET=<my-bucket> GOOGLE_APPLICATION_CREDENTIALS=<my-credentials.json> In survey.py : from hemlock import Branch , File , Page , Label , route @route ( '/survey' ) def start (): return Branch ( Page ( File ( 'Upload a .png' , filename = 'upload' , allowed_extensions = [ '.png' ] )), Page ( Label ( '<p>The End</p>' ), terminal = True ) ) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app locally with: $ python app.py # or python3 app.py And open your browser to http://localhost:5000/ . Upload a .png and click to the next page. You'll find your uploaded file in your Google bucket in participant-1/upload.png . Methods generate_signed_url ( self, expiration=timedelta(hours=0.5), **kwargs ) [source] Generate a signed URL for the uploaded file. Parameters: expiration : datetime.timedelta, default=datetime.timedelta(0, 1800) Duration for which this signed URL is valid. **kwargs : Additional keyword arguments are passed to the generate_signed_url method. Notes Read more about signed URLs . get_allowed_types ( self ) [source] Returns: allowed_types : list List of allowed mimetypes. Derived from self.allowed_extensions . get_path ( self ) [source] Returns: path : str Path to the uploaded file in the Google bucket.","title":"File upload"},{"location":"questions/file/#file-upload","text":"","title":"File upload"},{"location":"questions/file/#hemlockupload_to_bucket","text":"def hemlock. upload_to_bucket ( file_ ) [source] Default hemlock.File submit function. Uploads a participant file to Google bucket. Parameters: file_ : hemlock.File","title":"hemlock.upload_to_bucket"},{"location":"questions/file/#hemlockfile","text":"class hemlock. File ( label=None, template='hemlock/file.html', **kwargs ) [source] Allows participants to upload files. Inherits from hemlock.qpolymorphs.InputBase and hemlock.Question . Parameters: label : str or None, default=None Upload file label. template : str, default='hemlock/file.html' Template for the file upload body. Attributes: allowed_extensions : list Allowed file extensions, e.g. ['.png','.jpeg'] . filename : str Name of the file as stored in the Google bucket.","title":"hemlock.File"},{"location":"questions/file/#examples","text":"Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket, and GOOGLE_APPLICATION_CREDENTIALS to the name of your Google application credentials JSON file . export BUCKET=<my-bucket> GOOGLE_APPLICATION_CREDENTIALS=<my-credentials.json> In survey.py : from hemlock import Branch , File , Page , Label , route @route ( '/survey' ) def start (): return Branch ( Page ( File ( 'Upload a .png' , filename = 'upload' , allowed_extensions = [ '.png' ] )), Page ( Label ( '<p>The End</p>' ), terminal = True ) ) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app locally with: $ python app.py # or python3 app.py And open your browser to http://localhost:5000/ . Upload a .png and click to the next page. You'll find your uploaded file in your Google bucket in participant-1/upload.png .","title":"Examples"},{"location":"questions/file/#methods","text":"generate_signed_url ( self, expiration=timedelta(hours=0.5), **kwargs ) [source] Generate a signed URL for the uploaded file. Parameters: expiration : datetime.timedelta, default=datetime.timedelta(0, 1800) Duration for which this signed URL is valid. **kwargs : Additional keyword arguments are passed to the generate_signed_url method.","title":"Methods"},{"location":"questions/file/#notes","text":"Read more about signed URLs . get_allowed_types ( self ) [source] Returns: allowed_types : list List of allowed mimetypes. Derived from self.allowed_extensions . get_path ( self ) [source] Returns: path : str Path to the uploaded file in the Google bucket.","title":"Notes"},{"location":"questions/input/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Input hemlock. Input class hemlock. Input ( label=None, template='hemlock/input.html', **kwargs ) [source] Inputs take text input by default, or other types of html inputs. Inherits from hemlock.models.InputBase ](bases.md) and [ hemlock.Question` . Parameters: label : str or None, default=None Input label. template : str, default='hemlock/input.html' Template for the input body. Examples from hemlock import Input , Page , push_app_context app = push_app_context () Page ( Input ( 'Input text here.' )) . preview ()","title":"Input"},{"location":"questions/input/#input","text":"","title":"Input"},{"location":"questions/input/#hemlockinput","text":"class hemlock. Input ( label=None, template='hemlock/input.html', **kwargs ) [source] Inputs take text input by default, or other types of html inputs. Inherits from hemlock.models.InputBase ](bases.md) and [ hemlock.Question` . Parameters: label : str or None, default=None Input label. template : str, default='hemlock/input.html' Template for the input body.","title":"hemlock.Input"},{"location":"questions/input/#examples","text":"from hemlock import Input , Page , push_app_context app = push_app_context () Page ( Input ( 'Input text here.' )) . preview ()","title":"Examples"},{"location":"questions/label/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Label hemlock. Label class hemlock. Label ( label=None, template='hemlock/label.html', **kwargs ) [source] This question contains a label and does not receive input from the participant. Parameters: label : str or None, default=None Question label. template : str, default='hemlock/label.html' Path to the Jinja template for the label body. Examples from hemlock import Label , Page , push_app_context app = push_app_context () Page ( Label ( 'Hello World' )) . preview ()","title":"Label"},{"location":"questions/label/#label","text":"","title":"Label"},{"location":"questions/label/#hemlocklabel","text":"class hemlock. Label ( label=None, template='hemlock/label.html', **kwargs ) [source] This question contains a label and does not receive input from the participant. Parameters: label : str or None, default=None Question label. template : str, default='hemlock/label.html' Path to the Jinja template for the label body.","title":"hemlock.Label"},{"location":"questions/label/#examples","text":"from hemlock import Label , Page , push_app_context app = push_app_context () Page ( Label ( 'Hello World' )) . preview ()","title":"Examples"},{"location":"questions/range/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Range sliders hemlock. likert def hemlock. likert ( label=None, choices=5, default=0, **kwargs ) [source] Create a Likert slider. Parameters: label : str, default=None choices : int or list, default=5 A list of choices (str). May also be 5 , 7 , or 9 for default choice lists of length 5, 7, and 9. The list of choices should be an odd length and symmetric around the midpoint. default : int, default=0 Default value. 0 is the scale midpoint. **kwargs : Keyword arguments are passed to the Slider constructor. Returns: Likert : Slider hemlock. Range class hemlock. Range ( label=None, template='hemlock/range.html', **kwargs ) [source] Range sliders can be dragged between minimum and maximum values in step increments. Inherits from hemlock.InputBase and hemlock.Question . Parameters: label : str or None, default=None Range label. template : str, default='hemlock/range.html' Template for the range body. Notes Ranges have a default javascript which displays the value of the range slider to participants. This will be appended to any js and extra_js arguments passed to the constructor. Examples from hemlock import Range , Page , push_app_context app = push_app_context () Page ( Range ( 'This is a range slider.' )) . preview () hemlock. RangeInput class hemlock. RangeInput ( label=None, template='hemlock/rangeinput.html', **kwargs ) [source] Range slider with an input field. Inherits from hemlock.InputBase and hemlock.Question . Parameters: label : str or None, default=None Range label. template : str, default='hemlock/rangeinput.html' Template for the range body. width : str, default='5em' Width of the input field. Notes Ranges have a default javascript which displays the value of the range slider to participants. This will be appended to any js and extra_js arguments passed to the constructor. Examples from hemlock import RangeInput , Page , push_app_context app = push_app_context () Page ( RangeInput ( 'This is a range slider.' )) . preview () hemlock. Slider class hemlock. Slider ( label=None, template='hemlock/slider.html', **kwargs ) [source] Bootstrap slider. See here . Inherits from hemlock.InputBase and hemlock.Question . Parameters: label : str or None, default=None Range label. template : str, default='hemlock/slider.html' Notes You can input the formatter parameter in one of three ways: Javascript function (str). See here . List of formatted values, one for each tick. Dictionary mapping tick values to formatted values. Any ticks not mapped to a formatted value are displayed as the tick value. Examples from hemlock import Page , Slider , push_app_context app = push_app_context () Page ( Slider ( 'This is a fancy Bootstrap slider' , ticks = [ 0 , 2 , 4 ], ticks_labels = [ 'very low' , 'medium' , 'high' ], ticks_positions = [ 0 , 50 , 100 ], formatter = [ 'very low' , 'low' , 'medium' , 'high' , 'very high' ] ) ) . preview () Methods get_max ( self ) [source] Returns: max : scalar Maximum value the slider can take. get_min ( self ) [source] Returns: min : scalar Minimum value the sldier can take. get_values ( self ) [source] Returns: values : generator Range of values the slider can take. get_midpoint ( self ) [source] Returns: midpoint : scalar Scale midpoint.","title":"Range"},{"location":"questions/range/#range-sliders","text":"","title":"Range sliders"},{"location":"questions/range/#hemlocklikert","text":"def hemlock. likert ( label=None, choices=5, default=0, **kwargs ) [source] Create a Likert slider. Parameters: label : str, default=None choices : int or list, default=5 A list of choices (str). May also be 5 , 7 , or 9 for default choice lists of length 5, 7, and 9. The list of choices should be an odd length and symmetric around the midpoint. default : int, default=0 Default value. 0 is the scale midpoint. **kwargs : Keyword arguments are passed to the Slider constructor. Returns: Likert : Slider","title":"hemlock.likert"},{"location":"questions/range/#hemlockrange","text":"class hemlock. Range ( label=None, template='hemlock/range.html', **kwargs ) [source] Range sliders can be dragged between minimum and maximum values in step increments. Inherits from hemlock.InputBase and hemlock.Question . Parameters: label : str or None, default=None Range label. template : str, default='hemlock/range.html' Template for the range body.","title":"hemlock.Range"},{"location":"questions/range/#notes","text":"Ranges have a default javascript which displays the value of the range slider to participants. This will be appended to any js and extra_js arguments passed to the constructor.","title":"Notes"},{"location":"questions/range/#examples","text":"from hemlock import Range , Page , push_app_context app = push_app_context () Page ( Range ( 'This is a range slider.' )) . preview ()","title":"Examples"},{"location":"questions/range/#hemlockrangeinput","text":"class hemlock. RangeInput ( label=None, template='hemlock/rangeinput.html', **kwargs ) [source] Range slider with an input field. Inherits from hemlock.InputBase and hemlock.Question . Parameters: label : str or None, default=None Range label. template : str, default='hemlock/rangeinput.html' Template for the range body. width : str, default='5em' Width of the input field.","title":"hemlock.RangeInput"},{"location":"questions/range/#notes_1","text":"Ranges have a default javascript which displays the value of the range slider to participants. This will be appended to any js and extra_js arguments passed to the constructor.","title":"Notes"},{"location":"questions/range/#examples_1","text":"from hemlock import RangeInput , Page , push_app_context app = push_app_context () Page ( RangeInput ( 'This is a range slider.' )) . preview ()","title":"Examples"},{"location":"questions/range/#hemlockslider","text":"class hemlock. Slider ( label=None, template='hemlock/slider.html', **kwargs ) [source] Bootstrap slider. See here . Inherits from hemlock.InputBase and hemlock.Question . Parameters: label : str or None, default=None Range label. template : str, default='hemlock/slider.html'","title":"hemlock.Slider"},{"location":"questions/range/#notes_2","text":"You can input the formatter parameter in one of three ways: Javascript function (str). See here . List of formatted values, one for each tick. Dictionary mapping tick values to formatted values. Any ticks not mapped to a formatted value are displayed as the tick value.","title":"Notes"},{"location":"questions/range/#examples_2","text":"from hemlock import Page , Slider , push_app_context app = push_app_context () Page ( Slider ( 'This is a fancy Bootstrap slider' , ticks = [ 0 , 2 , 4 ], ticks_labels = [ 'very low' , 'medium' , 'high' ], ticks_positions = [ 0 , 50 , 100 ], formatter = [ 'very low' , 'low' , 'medium' , 'high' , 'very high' ] ) ) . preview ()","title":"Examples"},{"location":"questions/range/#methods","text":"get_max ( self ) [source] Returns: max : scalar Maximum value the slider can take. get_min ( self ) [source] Returns: min : scalar Minimum value the sldier can take. get_values ( self ) [source] Returns: values : generator Range of values the slider can take. get_midpoint ( self ) [source] Returns: midpoint : scalar Scale midpoint.","title":"Methods"},{"location":"questions/select/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Select (dropdown) hemlock. Select class hemlock. Select ( label=None, choices=[], template='hemlock/select.html', **kwargs ) [source] Select questions allow participants to select one or more options from a dropdown menu. Inherits from hemlock.InputBase and hemlock.ChoiceQuestion . Its default debug function is click_choices . Parameters: label : str or None, default=None Select question label. choices : list of hemlock.Option, str, tuple, or dict, default=[] Options the participant can select. template : str, default='hemlock/select.html' Template for the select body. Attributes: align : str, default='left' Choice alignment; 'left' , 'center' , or 'right' . choices : list of hemlock.Option Set for the choices parameter. multiple : bool, default=False Indicates that the participant may select multiple choices. Notes An option can be input as any of the following: Option object. str , treated as the choice label. (choice label, value) tuple. (choice label, value, name) tuple. Dictionary with choice keyword arguments. Examples from hemlock import Page , Select , Option , push_app_context app = push_app_context () Page ( Select ( 'Select one.' , [ 'World' , 'Moon' , 'Star' ] ) ) . preview ()","title":"Select"},{"location":"questions/select/#select-dropdown","text":"","title":"Select (dropdown)"},{"location":"questions/select/#hemlockselect","text":"class hemlock. Select ( label=None, choices=[], template='hemlock/select.html', **kwargs ) [source] Select questions allow participants to select one or more options from a dropdown menu. Inherits from hemlock.InputBase and hemlock.ChoiceQuestion . Its default debug function is click_choices . Parameters: label : str or None, default=None Select question label. choices : list of hemlock.Option, str, tuple, or dict, default=[] Options the participant can select. template : str, default='hemlock/select.html' Template for the select body. Attributes: align : str, default='left' Choice alignment; 'left' , 'center' , or 'right' . choices : list of hemlock.Option Set for the choices parameter. multiple : bool, default=False Indicates that the participant may select multiple choices.","title":"hemlock.Select"},{"location":"questions/select/#notes","text":"An option can be input as any of the following: Option object. str , treated as the choice label. (choice label, value) tuple. (choice label, value, name) tuple. Dictionary with choice keyword arguments.","title":"Notes"},{"location":"questions/select/#examples","text":"from hemlock import Page , Select , Option , push_app_context app = push_app_context () Page ( Select ( 'Select one.' , [ 'World' , 'Moon' , 'Star' ] ) ) . preview ()","title":"Examples"},{"location":"questions/textarea/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Textarea hemlock. Textarea class hemlock. Textarea ( label=None, template='hemlock/textarea.html', **kwargs ) [source] Textareas provide large text boxes for free responses. Inherits from hemlock.qpolymorphs.InputBase and hemlock.Question . Parameters: label : str, default=None Textarea label. template : str, default='hemlock/textarea.html' Template for the textarea body. Notes Textareas have a default javascript which displays the character and word count to participants. This will be appended to any js and extra_js arguments passed to the constructor. Examples from hemlock import Page , Textarea , push_app_context app = push_app_context () Page ( Textarea ( 'This is a textarea.' )) . preview ()","title":"Textarea"},{"location":"questions/textarea/#textarea","text":"","title":"Textarea"},{"location":"questions/textarea/#hemlocktextarea","text":"class hemlock. Textarea ( label=None, template='hemlock/textarea.html', **kwargs ) [source] Textareas provide large text boxes for free responses. Inherits from hemlock.qpolymorphs.InputBase and hemlock.Question . Parameters: label : str, default=None Textarea label. template : str, default='hemlock/textarea.html' Template for the textarea body.","title":"hemlock.Textarea"},{"location":"questions/textarea/#notes","text":"Textareas have a default javascript which displays the character and word count to participants. This will be appended to any js and extra_js arguments passed to the constructor.","title":"Notes"},{"location":"questions/textarea/#examples","text":"from hemlock import Page , Textarea , push_app_context app = push_app_context () Page ( Textarea ( 'This is a textarea.' )) . preview ()","title":"Examples"},{"location":"setup/linux/","text":"Linux setup These instructions were written for Ubuntu 20.04. Tip About 50% of the problems you encounter during setup can be fixed by closing and re-opening your terminal window. If you have any problems, this is the first thing to try. Python3 and pip3 Python is hemlock's primary language. Pip allows you to install python packages, including hemlock and its command line interface, hemlock-CLI. Many linux distributions come with python3. Verify your python3 installation: $ python3 --version Python 3 .x.x If you don't have python3, download the latest version here . Upgrade pip: $ python3 -m pip install --upgrade pip Verify your pip installation: $ pip3 --version pip xx.x.x ... pip versus pip3 You'll install several python packages using pip . Conventionally, the command to install these is written as: $ pip install <my-requested-package> You may need to repace this with: $ pip3 install <my-requested-package> Or even: $ python3 -m pip install <my-requested-package> Hemlock-CLI Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Download with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx Git and github Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. Find installation instructions for git here . Verify your git installation: $ git --version git version x.xx.x.linux.1 Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> Read everything until STOP before creating your github token. Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface. Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP. Visual studio code I recommend visual studio code for editing python files. Download VS code here . Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .xx.x Jupyter Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : x.x.x jupyter-notebook : x.x.x ... Google chrome Hemlock is developed and tested primarily on chrome. Download chrome here . Verify that you can open it: $ python3 -m webbrowser https://dsbowen.github.io You should see chrome open to my github.io page. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial . Chromedriver Hemlock's custom debugging tool and survey view functions use chromedriver . To use these features locally, you'll need to download chromedriver (this command assumes you have curl installed; see here to install curl ): $ hlk setup linux --chromedriver This will ask you to copy the chromedriver Linux download URL from here and paste it in your terminal window. Verify your chromedriver installation: $ chromedriver --version ChromeDriver xx.xxxx Chrome and chromedriver compatibility Google chrome will automatically update. Chromedriver will not. If you encounter a compatibility error in the future, simply repeat the above instructions. If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial . Heroku Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . You can install heroku-CLI using hemlock-CLI: $ hlk setup linux --heroku-cli Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x linux-x64 node-vxx.xx.x EACCES error See this github issue if you experience a 'EACCES' error. Do not simply use sudo ; this only masks issues you'll encounter later. Click here to return to the Deploy section of the tutorial .","title":"Linux"},{"location":"setup/linux/#linux-setup","text":"These instructions were written for Ubuntu 20.04. Tip About 50% of the problems you encounter during setup can be fixed by closing and re-opening your terminal window. If you have any problems, this is the first thing to try.","title":"Linux setup"},{"location":"setup/linux/#python3-and-pip3","text":"Python is hemlock's primary language. Pip allows you to install python packages, including hemlock and its command line interface, hemlock-CLI. Many linux distributions come with python3. Verify your python3 installation: $ python3 --version Python 3 .x.x If you don't have python3, download the latest version here . Upgrade pip: $ python3 -m pip install --upgrade pip Verify your pip installation: $ pip3 --version pip xx.x.x ... pip versus pip3 You'll install several python packages using pip . Conventionally, the command to install these is written as: $ pip install <my-requested-package> You may need to repace this with: $ pip3 install <my-requested-package> Or even: $ python3 -m pip install <my-requested-package>","title":"Python3 and pip3"},{"location":"setup/linux/#hemlock-cli","text":"Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Download with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx","title":"Hemlock-CLI"},{"location":"setup/linux/#git-and-github","text":"Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. Find installation instructions for git here . Verify your git installation: $ git --version git version x.xx.x.linux.1 Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> Read everything until STOP before creating your github token. Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface. Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP.","title":"Git and github"},{"location":"setup/linux/#visual-studio-code","text":"I recommend visual studio code for editing python files. Download VS code here . Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .xx.x","title":"Visual studio code"},{"location":"setup/linux/#jupyter","text":"Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : x.x.x jupyter-notebook : x.x.x ...","title":"Jupyter"},{"location":"setup/linux/#google-chrome","text":"Hemlock is developed and tested primarily on chrome. Download chrome here . Verify that you can open it: $ python3 -m webbrowser https://dsbowen.github.io You should see chrome open to my github.io page. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial .","title":"Google chrome"},{"location":"setup/linux/#chromedriver","text":"Hemlock's custom debugging tool and survey view functions use chromedriver . To use these features locally, you'll need to download chromedriver (this command assumes you have curl installed; see here to install curl ): $ hlk setup linux --chromedriver This will ask you to copy the chromedriver Linux download URL from here and paste it in your terminal window. Verify your chromedriver installation: $ chromedriver --version ChromeDriver xx.xxxx Chrome and chromedriver compatibility Google chrome will automatically update. Chromedriver will not. If you encounter a compatibility error in the future, simply repeat the above instructions. If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial .","title":"Chromedriver"},{"location":"setup/linux/#heroku","text":"Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . You can install heroku-CLI using hemlock-CLI: $ hlk setup linux --heroku-cli Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x linux-x64 node-vxx.xx.x EACCES error See this github issue if you experience a 'EACCES' error. Do not simply use sudo ; this only masks issues you'll encounter later. Click here to return to the Deploy section of the tutorial .","title":"Heroku"},{"location":"setup/mac/","text":"Mac setup These instructions were written for Mac OS 10.9. Tip About 50% of the problems you encounter during setup can be fixed by closing and re-opening your terminal window. If you have any problems, this is the first thing to try. Open a terminal window Hemlock requires you to use a terminal window for setting up, editing, and deploying hemlock projects. To open a terminal window, enter 'terminal' in spotlight search. Terminal commands are written in bash: $ <my-bash-command> Tip You don't type $ . This just indicates the beginning of a bash command. For the tutorial, always change to your home directory after you open your terminal. Do this by entering: $ cd Xcode Mac OS typically requires Xcode Command-line Tools. Install in your terminal: $ xcode-select --install Or from the Mac app store . Python3 and pip3 Read everything before STOP before downloading python. Python is hemlock's primary language. Pip allows you to install python packages, including hemlock and its command line interface, hemlock-CLI. Download the latest version of python here . When you start the python installer, you may see an Add Python to PATH option on the first page. Make sure to select this option. STOP. Close and re-open your terminal window. Verify your python installation. $ python3 --version Python 3 .6.8 Upgrade pip: $ python3 -m pip install --upgrade pip Verify your pip installation: $ pip3 --version pip xx.x.x ... pip versus pip3 You'll install several python packages using pip . Conventionally, the command to install these is written as: $ pip install <my-requested-package> You may need to repace this with: $ pip3 install <my-requested-package> Or even: $ python3 -m pip install <my-requested-package> Hemlock-CLI Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Install with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx Git and github Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. Macs typically have git pre-installed, which you can verify: $ git --version git version x.xx.x If you don't have git, follow the download and installation instructions here . Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> For example, I would enter: $ git config --global user.name dsbowen $ git config --global user.email dsbowen@wharton.upenn.edu Read everything until STOP before creating your github token. Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface. Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP. Visual studio code I recommend visual studio code for editing python files. Download VS code here Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .xx.x code: command not found If you experience a \"command not found\" error, it's probably because VS code isn't in your PATH . Try this: Open the VS code application and press Command + Shift + P or F1 . Type shell in command palette. You should see an option like shell command : Install code in PATH . Click that. Close and re-open your terminal and verify your installation. See here for more details. . Jupyter Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : 4 .6.3 jupyter-notebook : 6 .0.3 qtconsole : not installed ipython : 7 .16.1 ipykernel : 5 .3.2 jupyter client : 6 .1.5 jupyter lab : not installed nbconvert : 5 .6.1 ipywidgets : not installed nbformat : 5 .0.7 traitlets : 4 .3.3 Google chrome Hemlock is developed and tested primarily on chrome. Download chrome here . Verify that you can open it as follows: $ python3 -m webbrowser https://dsbowen.github.io You should see chrome open to my github.io page. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial . Chromedriver Hemlock's custom debugging tool and survey view functions use chromedriver . To use these features locally, you'll need to download chromedriver: $ hlk setup mac --chromedriver This will ask you to copy the chromedriver Mac download URL from here and paste it in your terminal window. Close and re-open your terminal. Verify your chromedriver installation: $ chromedriver --version ChromeDriver x.xx.x Chrome and chromedriver compatibility Google chrome will automatically update. Chromedriver will not. If you encounter a compatibility error in the future, simply repeat the above instructions. If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial . Heroku Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . You can install heroku-CLI using hemlock-CLI: $ hlk setup mac --heroku-cli Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x mac node-vxx.xx.x EACCES error See this github issue if you experience a 'EACCES' error. Do not simply use sudo ; this only masks issues you'll encounter later. Click here to return to the Deploy section of the tutorial .","title":"Mac"},{"location":"setup/mac/#mac-setup","text":"These instructions were written for Mac OS 10.9. Tip About 50% of the problems you encounter during setup can be fixed by closing and re-opening your terminal window. If you have any problems, this is the first thing to try.","title":"Mac setup"},{"location":"setup/mac/#open-a-terminal-window","text":"Hemlock requires you to use a terminal window for setting up, editing, and deploying hemlock projects. To open a terminal window, enter 'terminal' in spotlight search. Terminal commands are written in bash: $ <my-bash-command> Tip You don't type $ . This just indicates the beginning of a bash command. For the tutorial, always change to your home directory after you open your terminal. Do this by entering: $ cd","title":"Open a terminal window"},{"location":"setup/mac/#xcode","text":"Mac OS typically requires Xcode Command-line Tools. Install in your terminal: $ xcode-select --install Or from the Mac app store .","title":"Xcode"},{"location":"setup/mac/#python3-and-pip3","text":"Read everything before STOP before downloading python. Python is hemlock's primary language. Pip allows you to install python packages, including hemlock and its command line interface, hemlock-CLI. Download the latest version of python here . When you start the python installer, you may see an Add Python to PATH option on the first page. Make sure to select this option. STOP. Close and re-open your terminal window. Verify your python installation. $ python3 --version Python 3 .6.8 Upgrade pip: $ python3 -m pip install --upgrade pip Verify your pip installation: $ pip3 --version pip xx.x.x ... pip versus pip3 You'll install several python packages using pip . Conventionally, the command to install these is written as: $ pip install <my-requested-package> You may need to repace this with: $ pip3 install <my-requested-package> Or even: $ python3 -m pip install <my-requested-package>","title":"Python3 and pip3"},{"location":"setup/mac/#hemlock-cli","text":"Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Install with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx","title":"Hemlock-CLI"},{"location":"setup/mac/#git-and-github","text":"Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. Macs typically have git pre-installed, which you can verify: $ git --version git version x.xx.x If you don't have git, follow the download and installation instructions here . Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> For example, I would enter: $ git config --global user.name dsbowen $ git config --global user.email dsbowen@wharton.upenn.edu Read everything until STOP before creating your github token. Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface. Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP.","title":"Git and github"},{"location":"setup/mac/#visual-studio-code","text":"I recommend visual studio code for editing python files. Download VS code here Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .xx.x code: command not found If you experience a \"command not found\" error, it's probably because VS code isn't in your PATH . Try this: Open the VS code application and press Command + Shift + P or F1 . Type shell in command palette. You should see an option like shell command : Install code in PATH . Click that. Close and re-open your terminal and verify your installation. See here for more details. .","title":"Visual studio code"},{"location":"setup/mac/#jupyter","text":"Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : 4 .6.3 jupyter-notebook : 6 .0.3 qtconsole : not installed ipython : 7 .16.1 ipykernel : 5 .3.2 jupyter client : 6 .1.5 jupyter lab : not installed nbconvert : 5 .6.1 ipywidgets : not installed nbformat : 5 .0.7 traitlets : 4 .3.3","title":"Jupyter"},{"location":"setup/mac/#google-chrome","text":"Hemlock is developed and tested primarily on chrome. Download chrome here . Verify that you can open it as follows: $ python3 -m webbrowser https://dsbowen.github.io You should see chrome open to my github.io page. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial .","title":"Google chrome"},{"location":"setup/mac/#chromedriver","text":"Hemlock's custom debugging tool and survey view functions use chromedriver . To use these features locally, you'll need to download chromedriver: $ hlk setup mac --chromedriver This will ask you to copy the chromedriver Mac download URL from here and paste it in your terminal window. Close and re-open your terminal. Verify your chromedriver installation: $ chromedriver --version ChromeDriver x.xx.x Chrome and chromedriver compatibility Google chrome will automatically update. Chromedriver will not. If you encounter a compatibility error in the future, simply repeat the above instructions. If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial .","title":"Chromedriver"},{"location":"setup/mac/#heroku","text":"Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . You can install heroku-CLI using hemlock-CLI: $ hlk setup mac --heroku-cli Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x mac node-vxx.xx.x EACCES error See this github issue if you experience a 'EACCES' error. Do not simply use sudo ; this only masks issues you'll encounter later. Click here to return to the Deploy section of the tutorial .","title":"Heroku"},{"location":"setup/win/","text":"Windows setup These instructions were written for Windows 10. Tip About 50% of the problems you encounter during setup can be fixed by closing and re-opening your terminal window. If you have any problems, this is the first thing to try. Git and github Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. You can find git download and installation instructions here . We'll use the git bash terminal for this tutorial. Right click anywhere on your desktop and select 'Git Bash Here`. You should see a terminal window appear. Enter the following into your terminal: $ cd This moves you to your home directory. It's not important that you understand exactly what this means, but if you're dying to find out, read this . Tip You don't type $ . This just indicates the beginning of a bash command. For the tutorial, always change to your home directory after you open your terminal. Do this by entering: $ cd Verify your git installation: $ git --version git version 2 .27.0.windows.1 Tip git --version is the command you enter in your terminal. The line underneath it ('git version...') is the output. Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> For example, I would enter: $ git config --global user.name dsbowen $ git config --global user.email dsbowen@wharton.upenn.edu Read everything until STOP before creating your github token. Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface (more on this later). Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP. Python3 and pip3 Read everything before STOP before downloading python. Python is hemlock's primary language. Pip allows you to install python packages, including hemlock and its command line interface, hemlock-CLI. Download the latest version of python here . When you start the python installer, you may see an Add Python to PATH option on the first page. Make sure to select this option. STOP. Close and re-open your terminal window and enter: $ which python You should see a line print underneath which python . This is the location of your python executable (i.e., the file that runs python). On my computer, it looks like: /c/Users/DBSpe/AppData/Local/Programs/Python/Python36-32/python The python executable may be in a different location on your computer. In general, it'll look like: <my-python-location>/python We're going to change directories to that location (i.e. we're going to go to where the python executable is). On my computer, I would enter: $ cd /c/Users/DBSpe/AppData/Local/Programs/Python/Python36-32 In general, you would enter: $ cd <my-python-location> Important The line that printed under which python was <my-python-location>/python . You'll then enter cd <my-python-location> , not cd <my-python-location>/python . Copy python.exe to python3.exe : $ cp python.exe python3.exe Verify your python installation: $ python3 --version Python 3 .6.8 Permission denied error If you get a \"Permission denied\" error here, try this: Go to 'Manage app execution aliases' in system settings. You can get there by typing 'manage app execution aliases' in the Windows search bar. Turn off 'App Installer python3.exe'. See here for details. Next, upgrade pip: $ python3 -m pip install --upgrade pip Verify your pip installation: $ pip3 --version pip 20 .1.1 from c: \\u sers \\d bspe \\a ppdata \\l ocal \\p rograms \\p ython \\p ython36-32 \\l ib \\s ite-packages \\p ip ( python3.6 ) pip versus pip3 You'll install several python packages using pip . Conventionally, the command to install these is written as: $ pip install <my-requested-package> You may need to repace this with: $ pip3 install <my-requested-package> Or even: $ python3 -m pip install <my-requested-package> Congratulations! You've installed python. Now return to your home directory: $ cd Hemlock-CLI Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Install with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx Visual studio code I recommend visual studio code for editing python files. Download VS code here Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .47.2 17299e413d5590b14ab0340ea477cdd86ff13dafx64 Jupyter Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : 4 .6.3 jupyter-notebook : 6 .0.3 qtconsole : not installed ipython : 7 .16.1 ipykernel : 5 .3.2 jupyter client : 6 .1.5 jupyter lab : not installed nbconvert : 5 .6.1 ipywidgets : not installed nbformat : 5 .0.7 traitlets : 4 .3.3 Google chrome Hemlock is developed and tested primarily on chrome. Download chrome here . Verify that you can open it as follows: $ python3 -m webbrowser https://dsbowen.github.io You should see chrome open to my github.io page. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial . Chromedriver Hemlock's custom debugging tool and survey view functions use chromedriver . To use these features locally, you'll need to download chromedriver: $ hlk setup win --chromedriver This will ask you to copy the chromedriver Windows download URL from here and paste it in your terminal window. Close and re-open your terminal. Verify your chromedriver installation: $ chromedriver --version ChromeDriver x.xx.x Chrome and chromedriver compatibility Google chrome will automatically update. Chromedriver will not. If you encounter a compatibility error in the future, simply repeat the above instructions. If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial . Heroku Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . Then, download and install the heroku command line interface (heroku-CLI) following these instructions . Close and re-open your terminal. Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x win32-x64 node-vxx.xx.x Log into heroku: $ heroku login Click here to return to the Deploy section of the tutorial .","title":"Windows"},{"location":"setup/win/#windows-setup","text":"These instructions were written for Windows 10. Tip About 50% of the problems you encounter during setup can be fixed by closing and re-opening your terminal window. If you have any problems, this is the first thing to try.","title":"Windows setup"},{"location":"setup/win/#git-and-github","text":"Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. You can find git download and installation instructions here . We'll use the git bash terminal for this tutorial. Right click anywhere on your desktop and select 'Git Bash Here`. You should see a terminal window appear. Enter the following into your terminal: $ cd This moves you to your home directory. It's not important that you understand exactly what this means, but if you're dying to find out, read this . Tip You don't type $ . This just indicates the beginning of a bash command. For the tutorial, always change to your home directory after you open your terminal. Do this by entering: $ cd Verify your git installation: $ git --version git version 2 .27.0.windows.1 Tip git --version is the command you enter in your terminal. The line underneath it ('git version...') is the output. Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> For example, I would enter: $ git config --global user.name dsbowen $ git config --global user.email dsbowen@wharton.upenn.edu Read everything until STOP before creating your github token. Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface (more on this later). Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP.","title":"Git and github"},{"location":"setup/win/#python3-and-pip3","text":"Read everything before STOP before downloading python. Python is hemlock's primary language. Pip allows you to install python packages, including hemlock and its command line interface, hemlock-CLI. Download the latest version of python here . When you start the python installer, you may see an Add Python to PATH option on the first page. Make sure to select this option. STOP. Close and re-open your terminal window and enter: $ which python You should see a line print underneath which python . This is the location of your python executable (i.e., the file that runs python). On my computer, it looks like: /c/Users/DBSpe/AppData/Local/Programs/Python/Python36-32/python The python executable may be in a different location on your computer. In general, it'll look like: <my-python-location>/python We're going to change directories to that location (i.e. we're going to go to where the python executable is). On my computer, I would enter: $ cd /c/Users/DBSpe/AppData/Local/Programs/Python/Python36-32 In general, you would enter: $ cd <my-python-location> Important The line that printed under which python was <my-python-location>/python . You'll then enter cd <my-python-location> , not cd <my-python-location>/python . Copy python.exe to python3.exe : $ cp python.exe python3.exe Verify your python installation: $ python3 --version Python 3 .6.8 Permission denied error If you get a \"Permission denied\" error here, try this: Go to 'Manage app execution aliases' in system settings. You can get there by typing 'manage app execution aliases' in the Windows search bar. Turn off 'App Installer python3.exe'. See here for details. Next, upgrade pip: $ python3 -m pip install --upgrade pip Verify your pip installation: $ pip3 --version pip 20 .1.1 from c: \\u sers \\d bspe \\a ppdata \\l ocal \\p rograms \\p ython \\p ython36-32 \\l ib \\s ite-packages \\p ip ( python3.6 ) pip versus pip3 You'll install several python packages using pip . Conventionally, the command to install these is written as: $ pip install <my-requested-package> You may need to repace this with: $ pip3 install <my-requested-package> Or even: $ python3 -m pip install <my-requested-package> Congratulations! You've installed python. Now return to your home directory: $ cd","title":"Python3 and pip3"},{"location":"setup/win/#hemlock-cli","text":"Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Install with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx","title":"Hemlock-CLI"},{"location":"setup/win/#visual-studio-code","text":"I recommend visual studio code for editing python files. Download VS code here Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .47.2 17299e413d5590b14ab0340ea477cdd86ff13dafx64","title":"Visual studio code"},{"location":"setup/win/#jupyter","text":"Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : 4 .6.3 jupyter-notebook : 6 .0.3 qtconsole : not installed ipython : 7 .16.1 ipykernel : 5 .3.2 jupyter client : 6 .1.5 jupyter lab : not installed nbconvert : 5 .6.1 ipywidgets : not installed nbformat : 5 .0.7 traitlets : 4 .3.3","title":"Jupyter"},{"location":"setup/win/#google-chrome","text":"Hemlock is developed and tested primarily on chrome. Download chrome here . Verify that you can open it as follows: $ python3 -m webbrowser https://dsbowen.github.io You should see chrome open to my github.io page. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial .","title":"Google chrome"},{"location":"setup/win/#chromedriver","text":"Hemlock's custom debugging tool and survey view functions use chromedriver . To use these features locally, you'll need to download chromedriver: $ hlk setup win --chromedriver This will ask you to copy the chromedriver Windows download URL from here and paste it in your terminal window. Close and re-open your terminal. Verify your chromedriver installation: $ chromedriver --version ChromeDriver x.xx.x Chrome and chromedriver compatibility Google chrome will automatically update. Chromedriver will not. If you encounter a compatibility error in the future, simply repeat the above instructions. If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial .","title":"Chromedriver"},{"location":"setup/win/#heroku","text":"Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . Then, download and install the heroku command line interface (heroku-CLI) following these instructions . Close and re-open your terminal. Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x win32-x64 node-vxx.xx.x Log into heroku: $ heroku login Click here to return to the Deploy section of the tutorial .","title":"Heroku"},{"location":"setup/wsl/","text":"Windows Subsystem for Linux (WSL) setup These instructions were written for Windows 10. Why WSL? The main reason I use WSL is that Windows OS doesn't have a fork (only a spoon), which means you'll need WSL if you want to run Redis. You can find download instructions for WSL here . Download WSL2, not WSL1. I personally use the Ubuntu distribution. After you've installed WSL, open a terminal window (WIN + R, then enter e.g., 'ubuntu2004'. You may be prompted to create a username and password. Tip About 50% of the problems you encounter during setup can be fixed by closing and re-opening your terminal window. If you have any problems, this is the first thing to try. Update your package lists $ sudo apt-get update Visual studio code Read everything until STOP before downloading or installing anything. I recommend visual studio code for editing python files. Download VS code here Make sure to download the Windows version, not the Linux version. STOP Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .xx.x X Server X server allows you to install python packages and interact with web browsers inside WSL. Download and install VcXsrv in Windows . Make sure you allow X server to access public networks. If you accidentally didn't, see here and here for troubleshooting. Then run xlaunch.exe from the VcSrc folder in Program Files. Keep the default settings except make sure to select \"Disable access control\" . Finally, we set the DISPLAY environment variable for the X server. Open your .profile or .bashrc file with: $ code .profile # or code .bashrc Add these lines to the bottom of the file. export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2; exit;}'):0.0 export LIBGL_ALWAYS_INDIRECT=1 Verify that you've set the DISPLAY variable correctly: $ echo $DISPLAY 172 .19.192.1:0.0 If that didn't work, close and re-open your terminal, then run echo $DISPLAY again. Python3 and pip3 Python is hemlock's primary language. Pip allows you to install python packages, including hemlock and its command line interface, hemlock-CLI. Most WSL distributions come with python3. Verify your python installation with: $ python3 --version Python 3.x.x If you don't have python intalled on your WSL distribution, download python here . I recommend python3.6, rather than the latest version. Why? Because heroku, my recommended method of app deployment, uses python3.6, meaning that if you develop in python3.7+ and deploy in python3.6, you may encounter compatibility issues. Install pip3: $ sudo apt install -f -y python3-pip Respond 'Yes' if asked whether you want to restart services automatically. Verify your pip3 installation: $ pip3 --version pip x.x.x from /usr/lib/python3/dist-packages ( python 3 .x ) pip versus pip3 You'll install several python packages using pip . Conventionally, the command to install these is written as: $ pip install <my-requested-package> You may need to repace this with: $ pip3 install <my-requested-package> Or even: $ python3 -m pip install <my-requested-package> You'll also need the ability to create virtual environments: $ apt install -f -y python3-venv Hemlock-CLI Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Download with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx Git and github Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. You can find git download and installation instructions here . Verify your git installation: $ git --version git version 2 .17.1 Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> Read everything until STOP before creating your github token. Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface. Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP. Jupyter Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : x.x.x jupyter-notebook : x.x.x ... Google chrome To download and install Google chrome, run: $ hlk setup wsl --chrome Verify your installation: $ google-chrome-stable --version Verify that you can open it as follows: $ python3 -m webbrowser https://dsbowen.github.io You should see chrome open to my github.io page. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial . Chromedrover To download and install chromedriver, run: $ hlk setup wsl --chromedriver Verify your installation $ chromedriver --version Chrome and chromedriver compatibility Google chrome will automatically update. Chromedriver will not. If you encounter a compatibility error in the future, simply repeat the above instructions. If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial . Heroku Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . If using hemlock-CLI, you can install and configure the heroku command line interface with: $ hlk setup wsl --heroku-cli This will prompt you to create and log in to a heroku account. Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x linux-x64 node-vxx.xx.x EACCES error See this github issue if you experience a 'EACCES' error. Do not simply use sudo ; this only masks issues you'll encounter later. Click here to return to the Deploy section of the tutorial .","title":"Windows Subsystem for Linux"},{"location":"setup/wsl/#windows-subsystem-for-linux-wsl-setup","text":"These instructions were written for Windows 10. Why WSL? The main reason I use WSL is that Windows OS doesn't have a fork (only a spoon), which means you'll need WSL if you want to run Redis. You can find download instructions for WSL here . Download WSL2, not WSL1. I personally use the Ubuntu distribution. After you've installed WSL, open a terminal window (WIN + R, then enter e.g., 'ubuntu2004'. You may be prompted to create a username and password. Tip About 50% of the problems you encounter during setup can be fixed by closing and re-opening your terminal window. If you have any problems, this is the first thing to try.","title":"Windows Subsystem for Linux (WSL) setup"},{"location":"setup/wsl/#update-your-package-lists","text":"$ sudo apt-get update","title":"Update your package lists"},{"location":"setup/wsl/#visual-studio-code","text":"Read everything until STOP before downloading or installing anything. I recommend visual studio code for editing python files. Download VS code here Make sure to download the Windows version, not the Linux version. STOP Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .xx.x","title":"Visual studio code"},{"location":"setup/wsl/#x-server","text":"X server allows you to install python packages and interact with web browsers inside WSL. Download and install VcXsrv in Windows . Make sure you allow X server to access public networks. If you accidentally didn't, see here and here for troubleshooting. Then run xlaunch.exe from the VcSrc folder in Program Files. Keep the default settings except make sure to select \"Disable access control\" . Finally, we set the DISPLAY environment variable for the X server. Open your .profile or .bashrc file with: $ code .profile # or code .bashrc Add these lines to the bottom of the file. export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2; exit;}'):0.0 export LIBGL_ALWAYS_INDIRECT=1 Verify that you've set the DISPLAY variable correctly: $ echo $DISPLAY 172 .19.192.1:0.0 If that didn't work, close and re-open your terminal, then run echo $DISPLAY again.","title":"X Server"},{"location":"setup/wsl/#python3-and-pip3","text":"Python is hemlock's primary language. Pip allows you to install python packages, including hemlock and its command line interface, hemlock-CLI. Most WSL distributions come with python3. Verify your python installation with: $ python3 --version Python 3.x.x If you don't have python intalled on your WSL distribution, download python here . I recommend python3.6, rather than the latest version. Why? Because heroku, my recommended method of app deployment, uses python3.6, meaning that if you develop in python3.7+ and deploy in python3.6, you may encounter compatibility issues. Install pip3: $ sudo apt install -f -y python3-pip Respond 'Yes' if asked whether you want to restart services automatically. Verify your pip3 installation: $ pip3 --version pip x.x.x from /usr/lib/python3/dist-packages ( python 3 .x ) pip versus pip3 You'll install several python packages using pip . Conventionally, the command to install these is written as: $ pip install <my-requested-package> You may need to repace this with: $ pip3 install <my-requested-package> Or even: $ python3 -m pip install <my-requested-package> You'll also need the ability to create virtual environments: $ apt install -f -y python3-venv","title":"Python3 and pip3"},{"location":"setup/wsl/#hemlock-cli","text":"Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Download with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx","title":"Hemlock-CLI"},{"location":"setup/wsl/#git-and-github","text":"Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. You can find git download and installation instructions here . Verify your git installation: $ git --version git version 2 .17.1 Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> Read everything until STOP before creating your github token. Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface. Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP.","title":"Git and github"},{"location":"setup/wsl/#jupyter","text":"Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : x.x.x jupyter-notebook : x.x.x ...","title":"Jupyter"},{"location":"setup/wsl/#google-chrome","text":"To download and install Google chrome, run: $ hlk setup wsl --chrome Verify your installation: $ google-chrome-stable --version Verify that you can open it as follows: $ python3 -m webbrowser https://dsbowen.github.io You should see chrome open to my github.io page. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial .","title":"Google chrome"},{"location":"setup/wsl/#chromedrover","text":"To download and install chromedriver, run: $ hlk setup wsl --chromedriver Verify your installation $ chromedriver --version Chrome and chromedriver compatibility Google chrome will automatically update. Chromedriver will not. If you encounter a compatibility error in the future, simply repeat the above instructions. If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial .","title":"Chromedrover"},{"location":"setup/wsl/#heroku","text":"Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . If using hemlock-CLI, you can install and configure the heroku command line interface with: $ hlk setup wsl --heroku-cli This will prompt you to create and log in to a heroku account. Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x linux-x64 node-vxx.xx.x EACCES error See this github issue if you experience a 'EACCES' error. Do not simply use sudo ; this only masks issues you'll encounter later. Click here to return to the Deploy section of the tutorial .","title":"Heroku"},{"location":"tools/comprehension/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Comprehension check hemlock.tools. comprehension_check def hemlock.tools. comprehension_check ( instructions, checks, attempts=None ) [source] A comprehension check consists of 'instruction' pages followed by 'check' pages. The data of all questions in a check page must evaluate to True to pass the check. When a participant fails a check, he is brought back to the first instructions page. Participants only have to pass each check once. For example, suppose there are two checks, A and B. The participant passes check A but fails check B. He is brought back to the first page of the instructions. After rereading the instructions, he is brought directly to check B, skipping check A. Parameters: instructions : hemlock.Page or list of hemlock.Page Instruction page(s). checks : hemlock.Page or list of hemlock.Page Check page(s). attempts : int or None, default=None Number of attempts allotted. Participants are allowed to proceed with the survey after exceeding the maximum number of attempts. If None , participants must pass the comprehension check before continuing the survey. Returns: pages : list of hemlock.Page List of instructions pages + check pages. Notes This function adds a hemlock.Submit function to each check page. This must be the last submit function of each check page. Examples We have two files in our root directory. In survey.py : from hemlock import Branch , Page , Label , Input , Submit as S , route from hemlock.tools import comprehension_check @route ( '/survey' ) def start (): return Branch ( * comprehension_check ( instructions = Page ( Label ( '<p>Here are some instructions.</p>' ) ), checks = Page ( Input ( '<p>Enter \"hello world\" or you... shall not... PASS!</p>' , submit = S . match ( 'hello world' ) ) ) ), Page ( Label ( '<p>You passed the comprehension check!</p>' ), terminal = True ) ) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app with: $ python app.py # or python3 app.py Open your browser to http://localhost:5000/ .","title":"Comprehension check"},{"location":"tools/comprehension/#comprehension-check","text":"","title":"Comprehension check"},{"location":"tools/comprehension/#hemlocktoolscomprehension_check","text":"def hemlock.tools. comprehension_check ( instructions, checks, attempts=None ) [source] A comprehension check consists of 'instruction' pages followed by 'check' pages. The data of all questions in a check page must evaluate to True to pass the check. When a participant fails a check, he is brought back to the first instructions page. Participants only have to pass each check once. For example, suppose there are two checks, A and B. The participant passes check A but fails check B. He is brought back to the first page of the instructions. After rereading the instructions, he is brought directly to check B, skipping check A. Parameters: instructions : hemlock.Page or list of hemlock.Page Instruction page(s). checks : hemlock.Page or list of hemlock.Page Check page(s). attempts : int or None, default=None Number of attempts allotted. Participants are allowed to proceed with the survey after exceeding the maximum number of attempts. If None , participants must pass the comprehension check before continuing the survey. Returns: pages : list of hemlock.Page List of instructions pages + check pages.","title":"hemlock.tools.comprehension_check"},{"location":"tools/comprehension/#notes","text":"This function adds a hemlock.Submit function to each check page. This must be the last submit function of each check page.","title":"Notes"},{"location":"tools/comprehension/#examples","text":"We have two files in our root directory. In survey.py : from hemlock import Branch , Page , Label , Input , Submit as S , route from hemlock.tools import comprehension_check @route ( '/survey' ) def start (): return Branch ( * comprehension_check ( instructions = Page ( Label ( '<p>Here are some instructions.</p>' ) ), checks = Page ( Input ( '<p>Enter \"hello world\" or you... shall not... PASS!</p>' , submit = S . match ( 'hello world' ) ) ) ), Page ( Label ( '<p>You passed the comprehension check!</p>' ), terminal = True ) ) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app with: $ python app.py # or python3 app.py Open your browser to http://localhost:5000/ .","title":"Examples"},{"location":"tools/lang/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Language tools hemlock.tools. indef_article def hemlock.tools. indef_article ( word ) [source] Parameters: word : str Word to which the indefinite article belongs. Returns: article : str 'an' if word starts with a vowel, or 'a' otherwise, followed by the word. Examples from hemlock.tools import indef_article [ indef_article ( fruit ) for fruit in ( 'apple' , 'banana' )] Out: ['an apple', 'a banana'] hemlock.tools. join def hemlock.tools. join ( joiner, items ) [source] Parameters: joiner : str Joins the first n-1 items with the last item, e.g. 'and' . items : iterable Items to join. Returns: joined : str Joined items. Examples from hemlock.tools import join print ( join ( 'and' , ( 'world' , 'sun' ))) print ( join ( 'or' , ( 'world' , 'sun' , 'moon' ))) Out: world and sun world, sun, or moon hemlock.tools. markdown def hemlock.tools. markdown ( string, strip_last_paragraph=False ) [source] Convert markdown-formatted string to HMTL. Parameters: string : str Markdown-formatted string. strip_last_paragraph : bool, default=False Strips the <p> tag from the last paragraph. This often prettifies the display. Returns: HTML : str HTML-formatted string. hemlock.tools. plural def hemlock.tools. plural ( n, singular, plural=None ) [source] Parameters: n : int Number. singular : str The singular form of the word. plural : str or None, default=None The plural form of the word. If None , the plural form is assumed to be the singular + 's'. Returns: word : str The singular form if number is 1, plural form otherwise. Examples from hemlock.tools import plural [ ' {} {} ' . format ( n , plural ( n , 'cat' )) for n in range ( 0 , 3 )] Out: ['0 cats', '1 cat', '2 cats'] hemlock.tools. pronouns def hemlock.tools. pronouns ( person, singular, gender=None, pfx='' ) [source] Parameters: person : int 1 , 2 , or 3 for first, second, or third person. singular : bool True for singular, False for plural. gender : str or None, default=None 'male' , 'female' , 'neuter' , or 'epicene' . Required for third person singular pronouns. pfx : str, default='' Prefix for dictionary keys. Use this to distinguish between multiple entities in a single string. Returns: pronouns : dict Mapping of pronoun keys to pronouns. Pronoun keys are 'subject' , 'object' , 'dep_poss' (dependent possessive), 'indep_poss' , (indepedent possessive), 'reflex' (reflexive). Examples from hemlock.tools import pronouns string = ''' {A_subject} said hello to {B_object} as {B_subject} was walking {B_dep_poss} neighbor's dog. 'Is that dog {B_indep_poss} ?', {A_subject} thought to {A_reflex} . ''' string . format ( ** pronouns ( 3 , True , 'male' , pfx = 'A_' ), ** pronouns ( 3 , True , 'female' , pfx = 'B_' ) ) Out: he said hello to her as she was walking her neighbor's dog. 'Is that dog hers?', he thought to himself. In: string . format ( ** pronouns ( 3 , True , 'female' , pfx = 'A_' ), ** pronouns ( 3 , True , 'male' , pfx = 'B_' ) ) Out: she said hello to him as he was walking his neighbor's dog. 'Is that dog his?', she thought to herself.","title":"Language"},{"location":"tools/lang/#language-tools","text":"","title":"Language tools"},{"location":"tools/lang/#hemlocktoolsindef_article","text":"def hemlock.tools. indef_article ( word ) [source] Parameters: word : str Word to which the indefinite article belongs. Returns: article : str 'an' if word starts with a vowel, or 'a' otherwise, followed by the word.","title":"hemlock.tools.indef_article"},{"location":"tools/lang/#examples","text":"from hemlock.tools import indef_article [ indef_article ( fruit ) for fruit in ( 'apple' , 'banana' )] Out: ['an apple', 'a banana']","title":"Examples"},{"location":"tools/lang/#hemlocktoolsjoin","text":"def hemlock.tools. join ( joiner, items ) [source] Parameters: joiner : str Joins the first n-1 items with the last item, e.g. 'and' . items : iterable Items to join. Returns: joined : str Joined items.","title":"hemlock.tools.join"},{"location":"tools/lang/#examples_1","text":"from hemlock.tools import join print ( join ( 'and' , ( 'world' , 'sun' ))) print ( join ( 'or' , ( 'world' , 'sun' , 'moon' ))) Out: world and sun world, sun, or moon","title":"Examples"},{"location":"tools/lang/#hemlocktoolsmarkdown","text":"def hemlock.tools. markdown ( string, strip_last_paragraph=False ) [source] Convert markdown-formatted string to HMTL. Parameters: string : str Markdown-formatted string. strip_last_paragraph : bool, default=False Strips the <p> tag from the last paragraph. This often prettifies the display. Returns: HTML : str HTML-formatted string.","title":"hemlock.tools.markdown"},{"location":"tools/lang/#hemlocktoolsplural","text":"def hemlock.tools. plural ( n, singular, plural=None ) [source] Parameters: n : int Number. singular : str The singular form of the word. plural : str or None, default=None The plural form of the word. If None , the plural form is assumed to be the singular + 's'. Returns: word : str The singular form if number is 1, plural form otherwise.","title":"hemlock.tools.plural"},{"location":"tools/lang/#examples_2","text":"from hemlock.tools import plural [ ' {} {} ' . format ( n , plural ( n , 'cat' )) for n in range ( 0 , 3 )] Out: ['0 cats', '1 cat', '2 cats']","title":"Examples"},{"location":"tools/lang/#hemlocktoolspronouns","text":"def hemlock.tools. pronouns ( person, singular, gender=None, pfx='' ) [source] Parameters: person : int 1 , 2 , or 3 for first, second, or third person. singular : bool True for singular, False for plural. gender : str or None, default=None 'male' , 'female' , 'neuter' , or 'epicene' . Required for third person singular pronouns. pfx : str, default='' Prefix for dictionary keys. Use this to distinguish between multiple entities in a single string. Returns: pronouns : dict Mapping of pronoun keys to pronouns. Pronoun keys are 'subject' , 'object' , 'dep_poss' (dependent possessive), 'indep_poss' , (indepedent possessive), 'reflex' (reflexive).","title":"hemlock.tools.pronouns"},{"location":"tools/lang/#examples_3","text":"from hemlock.tools import pronouns string = ''' {A_subject} said hello to {B_object} as {B_subject} was walking {B_dep_poss} neighbor's dog. 'Is that dog {B_indep_poss} ?', {A_subject} thought to {A_reflex} . ''' string . format ( ** pronouns ( 3 , True , 'male' , pfx = 'A_' ), ** pronouns ( 3 , True , 'female' , pfx = 'B_' ) ) Out: he said hello to her as she was walking her neighbor's dog. 'Is that dog hers?', he thought to himself. In: string . format ( ** pronouns ( 3 , True , 'female' , pfx = 'A_' ), ** pronouns ( 3 , True , 'male' , pfx = 'B_' ) ) Out: she said hello to him as he was walking his neighbor's dog. 'Is that dog his?', she thought to herself.","title":"Examples"},{"location":"tools/mturk/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } MTurk utilities hemlock.tools. consent_page def hemlock.tools. consent_page ( consent_label=None, id_label=ID_LABEL, confirm_label= CONFIRM_LABEL, require=True ) [source] Parameters: consent_label : str or None, default=None The consent terms for your study. If None , the consent label is omitted. id_label : str, default='Enter your MTurk ID to consent' Label asking workers to enter their ID. confirm_label : str, default='Confirm your ID' Label asking for confirmation. require : bool, default=True Indicates that workers are required to enter their ID. Returns: consent page : hemlock.Page hemlock.tools. completion_page def hemlock.tools. completion_page ( participant=None ) [source] Parameters: participant : hemlock.Participant or None, default=None Record the completion code in this participant's metadata. If None , the completion code is recorded in flask-login's current_user . Returns: completion page : hemlock.Page Completion page with unique completion code. hemlock.tools. get_approve_df def hemlock.tools. get_approve_df ( data_df, batch_df, bonus=False, verbose=True ) [source] Parameters: data_df : str or pd.DataFrame Hemlock survey data. This must have 'WorkerId' and 'SurveyCode' columns. bonus : bool, default=False Indicates that workers will receive a bonus. If bonusing workers, data_df`` must include a column called 'BonusAmount'`. verbose : bool, default=True Indicates to print information on approvals, rejections, and bonuses. Returns: approve_df : pd.DataFrame Dataframe with approval and bonus information. Examples from hemlock.tools import get_approve_df , approve_assignments approve_df = get_approve_df ( data_df , 'path/to/batch.csv' , bonus = True ) Out: 90 assignments approved 10 assignments rejected Total bonus: $90 import boto3 client = boto3 . client ( 'mturk' ) approve_assignments ( client , approve_df , bonus = True , reason = 'Great job!' ) hemlock.tools. approve_assignments def hemlock.tools. approve_assignments ( client, approve_df, approve=True, bonus=False, bonus_reason='', OverrideRejection=False ) [source] Approve and reject assignments and pay bonuses. Parameters: client : boto3.client approve_df : pd.DataFrame Output of get_approve_df . approve : bool, default=True Indicates that assignments should be approved and rejected. bonus : bool, default=False Indicates that bonuses should be paid. bonus_reason : str, default='' Reason for giving bonuses. This must be nonempty if paying bonuses. OverrideRejection : bool, default=False Indicates that this function can override rejected assignments.","title":"MTurk"},{"location":"tools/mturk/#mturk-utilities","text":"","title":"MTurk utilities"},{"location":"tools/mturk/#hemlocktoolsconsent_page","text":"def hemlock.tools. consent_page ( consent_label=None, id_label=ID_LABEL, confirm_label= CONFIRM_LABEL, require=True ) [source] Parameters: consent_label : str or None, default=None The consent terms for your study. If None , the consent label is omitted. id_label : str, default='Enter your MTurk ID to consent' Label asking workers to enter their ID. confirm_label : str, default='Confirm your ID' Label asking for confirmation. require : bool, default=True Indicates that workers are required to enter their ID. Returns: consent page : hemlock.Page","title":"hemlock.tools.consent_page"},{"location":"tools/mturk/#hemlocktoolscompletion_page","text":"def hemlock.tools. completion_page ( participant=None ) [source] Parameters: participant : hemlock.Participant or None, default=None Record the completion code in this participant's metadata. If None , the completion code is recorded in flask-login's current_user . Returns: completion page : hemlock.Page Completion page with unique completion code.","title":"hemlock.tools.completion_page"},{"location":"tools/mturk/#hemlocktoolsget_approve_df","text":"def hemlock.tools. get_approve_df ( data_df, batch_df, bonus=False, verbose=True ) [source] Parameters: data_df : str or pd.DataFrame Hemlock survey data. This must have 'WorkerId' and 'SurveyCode' columns. bonus : bool, default=False Indicates that workers will receive a bonus. If bonusing workers, data_df`` must include a column called 'BonusAmount'`. verbose : bool, default=True Indicates to print information on approvals, rejections, and bonuses. Returns: approve_df : pd.DataFrame Dataframe with approval and bonus information.","title":"hemlock.tools.get_approve_df"},{"location":"tools/mturk/#examples","text":"from hemlock.tools import get_approve_df , approve_assignments approve_df = get_approve_df ( data_df , 'path/to/batch.csv' , bonus = True ) Out: 90 assignments approved 10 assignments rejected Total bonus: $90 import boto3 client = boto3 . client ( 'mturk' ) approve_assignments ( client , approve_df , bonus = True , reason = 'Great job!' )","title":"Examples"},{"location":"tools/mturk/#hemlocktoolsapprove_assignments","text":"def hemlock.tools. approve_assignments ( client, approve_df, approve=True, bonus=False, bonus_reason='', OverrideRejection=False ) [source] Approve and reject assignments and pay bonuses. Parameters: client : boto3.client approve_df : pd.DataFrame Output of get_approve_df . approve : bool, default=True Indicates that assignments should be approved and rejected. bonus : bool, default=False Indicates that bonuses should be paid. bonus_reason : str, default='' Reason for giving bonuses. This must be nonempty if paying bonuses. OverrideRejection : bool, default=False Indicates that this function can override rejected assignments.","title":"hemlock.tools.approve_assignments"},{"location":"tools/navbar/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Navigation bar Examples from hemlock import Page , push_app_context from hemlock.tools import Navbar , Navitem , Navitemdd , Dropdownitem app = push_app_context () url_root = 'https://dsbowen.github.io/' navbar = Navbar ( 'Hemlock' , [ ( 'Application' , href = url_root + 'app' ), ( 'Tools' , [ ( 'Language' , href = url_root + 'tools/lang' ), ( 'Navbar' , href = url_root + 'tools/navbar' ) ] ) ], href = url_root + 'hemlock' ) Page ( navbar = navbar . render ()) . preview () hemlock.tools. NavBase class hemlock.tools. NavBase ( label, template, href='', a_class=[], a_attrs={} ) [source] All navigation models inherit from this base. Parameters and attributes: label : str Label for the navigation element. template : str Path to template file or string. This is not a Jinja template, as you may wish to generate html for statics outside the application context. href : str, default='' Hyperref to which the navigation element links. a_attrs : dict, default={} Dictionary of HTML attributes for the navigation element's <a> tag. Methods render ( self ) [source] Returns: rendered : str hemlock.tools. NavitemList Methods convert ( cls, item ) [source] hemlock.tools. Navbar class hemlock.tools. Navbar ( label='', navitems=[], href='#', template=os.path.join( DIR, 'navbar.html'), a_class=['navbar-brand'], a_attrs={}, navbar_attrs ={'class': ['navbar', 'navbar-expand-lg', 'navbar-light', 'bg-light', 'fixed-top']} ) [source] Parameters: label : str, default='' navitems : list of hemlock.tools.Navitem and hemlock.tools.Navitemdd Navigation items associated with the navbar. href : str, default='' template : str, default='directory/navbar.html' By default, this is a file stored in the directory of the current file. a_attrs : dict navbar_attrs : dict HTML attributes for the <nav> tag. Methods render ( self ) [source] Returns: rendered : str Rendered navbar HTML. hemlock.tools. Navitem class hemlock.tools. Navitem ( label='', href='', template=os.path.join(DIR, 'navitem.html'), a_class=['nav-item', 'nav-link'], a_attrs={} ) [source] Navigation item without dropdown items. Parameters: label : str, default='' href : str, default='' template : str, default='directory/navitem.html' By default, this is a file stored in the directory of the current file. a_attrs : dict navitem_attrs : dict HTML attributes for the navitem div. hemlock.tools. DropdownitemList Methods convert ( cls, item ) [source] hemlock.tools. Navitemdd class hemlock.tools. Navitemdd ( label='', dropdownitems=[], template=os.path.join(DIR, 'navitemdd.html'), a_class=['nav-item', 'nav-link', 'dropdown', 'dropdown-toggle'], a_attrs={'role': 'button', 'data-toggle': 'dropdown', 'aria-haspopup': 'true', 'aria-expanded': 'false'}, navitem_attrs={'class': ['nav-item', 'dropdown']} ) [source] Navigation item with dropdown items. Parameters: label : str, default='' dropdownitems : list of hemlock.tools.Dropdownitem template : str, default='directory/navitemdd.html' By default, this is a file stored in the directory of the current file. a_attrs : dict navitem_attrs : dict HTML attributes for the navitem div. Methods render ( self ) [source] Returns: rendered : str hemlock.tools. Dropdownitem class hemlock.tools. Dropdownitem ( label='', href='', template=os.path.join(DIR, 'dropdownitem.html'), a_class=['dropdown-item'], a_attrs={} ) [source] Parameters: label : str, default='' href : str, default='' template : str, default='directory/dropdownitem.html' By default, this is a file stored in the directory of the current file. a_attrs : dict","title":"Navbar"},{"location":"tools/navbar/#navigation-bar","text":"","title":"Navigation bar"},{"location":"tools/navbar/#examples","text":"from hemlock import Page , push_app_context from hemlock.tools import Navbar , Navitem , Navitemdd , Dropdownitem app = push_app_context () url_root = 'https://dsbowen.github.io/' navbar = Navbar ( 'Hemlock' , [ ( 'Application' , href = url_root + 'app' ), ( 'Tools' , [ ( 'Language' , href = url_root + 'tools/lang' ), ( 'Navbar' , href = url_root + 'tools/navbar' ) ] ) ], href = url_root + 'hemlock' ) Page ( navbar = navbar . render ()) . preview ()","title":"Examples"},{"location":"tools/navbar/#hemlocktoolsnavbase","text":"class hemlock.tools. NavBase ( label, template, href='', a_class=[], a_attrs={} ) [source] All navigation models inherit from this base. Parameters and attributes: label : str Label for the navigation element. template : str Path to template file or string. This is not a Jinja template, as you may wish to generate html for statics outside the application context. href : str, default='' Hyperref to which the navigation element links. a_attrs : dict, default={} Dictionary of HTML attributes for the navigation element's <a> tag.","title":"hemlock.tools.NavBase"},{"location":"tools/navbar/#methods","text":"render ( self ) [source] Returns: rendered : str","title":"Methods"},{"location":"tools/navbar/#hemlocktoolsnavitemlist","text":"","title":"hemlock.tools.NavitemList"},{"location":"tools/navbar/#methods_1","text":"convert ( cls, item ) [source]","title":"Methods"},{"location":"tools/navbar/#hemlocktoolsnavbar","text":"class hemlock.tools. Navbar ( label='', navitems=[], href='#', template=os.path.join( DIR, 'navbar.html'), a_class=['navbar-brand'], a_attrs={}, navbar_attrs ={'class': ['navbar', 'navbar-expand-lg', 'navbar-light', 'bg-light', 'fixed-top']} ) [source] Parameters: label : str, default='' navitems : list of hemlock.tools.Navitem and hemlock.tools.Navitemdd Navigation items associated with the navbar. href : str, default='' template : str, default='directory/navbar.html' By default, this is a file stored in the directory of the current file. a_attrs : dict navbar_attrs : dict HTML attributes for the <nav> tag.","title":"hemlock.tools.Navbar"},{"location":"tools/navbar/#methods_2","text":"render ( self ) [source] Returns: rendered : str Rendered navbar HTML.","title":"Methods"},{"location":"tools/navbar/#hemlocktoolsnavitem","text":"class hemlock.tools. Navitem ( label='', href='', template=os.path.join(DIR, 'navitem.html'), a_class=['nav-item', 'nav-link'], a_attrs={} ) [source] Navigation item without dropdown items. Parameters: label : str, default='' href : str, default='' template : str, default='directory/navitem.html' By default, this is a file stored in the directory of the current file. a_attrs : dict navitem_attrs : dict HTML attributes for the navitem div.","title":"hemlock.tools.Navitem"},{"location":"tools/navbar/#hemlocktoolsdropdownitemlist","text":"","title":"hemlock.tools.DropdownitemList"},{"location":"tools/navbar/#methods_3","text":"convert ( cls, item ) [source]","title":"Methods"},{"location":"tools/navbar/#hemlocktoolsnavitemdd","text":"class hemlock.tools. Navitemdd ( label='', dropdownitems=[], template=os.path.join(DIR, 'navitemdd.html'), a_class=['nav-item', 'nav-link', 'dropdown', 'dropdown-toggle'], a_attrs={'role': 'button', 'data-toggle': 'dropdown', 'aria-haspopup': 'true', 'aria-expanded': 'false'}, navitem_attrs={'class': ['nav-item', 'dropdown']} ) [source] Navigation item with dropdown items. Parameters: label : str, default='' dropdownitems : list of hemlock.tools.Dropdownitem template : str, default='directory/navitemdd.html' By default, this is a file stored in the directory of the current file. a_attrs : dict navitem_attrs : dict HTML attributes for the navitem div.","title":"hemlock.tools.Navitemdd"},{"location":"tools/navbar/#methods_4","text":"render ( self ) [source] Returns: rendered : str","title":"Methods"},{"location":"tools/navbar/#hemlocktoolsdropdownitem","text":"class hemlock.tools. Dropdownitem ( label='', href='', template=os.path.join(DIR, 'dropdownitem.html'), a_class=['dropdown-item'], a_attrs={} ) [source] Parameters: label : str, default='' href : str, default='' template : str, default='directory/dropdownitem.html' By default, this is a file stored in the directory of the current file. a_attrs : dict","title":"hemlock.tools.Dropdownitem"},{"location":"tools/progress/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } hemlock.tools. progress def hemlock.tools. progress ( width, text=None, progress_attrs={'class': ['progress', 'position-relative'], 'style': {'height': '25px', 'background-color': 'rgb(200,200,200)', 'box-shadow': '0 1px 2px rgba(0,0,0,0.25) inset'}}, bar_attrs={'class': ['progress-bar'], 'role': 'progressbar'}, text_attrs={'class': ['justify-content-center', 'd-flex', 'position-absolute', 'w-100', 'align-items-center']} ) [source] Creates a progress bar. Parameters: width : float between 0 and 1 Percent complete. text : str, default=None Progress text report. If None , the text will be the percent complete. additional parameters : Additional parameters specify attributes for the progress bar containers. Returns: progress bar HTML : str Examples from hemlock import Page , Label , push_app_context from hemlock.tools import progress app = push_app_context () Page ( Label ( progress ( 0.5 , \"Halfway there!\" ) ) ) . preview ()","title":"Progress bar"},{"location":"tools/progress/#hemlocktoolsprogress","text":"def hemlock.tools. progress ( width, text=None, progress_attrs={'class': ['progress', 'position-relative'], 'style': {'height': '25px', 'background-color': 'rgb(200,200,200)', 'box-shadow': '0 1px 2px rgba(0,0,0,0.25) inset'}}, bar_attrs={'class': ['progress-bar'], 'role': 'progressbar'}, text_attrs={'class': ['justify-content-center', 'd-flex', 'position-absolute', 'w-100', 'align-items-center']} ) [source] Creates a progress bar. Parameters: width : float between 0 and 1 Percent complete. text : str, default=None Progress text report. If None , the text will be the percent complete. additional parameters : Additional parameters specify attributes for the progress bar containers. Returns: progress bar HTML : str","title":"hemlock.tools.progress"},{"location":"tools/progress/#examples","text":"from hemlock import Page , Label , push_app_context from hemlock.tools import progress app = push_app_context () Page ( Label ( progress ( 0.5 , \"Halfway there!\" ) ) ) . preview ()","title":"Examples"},{"location":"tools/random/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Randomization tools hemlock.tools. key def hemlock.tools. key ( len_=90 ) [source] Parameters: len_ : int, default=90 Length of the key to generate. Returns: key : str Randomly generated key of ascii letters and digits of specificed length. Notes The first character is a letter. This allows you to use key to generate strongly random id's for html elements. (Html element id's cannot start with a digit.) Examples from hemlock import tools tools . key ( 10 ) Out: gpGmZuRfF7 hemlock.tools. reset_random_seed def hemlock.tools. reset_random_seed ( ) [source] hemlock.tools. Randomizer class hemlock.tools. Randomizer ( elements, r=1, combination=True ) [source] Evenly randomizes over a set of elements. Parameters: elements : iterable Set of elements over which to randomize. r : int, default=1 Size of the subset of elements to select. combination : bool, default=True Indicates randomization over combinations of the elements, as opposed to permutations. Attributes: elements : iterable Set from the elements parameter. Examples from hemlock.tools import Randomizer elements = ( 'world' , 'moon' , 'star' ) randomizer = Randomizer ( elements , r = 2 , combination = False ) randomizer . next () Out: ('moon', 'world') Methods next ( self ) [source] Returns: subset : Selected subset of elements. hemlock.tools. Assigner class hemlock.tools. Assigner ( conditions ) [source] Evenly assigns participants to conditions. Inherits from hemlock.tools.Randomizer . Parameters: conditions : dict Maps condition variable name to iterable of possible assignments. Attributes: keys : iterable Condition variable names. elements : iterable All possible combinations of condition values to which a participant may be assigned. Examples from hemlock import Participant , push_app_context from hemlock.tools import Assigner push_app_context () part = Participant . gen_test_participant () conditions = { 'Treatment' : ( 0 , 1 ), 'Level' : ( 'low' , 'med' , 'high' )} assigner = Assigner ( conditions ) assigner . next () Out: {'Treatment': 1, 'Level': 'low'} In: part . meta Out: [('Treatment', 0), ('Level', 'low')] Methods next ( self, participant=None ) [source] Assigns the participant to a condition. The condition assigment updates the participant's metadata. Parameters: participant : hemlock.Participant or None, default=None This method records the assignment in this participant's meta dictionary. If None , the participant is the current user. Returns: assignment : dict Maps condition variable names to assigned conditions. Notes By default, this method assigns the participant using flask-login's current_user . If you're assigning the participant in function handled by Redis, this won't work. You'll need to manually pass in the participant.","title":"Randomization"},{"location":"tools/random/#randomization-tools","text":"","title":"Randomization tools"},{"location":"tools/random/#hemlocktoolskey","text":"def hemlock.tools. key ( len_=90 ) [source] Parameters: len_ : int, default=90 Length of the key to generate. Returns: key : str Randomly generated key of ascii letters and digits of specificed length.","title":"hemlock.tools.key"},{"location":"tools/random/#notes","text":"The first character is a letter. This allows you to use key to generate strongly random id's for html elements. (Html element id's cannot start with a digit.)","title":"Notes"},{"location":"tools/random/#examples","text":"from hemlock import tools tools . key ( 10 ) Out: gpGmZuRfF7","title":"Examples"},{"location":"tools/random/#hemlocktoolsreset_random_seed","text":"def hemlock.tools. reset_random_seed ( ) [source]","title":"hemlock.tools.reset_random_seed"},{"location":"tools/random/#hemlocktoolsrandomizer","text":"class hemlock.tools. Randomizer ( elements, r=1, combination=True ) [source] Evenly randomizes over a set of elements. Parameters: elements : iterable Set of elements over which to randomize. r : int, default=1 Size of the subset of elements to select. combination : bool, default=True Indicates randomization over combinations of the elements, as opposed to permutations. Attributes: elements : iterable Set from the elements parameter.","title":"hemlock.tools.Randomizer"},{"location":"tools/random/#examples_1","text":"from hemlock.tools import Randomizer elements = ( 'world' , 'moon' , 'star' ) randomizer = Randomizer ( elements , r = 2 , combination = False ) randomizer . next () Out: ('moon', 'world')","title":"Examples"},{"location":"tools/random/#methods","text":"next ( self ) [source] Returns: subset : Selected subset of elements.","title":"Methods"},{"location":"tools/random/#hemlocktoolsassigner","text":"class hemlock.tools. Assigner ( conditions ) [source] Evenly assigns participants to conditions. Inherits from hemlock.tools.Randomizer . Parameters: conditions : dict Maps condition variable name to iterable of possible assignments. Attributes: keys : iterable Condition variable names. elements : iterable All possible combinations of condition values to which a participant may be assigned.","title":"hemlock.tools.Assigner"},{"location":"tools/random/#examples_2","text":"from hemlock import Participant , push_app_context from hemlock.tools import Assigner push_app_context () part = Participant . gen_test_participant () conditions = { 'Treatment' : ( 0 , 1 ), 'Level' : ( 'low' , 'med' , 'high' )} assigner = Assigner ( conditions ) assigner . next () Out: {'Treatment': 1, 'Level': 'low'} In: part . meta Out: [('Treatment', 0), ('Level', 'low')]","title":"Examples"},{"location":"tools/random/#methods_1","text":"next ( self, participant=None ) [source] Assigns the participant to a condition. The condition assigment updates the participant's metadata. Parameters: participant : hemlock.Participant or None, default=None This method records the assignment in this participant's meta dictionary. If None , the participant is the current user. Returns: assignment : dict Maps condition variable names to assigned conditions.","title":"Methods"},{"location":"tools/random/#notes_1","text":"By default, this method assigns the participant using flask-login's current_user . If you're assigning the participant in function handled by Redis, this won't work. You'll need to manually pass in the participant.","title":"Notes"},{"location":"tools/statics/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Statics Tool for embedding statics: css javascript images iframes YouTube videos links to Google bucket files hemlock.tools. format_attrs def hemlock.tools. format_attrs ( **attrs ) [source] Parameters: **attrs : dict Maps HTML attribute name to value. Returns: attrs : str Formated attributes for insertion into HTML tag. hemlock.tools. external_css def hemlock.tools. external_css ( href, rel='stylesheet', type='text/css', **attrs ) [source] Parameters: **attrs : Attribute names and values in the <link/> tag. Returns: css : str <link/> tag. Examples from hemlock import Page , push_app_context from hemlock.tools import external_css app = push_app_context () p = Page ( extra_css = external_css ( href = 'https://my-css-url' )) p . css Out: ... <link href=\"https://my-css-url\" rel=\"stylesheet\" type=\"text/css\"/> hemlock.tools. internal_css def hemlock.tools. internal_css ( style ) [source] Parameters: style : dict Maps css selector to an attributes dictionary. The attributes dictionary maps attribute names to values. Returns: css : str <style> tag. Examples from hemlock import Page , push_app_context from hemlock.tools import internal_css app = push_app_context () p = Page ( extra_css = internal_css ({ 'body' : { 'background' : 'coral' }})) p . css Out: ... <style> body {background:coral;} </style> hemlock.tools. external_js def hemlock.tools. external_js ( src, **attrs ) [source] Parameters: src : str External javascript source. **attrs : Attribute names and values in the <script> tag. Returns: js : str <script> tag. Examples from hemlock import Page , push_app_context from hemlock.tools import external_js app = push_app_context () p = Page ( extra_js = external_js ( src = 'https://my-js-url' )) p . js Out: ... <script src=\"https://my-js-url\"></script> hemlock.tools. internal_js def hemlock.tools. internal_js ( js, **attrs ) [source] Parameters: js : str Javascript code. **attrs : dict Mapping of HTML attributes to values for the <script> tag. Returns: js : str Javascript code wrapped in <script> tag. Examples from hemlock import Page , push_app_context from hemlock.tools import internal_js app = push_app_context () p = Page ( extra_js = internal_js ( ''' $( document ).ready(function() { alert('hello, world!'); }); ''' ) ) p . js Out: ... <script> $( document ).ready(function() { alert('hello, world!'); }); </script> hemlock.tools. src_from_bucket def hemlock.tools. src_from_bucket ( filename ) [source] Parameters: filename : str Name of the file in the Google bucket. Returns: src : str src html attribute which references the specified file in the Google bucket. Examples Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket. $ export BUCKET=<my-bucket> Upload a file to the bucket, e.g. https://xkcd.com/2138/ and name it wanna_see_the_code.png . from hemlock import Branch , Page , Label , push_app_context from hemlock.tools import Img , src_from_bucket app = push_app_context () img = Img ( src = src_from_bucket ( 'wanna_see_the_code.png' ), align = 'center' ) . render () Page ( Label ( img )) . preview () hemlock.tools. url_from_bucket def hemlock.tools. url_from_bucket ( filename, expiration=1800, **kwargs ) [source] Parameters: filename : str Name of the file in the Google bucket. expiration : float, default=1800 Number of seconds until the url expires. **kwargs : Keyword arguments are passed to the [ generate_signed_url method] (https://cloud.google.com/storage/docs/access-control/signed-urls). Returns: signed_url : str Signed url for the file in the app's bucket. Examples Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket, and GOOGLE_APPLICATION_CREDENTIALS to the name of your Google application credentials JSON file . $ export BUCKET=<my-bucket> GOOGLE_APPLICATION_CREDENTIALS=<my-credentials.json> In survey.py : from hemlock import Branch , Page , Download , route from hemlock.tools import url_from_bucket @route ( '/survey' ) def start (): filename = 'wanna_see_the_code.png' url = url_from_bucket ( filename ) return Branch ( Page ( Download ( downloads = [( url , filename )]))) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app locally with: $ python app.py # or python3 app.py And open your browser to http://localhost:5000/ . Click on the download button to download the file from your Google bucket. hemlock.tools. img def hemlock.tools. img ( src, caption='', img_align='left', caption_align='left', figure_class='figure w-100', figure_attrs={}, img_class= 'figure-img img-fluid rounded', img_attrs={}, caption_class= 'figure-caption', caption_attrs={}, template=os.path.join(DIR, 'img.html') ) [source] Parameters: src : str Image source. caption : str img_align : str, default='left' caption_align : str, default='left' figure_class : list or str, default='figure w-100' Class for the <figure> tag. figure_attrs : dict, default={} HTML attributes for the <figure> tag. img_class : list or str, default='figure-img img-fluid rounded' Class for the <img> tag. img_attrs : dict, default={} HTML attributes for the <img> tag. caption_class : list or str, default='figure-caption' Class for the <figcaption> tag. caption_attrs : dict, default={} HTML attributes for the <figcaption> tag. template : str, default='directory/img.html' Path to image template. Default is a template in the same directory as the current file. This may also be a string to be used directly as the template. Returns: img : str Image html. Examples from hemlock.tools import img img ( 'https://imgs.xkcd.com/comics/wanna_see_the_code.png' , img_align = 'center' , caption = 'Wanna See The Code?' ) Out: <figure class=\"figure w-100 text-center\"> <img class=\"figure-img img-fluid rounded\" src=\"https://imgs.xkcd.com/comics/wanna_see_the_code.png\"> <figcaption class=\"figure-caption text-left\">Wanna See The Code?</figcaption> </figure> hemlock.tools. iframe def hemlock.tools. iframe ( src, aspect_ratio=(16, 9), query_string={}, div_class= 'embed-responsive', div_attrs={}, iframe_class='embed-responsive-item', iframe_attrs={'allowfullscreen': True}, template=os.path.join(DIR, 'iframe.html') ) [source] Parameters: src : str Embed source. aspect_ratio : tuple of (int, int), default=(16, 9) Embed aspect ratio . query_string : dict Mapping of URL query keys to values. div_class : str or list, default='embed-responsive' Class of the <div> which wraps the <iframe> . div_attrs : dict, default={} HTML attributes for the <div> wrapper. iframe_class : str or list, default='embed-responsive-item' Class of the <iframe> tag. iframe_attrs : HTML attributes for the <iframe> tag. template : str, default='directory/iframe.html' Path to iframe template. Default is a template in the same directory as the current file. This may also be a string to be used directly as the template. Returns: iframe : str Iframe HTML. Examples from hemlock.tools import iframe iframe ( 'https://www.youtube.com/embed/zpOULjyy-n8?rel=0' , aspect_ratio = ( 21 , 9 ) ) Out: <div class=\"embed-responsive embed-responsive-21by9\"> <iframe allowfullscreen class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/zpOULjyy-n8?rel=0\"></iframe> </div> hemlock.tools. youtube def hemlock.tools. youtube ( src, iframe_attrs={'allow': 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture;', 'allowfullscreen': True}, *args, **kwargs ) [source] Embed a youtube video. Parameters: src : str Link to youtube video. e.g. https://www.youtube.com/watch?v=ts3s738ZkcQ . iframe_attrs : dict HTML attributes for the <iframe> tag. *args, **kwarg : Arguments and keyword arguments are passed to hemlock.tools.iframe . Returns: iframe : str Iframe HTML. Examples from hemlock.tools import youtube youtube ( 'https://www.youtube.com/watch?v=ts3s738ZkcQ' , query_string = { 'autoplay' : 1 } ) Out: <div class=\"embed-responsive embed-responsive-16by9\"> <iframe allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture;\" allowfullscreen class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/ts3s738ZkcQ?autoplay=1\"></iframe> </div>","title":"Statics"},{"location":"tools/statics/#statics","text":"Tool for embedding statics: css javascript images iframes YouTube videos links to Google bucket files","title":"Statics"},{"location":"tools/statics/#hemlocktoolsformat_attrs","text":"def hemlock.tools. format_attrs ( **attrs ) [source] Parameters: **attrs : dict Maps HTML attribute name to value. Returns: attrs : str Formated attributes for insertion into HTML tag.","title":"hemlock.tools.format_attrs"},{"location":"tools/statics/#hemlocktoolsexternal_css","text":"def hemlock.tools. external_css ( href, rel='stylesheet', type='text/css', **attrs ) [source] Parameters: **attrs : Attribute names and values in the <link/> tag. Returns: css : str <link/> tag.","title":"hemlock.tools.external_css"},{"location":"tools/statics/#examples","text":"from hemlock import Page , push_app_context from hemlock.tools import external_css app = push_app_context () p = Page ( extra_css = external_css ( href = 'https://my-css-url' )) p . css Out: ... <link href=\"https://my-css-url\" rel=\"stylesheet\" type=\"text/css\"/>","title":"Examples"},{"location":"tools/statics/#hemlocktoolsinternal_css","text":"def hemlock.tools. internal_css ( style ) [source] Parameters: style : dict Maps css selector to an attributes dictionary. The attributes dictionary maps attribute names to values. Returns: css : str <style> tag.","title":"hemlock.tools.internal_css"},{"location":"tools/statics/#examples_1","text":"from hemlock import Page , push_app_context from hemlock.tools import internal_css app = push_app_context () p = Page ( extra_css = internal_css ({ 'body' : { 'background' : 'coral' }})) p . css Out: ... <style> body {background:coral;} </style>","title":"Examples"},{"location":"tools/statics/#hemlocktoolsexternal_js","text":"def hemlock.tools. external_js ( src, **attrs ) [source] Parameters: src : str External javascript source. **attrs : Attribute names and values in the <script> tag. Returns: js : str <script> tag.","title":"hemlock.tools.external_js"},{"location":"tools/statics/#examples_2","text":"from hemlock import Page , push_app_context from hemlock.tools import external_js app = push_app_context () p = Page ( extra_js = external_js ( src = 'https://my-js-url' )) p . js Out: ... <script src=\"https://my-js-url\"></script>","title":"Examples"},{"location":"tools/statics/#hemlocktoolsinternal_js","text":"def hemlock.tools. internal_js ( js, **attrs ) [source] Parameters: js : str Javascript code. **attrs : dict Mapping of HTML attributes to values for the <script> tag. Returns: js : str Javascript code wrapped in <script> tag.","title":"hemlock.tools.internal_js"},{"location":"tools/statics/#examples_3","text":"from hemlock import Page , push_app_context from hemlock.tools import internal_js app = push_app_context () p = Page ( extra_js = internal_js ( ''' $( document ).ready(function() { alert('hello, world!'); }); ''' ) ) p . js Out: ... <script> $( document ).ready(function() { alert('hello, world!'); }); </script>","title":"Examples"},{"location":"tools/statics/#hemlocktoolssrc_from_bucket","text":"def hemlock.tools. src_from_bucket ( filename ) [source] Parameters: filename : str Name of the file in the Google bucket. Returns: src : str src html attribute which references the specified file in the Google bucket.","title":"hemlock.tools.src_from_bucket"},{"location":"tools/statics/#examples_4","text":"Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket. $ export BUCKET=<my-bucket> Upload a file to the bucket, e.g. https://xkcd.com/2138/ and name it wanna_see_the_code.png . from hemlock import Branch , Page , Label , push_app_context from hemlock.tools import Img , src_from_bucket app = push_app_context () img = Img ( src = src_from_bucket ( 'wanna_see_the_code.png' ), align = 'center' ) . render () Page ( Label ( img )) . preview ()","title":"Examples"},{"location":"tools/statics/#hemlocktoolsurl_from_bucket","text":"def hemlock.tools. url_from_bucket ( filename, expiration=1800, **kwargs ) [source] Parameters: filename : str Name of the file in the Google bucket. expiration : float, default=1800 Number of seconds until the url expires. **kwargs : Keyword arguments are passed to the [ generate_signed_url method] (https://cloud.google.com/storage/docs/access-control/signed-urls). Returns: signed_url : str Signed url for the file in the app's bucket.","title":"hemlock.tools.url_from_bucket"},{"location":"tools/statics/#examples_5","text":"Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket, and GOOGLE_APPLICATION_CREDENTIALS to the name of your Google application credentials JSON file . $ export BUCKET=<my-bucket> GOOGLE_APPLICATION_CREDENTIALS=<my-credentials.json> In survey.py : from hemlock import Branch , Page , Download , route from hemlock.tools import url_from_bucket @route ( '/survey' ) def start (): filename = 'wanna_see_the_code.png' url = url_from_bucket ( filename ) return Branch ( Page ( Download ( downloads = [( url , filename )]))) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app locally with: $ python app.py # or python3 app.py And open your browser to http://localhost:5000/ . Click on the download button to download the file from your Google bucket.","title":"Examples"},{"location":"tools/statics/#hemlocktoolsimg","text":"def hemlock.tools. img ( src, caption='', img_align='left', caption_align='left', figure_class='figure w-100', figure_attrs={}, img_class= 'figure-img img-fluid rounded', img_attrs={}, caption_class= 'figure-caption', caption_attrs={}, template=os.path.join(DIR, 'img.html') ) [source] Parameters: src : str Image source. caption : str img_align : str, default='left' caption_align : str, default='left' figure_class : list or str, default='figure w-100' Class for the <figure> tag. figure_attrs : dict, default={} HTML attributes for the <figure> tag. img_class : list or str, default='figure-img img-fluid rounded' Class for the <img> tag. img_attrs : dict, default={} HTML attributes for the <img> tag. caption_class : list or str, default='figure-caption' Class for the <figcaption> tag. caption_attrs : dict, default={} HTML attributes for the <figcaption> tag. template : str, default='directory/img.html' Path to image template. Default is a template in the same directory as the current file. This may also be a string to be used directly as the template. Returns: img : str Image html.","title":"hemlock.tools.img"},{"location":"tools/statics/#examples_6","text":"from hemlock.tools import img img ( 'https://imgs.xkcd.com/comics/wanna_see_the_code.png' , img_align = 'center' , caption = 'Wanna See The Code?' ) Out: <figure class=\"figure w-100 text-center\"> <img class=\"figure-img img-fluid rounded\" src=\"https://imgs.xkcd.com/comics/wanna_see_the_code.png\"> <figcaption class=\"figure-caption text-left\">Wanna See The Code?</figcaption> </figure>","title":"Examples"},{"location":"tools/statics/#hemlocktoolsiframe","text":"def hemlock.tools. iframe ( src, aspect_ratio=(16, 9), query_string={}, div_class= 'embed-responsive', div_attrs={}, iframe_class='embed-responsive-item', iframe_attrs={'allowfullscreen': True}, template=os.path.join(DIR, 'iframe.html') ) [source] Parameters: src : str Embed source. aspect_ratio : tuple of (int, int), default=(16, 9) Embed aspect ratio . query_string : dict Mapping of URL query keys to values. div_class : str or list, default='embed-responsive' Class of the <div> which wraps the <iframe> . div_attrs : dict, default={} HTML attributes for the <div> wrapper. iframe_class : str or list, default='embed-responsive-item' Class of the <iframe> tag. iframe_attrs : HTML attributes for the <iframe> tag. template : str, default='directory/iframe.html' Path to iframe template. Default is a template in the same directory as the current file. This may also be a string to be used directly as the template. Returns: iframe : str Iframe HTML.","title":"hemlock.tools.iframe"},{"location":"tools/statics/#examples_7","text":"from hemlock.tools import iframe iframe ( 'https://www.youtube.com/embed/zpOULjyy-n8?rel=0' , aspect_ratio = ( 21 , 9 ) ) Out: <div class=\"embed-responsive embed-responsive-21by9\"> <iframe allowfullscreen class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/zpOULjyy-n8?rel=0\"></iframe> </div>","title":"Examples"},{"location":"tools/statics/#hemlocktoolsyoutube","text":"def hemlock.tools. youtube ( src, iframe_attrs={'allow': 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture;', 'allowfullscreen': True}, *args, **kwargs ) [source] Embed a youtube video. Parameters: src : str Link to youtube video. e.g. https://www.youtube.com/watch?v=ts3s738ZkcQ . iframe_attrs : dict HTML attributes for the <iframe> tag. *args, **kwarg : Arguments and keyword arguments are passed to hemlock.tools.iframe . Returns: iframe : str Iframe HTML.","title":"hemlock.tools.youtube"},{"location":"tools/statics/#examples_8","text":"from hemlock.tools import youtube youtube ( 'https://www.youtube.com/watch?v=ts3s738ZkcQ' , query_string = { 'autoplay' : 1 } ) Out: <div class=\"embed-responsive embed-responsive-16by9\"> <iframe allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture;\" allowfullscreen class=\"embed-responsive-item\" src=\"https://www.youtube.com/embed/ts3s738ZkcQ?autoplay=1\"></iframe> </div>","title":"Examples"},{"location":"tools/titrate/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Titration tool Titration is used primarily to elicit willingness to pay or risk preferences. hemlock.tools. titrate def hemlock.tools. titrate ( gen_titrate_q, distribution, var, data_rows=1, tol=None, max_pages=None, **kwargs ) [source] Parameters: gen_titrate_q : callable Callable which takes the titration value and returns a hemlock.Question . If the question's data evaluates to True , the next iteration will increase the titration value. If the question's data evaluates to False , the next iteration will decrease the titration value. distribution : callable Callable with a ppf method which takes a quantile q and returns a value (e.g. float ). I recommend scipy.stats distributions. var : str Name of the variable in which to store the titrated value. data_rows : int, default=1 Number of data rows for the titration variable. tol : float or None, default=None Titration will stop when the titrated value reaches this precision. If None , titration stops after a certain number of questions. max_pages : int or None, default=None Titration will stop after this number of pages. If None , titration stops after a precision level is reached. **kwargs : Keyword arguments are passed to the titration page constructor. Returns: FIrst titration page : hemlock.Page Examples This example demonstrates how to use titration to more efficiently and precisely implement the Holt-Laury risk elicitation method . The titration value is the probability at which the participant is indifferent between two lotteries. We then compute the coefficient of relative risk aversion assuming CRRA utility. import numpy as np from hemlock import Branch , Page , Binary , Label , Validate as V , route from hemlock.tools import titrate from scipy.optimize import minimize from scipy.stats import uniform import math def gen_titrate_q ( p_larger ): # p_larger is the probability of winning the larger amount of money p = round ( p_larger ) return Binary ( ''' Which lottery would you rather have? ''' , [ ' {} /100 of $2.00, {} /100 of $1.60' . format ( p , 100 - p ), ' {} /100 of $3.85, {} /100 of $0.10' . format ( p , 100 - p ) ], inline = False , validate = V . require () ) @route ( '/survey' ) def start (): return Branch ( titrate ( gen_titrate_q , uniform ( 0 , 100 ), var = 'p' , tol = 5 , back = True ), Page ( Label ( compile = disp_risk_aversion ), back = True , terminal = True , ) ) def disp_risk_aversion ( label ): def func ( r ): def u ( x ): # CRRA utility function return x ** ( 1 - r ) if abs ( 1 - r ) > . 01 else math . log ( x ) return ( p * u ( 2 ) + ( 1 - p ) * u ( 1.6 ) - p * u ( 3.85 ) - ( 1 - p ) * u ( . 1 )) ** 2 p = label . part . g [ 'p' ] / 100. # indifference point between 0 and 1 # coefficient of relative risk aversion if optimization starts from -3 res_lower = minimize ( func , x0 = np . array ([ - 3 ])) . x # coefficient of relative risk aversion if optimization starts from 2 res_upper = minimize ( func , x0 = np . array ([ 2 ])) . x # you can trivially minimize the function by setting r == 1 (approximately) # this sets u(x) = 0 (approx.) for all x # so choose the r farther from 1 r = res_lower if abs ( res_lower - 1 ) > abs ( res_upper - 1 ) else res_upper label . label = ''' Indifference point is {:.0f} /100. Coefficient of relative risk aversion is {:.2f} ''' . format ( 100. * p , float ( r ))","title":"Titrate"},{"location":"tools/titrate/#titration-tool","text":"Titration is used primarily to elicit willingness to pay or risk preferences.","title":"Titration tool"},{"location":"tools/titrate/#hemlocktoolstitrate","text":"def hemlock.tools. titrate ( gen_titrate_q, distribution, var, data_rows=1, tol=None, max_pages=None, **kwargs ) [source] Parameters: gen_titrate_q : callable Callable which takes the titration value and returns a hemlock.Question . If the question's data evaluates to True , the next iteration will increase the titration value. If the question's data evaluates to False , the next iteration will decrease the titration value. distribution : callable Callable with a ppf method which takes a quantile q and returns a value (e.g. float ). I recommend scipy.stats distributions. var : str Name of the variable in which to store the titrated value. data_rows : int, default=1 Number of data rows for the titration variable. tol : float or None, default=None Titration will stop when the titrated value reaches this precision. If None , titration stops after a certain number of questions. max_pages : int or None, default=None Titration will stop after this number of pages. If None , titration stops after a precision level is reached. **kwargs : Keyword arguments are passed to the titration page constructor. Returns: FIrst titration page : hemlock.Page","title":"hemlock.tools.titrate"},{"location":"tools/titrate/#examples","text":"This example demonstrates how to use titration to more efficiently and precisely implement the Holt-Laury risk elicitation method . The titration value is the probability at which the participant is indifferent between two lotteries. We then compute the coefficient of relative risk aversion assuming CRRA utility. import numpy as np from hemlock import Branch , Page , Binary , Label , Validate as V , route from hemlock.tools import titrate from scipy.optimize import minimize from scipy.stats import uniform import math def gen_titrate_q ( p_larger ): # p_larger is the probability of winning the larger amount of money p = round ( p_larger ) return Binary ( ''' Which lottery would you rather have? ''' , [ ' {} /100 of $2.00, {} /100 of $1.60' . format ( p , 100 - p ), ' {} /100 of $3.85, {} /100 of $0.10' . format ( p , 100 - p ) ], inline = False , validate = V . require () ) @route ( '/survey' ) def start (): return Branch ( titrate ( gen_titrate_q , uniform ( 0 , 100 ), var = 'p' , tol = 5 , back = True ), Page ( Label ( compile = disp_risk_aversion ), back = True , terminal = True , ) ) def disp_risk_aversion ( label ): def func ( r ): def u ( x ): # CRRA utility function return x ** ( 1 - r ) if abs ( 1 - r ) > . 01 else math . log ( x ) return ( p * u ( 2 ) + ( 1 - p ) * u ( 1.6 ) - p * u ( 3.85 ) - ( 1 - p ) * u ( . 1 )) ** 2 p = label . part . g [ 'p' ] / 100. # indifference point between 0 and 1 # coefficient of relative risk aversion if optimization starts from -3 res_lower = minimize ( func , x0 = np . array ([ - 3 ])) . x # coefficient of relative risk aversion if optimization starts from 2 res_upper = minimize ( func , x0 = np . array ([ 2 ])) . x # you can trivially minimize the function by setting r == 1 (approximately) # this sets u(x) = 0 (approx.) for all x # so choose the r farther from 1 r = res_lower if abs ( res_lower - 1 ) > abs ( res_upper - 1 ) else res_upper label . label = ''' Indifference point is {:.0f} /100. Coefficient of relative risk aversion is {:.2f} ''' . format ( 100. * p , float ( r ))","title":"Examples"},{"location":"tools/utils/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Utilities hemlock.tools. chromedriver def hemlock.tools. chromedriver ( headless=False ) [source] Parameters: headless : bool, default=False Indicates whether to run Chrome in headless mode. Returns: driver : selenium.webdriver.chrome.webdriver.WebDriver Notes Chromedriver must be headless in production. When the application is in production, this method sets headless to True regardless of the parameter you pass. Examples from hemlock.tools import chromedriver driver = chromedriver () hemlock.tools. get_data def hemlock.tools. get_data ( dataframe='data' ) [source] Parameters: dataframe : str, default='data' Name of the dataframe to get; 'data' or 'meta' . Returns: data : dict Maps variable names to list of entries. May not include data from participants who are in progress. Examples from hemlock import Branch , Page , Participant , push_app_context from hemlock.tools import get_data def start (): return Branch ( Page ()) push_app_context () Participant . gen_test_participant ( start ) . completed = True get_data () Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 6, 17, 11, 0, 245032)], 'StartTime': [datetime.datetime(2020, 7, 6, 17, 11, 0, 245032)], 'Status': ['Completed']} hemlock.tools. make_list def hemlock.tools. make_list ( items, ordered=False ) [source] Parameters: items : list Returns: HTML list : str HTML-formatted list. hemlock.tools. make_table def hemlock.tools. make_table ( table, extra_classes=[] ) [source] Parameters: table : dict Maps column names to a list of entries. Returns: table : str Table in HTML format. Examples from hemlock.tools import html_table html_table ({ 'Column 0' : [ 'hello' , 'world' ], 'Column 1' : [ 'goodbye' , 'moon' ] }) Out: <table class=\"table\"> <thead> <tr> <th scope=\"col\">Column 0</th> <th scope=\"col\">Column 1</th> </tr> </thead> <tbody> <tr> <td>hello</td> <td>goodbye</td></tr> <tr> <td>world</td> <td>moon</td></tr> </tbody> </table> hemlock.tools. show_on_event def hemlock.tools. show_on_event ( target, condition, value, init_hidden=True, *args, **kwargs ) [source] Show the target question when a condition is met. Parameters: target : hemlock.Question The question which will be shown when the condition is met. condition : hemlock.Question The question whose value determines whether the target is shown. value : str or hemlock.Choice > If the condition is an input, the target is shown when the input value matches this value. 2. If the condition has choices, the target is shown when the choice with this value is checked. < init_hidden : bool, defualt=True Indicates that the initial state of the target should be hidden. regex : bool, default=False Indicates that the target will be shown if input value matches the string as a regular expression. event : str or None, default=None Type of event which toggles the target display. If None , this function infers the type of event based on inputs. duration : str or int, default=400 Show/hide event duration in milliseconds. Examples from hemlock import Page , Check , Input , Label , push_app_context from hemlock.tools import show_on_event app = push_app_context () race = Check ( '<p>Indicate your race.</p>' , [ 'White' , 'Black' , 'Other' ], multiple = True ) specify = Input ( '<p>Please specify.</p>' ) show_on_event ( specify , race , 'Other' ) Page ( race , specify ) . preview () name = Input ( \"<p>What's your name?</p>\" ) greet = Label ( \"Hello, World!\" ) show_on_event ( greet , name , '(w|W)orld' , regex = True , duration = 400 ) Page ( name , greet ) . preview () hemlock.tools. url_for def hemlock.tools. url_for ( *args, **kwargs ) [source] Attempt to return flask.url_for(*args, **kwargs) . However, this method does not exit the program when getting a url outside a request context; e.g. when debugging in a shell or notebook. Parameters: *args, **kwargs : Arguments and keyword arguments will be passed to flask.url_for . Returns: url : str Output of flask.url_for if possible; otherwise 'URL_UNAVAILABLE' .","title":"Utilities"},{"location":"tools/utils/#utilities","text":"","title":"Utilities"},{"location":"tools/utils/#hemlocktoolschromedriver","text":"def hemlock.tools. chromedriver ( headless=False ) [source] Parameters: headless : bool, default=False Indicates whether to run Chrome in headless mode. Returns: driver : selenium.webdriver.chrome.webdriver.WebDriver","title":"hemlock.tools.chromedriver"},{"location":"tools/utils/#notes","text":"Chromedriver must be headless in production. When the application is in production, this method sets headless to True regardless of the parameter you pass.","title":"Notes"},{"location":"tools/utils/#examples","text":"from hemlock.tools import chromedriver driver = chromedriver ()","title":"Examples"},{"location":"tools/utils/#hemlocktoolsget_data","text":"def hemlock.tools. get_data ( dataframe='data' ) [source] Parameters: dataframe : str, default='data' Name of the dataframe to get; 'data' or 'meta' . Returns: data : dict Maps variable names to list of entries. May not include data from participants who are in progress.","title":"hemlock.tools.get_data"},{"location":"tools/utils/#examples_1","text":"from hemlock import Branch , Page , Participant , push_app_context from hemlock.tools import get_data def start (): return Branch ( Page ()) push_app_context () Participant . gen_test_participant ( start ) . completed = True get_data () Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 6, 17, 11, 0, 245032)], 'StartTime': [datetime.datetime(2020, 7, 6, 17, 11, 0, 245032)], 'Status': ['Completed']}","title":"Examples"},{"location":"tools/utils/#hemlocktoolsmake_list","text":"def hemlock.tools. make_list ( items, ordered=False ) [source] Parameters: items : list Returns: HTML list : str HTML-formatted list.","title":"hemlock.tools.make_list"},{"location":"tools/utils/#hemlocktoolsmake_table","text":"def hemlock.tools. make_table ( table, extra_classes=[] ) [source] Parameters: table : dict Maps column names to a list of entries. Returns: table : str Table in HTML format.","title":"hemlock.tools.make_table"},{"location":"tools/utils/#examples_2","text":"from hemlock.tools import html_table html_table ({ 'Column 0' : [ 'hello' , 'world' ], 'Column 1' : [ 'goodbye' , 'moon' ] }) Out: <table class=\"table\"> <thead> <tr> <th scope=\"col\">Column 0</th> <th scope=\"col\">Column 1</th> </tr> </thead> <tbody> <tr> <td>hello</td> <td>goodbye</td></tr> <tr> <td>world</td> <td>moon</td></tr> </tbody> </table>","title":"Examples"},{"location":"tools/utils/#hemlocktoolsshow_on_event","text":"def hemlock.tools. show_on_event ( target, condition, value, init_hidden=True, *args, **kwargs ) [source] Show the target question when a condition is met. Parameters: target : hemlock.Question The question which will be shown when the condition is met. condition : hemlock.Question The question whose value determines whether the target is shown. value : str or hemlock.Choice > If the condition is an input, the target is shown when the input value matches this value. 2. If the condition has choices, the target is shown when the choice with this value is checked. < init_hidden : bool, defualt=True Indicates that the initial state of the target should be hidden. regex : bool, default=False Indicates that the target will be shown if input value matches the string as a regular expression. event : str or None, default=None Type of event which toggles the target display. If None , this function infers the type of event based on inputs. duration : str or int, default=400 Show/hide event duration in milliseconds.","title":"hemlock.tools.show_on_event"},{"location":"tools/utils/#examples_3","text":"from hemlock import Page , Check , Input , Label , push_app_context from hemlock.tools import show_on_event app = push_app_context () race = Check ( '<p>Indicate your race.</p>' , [ 'White' , 'Black' , 'Other' ], multiple = True ) specify = Input ( '<p>Please specify.</p>' ) show_on_event ( specify , race , 'Other' ) Page ( race , specify ) . preview () name = Input ( \"<p>What's your name?</p>\" ) greet = Label ( \"Hello, World!\" ) show_on_event ( greet , name , '(w|W)orld' , regex = True , duration = 400 ) Page ( name , greet ) . preview ()","title":"Examples"},{"location":"tools/utils/#hemlocktoolsurl_for","text":"def hemlock.tools. url_for ( *args, **kwargs ) [source] Attempt to return flask.url_for(*args, **kwargs) . However, this method does not exit the program when getting a url outside a request context; e.g. when debugging in a shell or notebook. Parameters: *args, **kwargs : Arguments and keyword arguments will be passed to flask.url_for . Returns: url : str Output of flask.url_for if possible; otherwise 'URL_UNAVAILABLE' .","title":"hemlock.tools.url_for"},{"location":"tutorial/comp_check/","text":"Comprehension check In the previous part of the tutorial, you reviewed page logic. By the end of this part of the tutorial, you'll be able to set up comprehension checks. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why comprehension checks? We often give our participants instructions. To make sure they understand the instructions, we give them comprehension checks. Hemlock has a built-in tool for easy comprehension checks. The structure of a comprehension check is: One or more pages of instructions. One or more pages of 'checks'. If the participant fails a check, they return to the first instructions page. Participants do not have to repeat checks that they pass. We set a limit on the number of attempts participants have to pass each check. For example, suppose there are two checks, A and B. The participant passes check A but fails check B. He is brought back to the first page of the instructions. After rereading the instructions, he is brought directly to check B, skipping check A. (Think about what it would take to do this in Qualtrics, or program this from scratch). Basic syntax Although we usually start with jupyter, the logic of comprehension checks is best illustrated by running an app. Open app.py and replace import survey with import tmp_survey . Now make a new file, tmp_survey.py , and enter the following: from hemlock import ( Branch , Check , Compile as C , Page , Label , Validate as V , Submit as S , route ) from hemlock.tools import comprehension_check @route ( '/survey' ) def start (): return Branch ( * comprehension_check ( instructions = Page ( Label ( 'Here are some instructions' ) ), checks = Page ( Check ( 'Select the correct choice.' , [ 'Correct' , 'Incorrect' , 'Also incorrect' ], compile = [ C . clear_response (), C . shuffle ()], validate = V . require (), submit = S . correct_choices ( 'Correct' ) ) ), attempts = 3 ), Page ( Label ( 'You passed the comprehension check!' ), terminal = True ) ) Run the app and play with the comprehension check. Notice that when you select an incorrect choice, the survey brings you back to the instructions page. Code explanation First, we import our standard hemlock objects and the comprehension_check tool. As usual, we return a branch from our navigate function. We begin the branch with a comprehension check. The comprehension check takes a list of instructions pages (or a single instructions page), a list of check pages (or a single check page), and the number of allotted attempts. The comprehension_check tool returns a list of instructions + check pages. The branch constructor expects pages, not a list of pages, to be passed in as arguments. The asterisk in *comprehension_check(...) means 'unlist' the list of instructions + check pages as you pass them into the branch constructor . The check page contains a Check question. Note that 'check' has different meanings here. A 'check page' in a comprehension check means a page where you test the participant's understanding of the instructions . A 'check question' means a question where you can check one or more choices . By default, the check question records the participant's response and display the choices in their original order. These are both problems for testing comprehension. We don't want participants to simply click choices in order until the hit the right one. To fix this, we add two compile functions: one to clear the response, and one to shuffle the choices. A participant passes a check page when all of its questions' data evaluate to True . So, we'll add a submit function to the check question which converts its data to 1 if the participant selected the correct choice and 0 otherwise ( 1 and 0 evaluate to True and False in most programming languages). Finally, we set attempts=3 to give the participant 3 attempts to pass the check. If a participant fails the check 3 times, they'll simply continue the survey. We can require participants to pass the check by not passing an attempts parameter. What would happen if we didn't require a response? If we didn't require a response, participants wouldn't have to respond to our check question. However, no response is considered incorrect by correct_choices , so hemlock would bring the participant back to the instructions page. Ultimatum game comprehension check We're going to use a comprehension check to explain the ultimatum game to our participants and test their understanding of it. First, open app.py and change import tmp_survey back to import survey . Instructions We're going to write several paragraphs of instructions for our participants. Rather than put this directly in survey.py , we'll store it in a file ug_instructions.md , also in the root directory. ??? tip \"Why store instructions in a separate file?: It's good practice to store large blocks of text in separate markdown files for two reasons: 1. It avoids cluttering your python file 2. It allows you to iterate on the phrasing of important survey pages with your less tech-savvy collaborators, sparing them the enormous burden of having to parse a few lines of code Create a file named ug_instructions.md and paste the following: You are about to play an ultimatum game. The game involves two players: a **proposer** and a **responder**. The proposer has ${} to split between him/herself and the responder. The responder names an amount of money such that he/she accepts any proposed split which gives him/her at least this amount, and rejects any proposed split which gives him/her less than this amount. **If the split is accepted, the proposer and responder split the money according to the proposal. If the split is rejected, both players receive $0.** You will play {} rounds of this game. Each round, you will be paired with another randomly selected participant. **You will rarely, if ever, play two rounds with the same player.** We will test your understanding of these instructions on the next page. Open your notebook and let's preview the instructions page: from hemlock import Page , Label N_ROUNDS = 5 # the number of rounds participants play POT = 20 # the amount of money split Page ( Label ( open ( 'ug_instructions.md' , 'r' ) . read () . format ( POT , N_ROUNDS ) ) ) . preview () Checks For the check pages, we're going to give participants a hypothetical proposal and response and ask them how much money the proposer and responder receive. We'll do this twice: once where the proposal is accepted, the other where it is rejected. Additionally, we want to avoid biasing participants' responses by giving them all the same hypothetical proposal-response pairs. So, we'll write a function to randomly generate proposals. Enter the following in your notebook: from hemlock import Compile as C , Input def gen_check_page ( accept ): return Page ( Label (), Input ( 'How much money does the proposer receive?' , prepend = '$' , append = '.00' , type = 'number' , required = True ), Input ( 'How much money does the responder receive?' , prepend = '$' , append = '.00' , type = 'number' , required = True ), compile = [ C . clear_response (), C . random_proposal ( accept )] ) @C . register def random_proposal ( check_page , accept ): # WE'LL WRITE THIS FUNCTION IN A MOMENT pass gen_check_page ( accept = True ) . preview () The gen_check_page function generates a check page. The Label with which the page starts is going to be populated by a randomly generated proposal-response pair which we'll create with the compile function random_proposal . Both gen_check_page and random_proposal take an accept argument which indicates whether the proposal will be accepted or rejected. Now, fill in the random_proposal function in the next cell: from hemlock import Compile as C , Input , Submit as S from random import randint @C . register def random_proposal ( check_page , accept ): # randomly generate a proposed split and response n = randint ( 1 , POT - 1 ) proposal = POT - n , n # proposer receives POT-n, responder receives n response = randint ( 0 , n ) if accept else randint ( n + 1 , POT ) # compute the payoff payoff = proposal if response <= proposal [ 1 ] else ( 0 , 0 ) # describe the proposal and response in the label check_page . questions [ 0 ] . label = ''' Imagine the proposer proposes the following split: - Proposer: $ {} - Responder: $ {} The responder says, \"I will accept any proposal which gives me at least $ {} .\" ''' . format ( proposal [ 0 ], proposal [ 1 ], response ) # add submit functions to verify that the response was correct check_page . questions [ 1 ] . submit = S . eq ( payoff [ 0 ]) check_page . questions [ 2 ] . submit = S . eq ( payoff [ 1 ]) random_proposal begins by generating a random proposal. We then generate a random response which will accept the proposal if accept is True and reject the proposal if accept is False . The payoff is the proposal if the proposal is accepted and (0,0) if the proposal is rejected. We then fill in the check page's label with the proposal and response. Finally, we add submit functions to the check page's input questions to verify that the participant's responses equal ( eq ) the true payoffs. Let's preview our comprehension check page when the responder accepts the proposal: check_page = gen_check_page ( accept = True ) check_page . _compile () check_page . preview () ...and when the responder rejects the proposal: check_page = gen_check_page ( accept = False ) check_page . _compile () check_page . preview () Adding a comprehension check to our app Let's put this all together in survey.py : from hemlock import ( Branch , Compile as C , Input , Label , Page , Validate as V , Submit as S , route ) from hemlock.tools import comprehension_check , join from hemlock_demographics import basic_demographics from random import randint N_ROUNDS = 5 # the number of rounds participants play POT = 20 # the amount of money split ... def ultimatum_game ( start_branch ): def gen_check_page ( accept ): # PASTE YOUR GEN_CHECK_PAGE FUNCTION HERE return Branch ( * comprehension_check ( instructions = Page ( Label ( open ( 'ug_instructions.md' , 'r' ) . read () . format ( POT , N_ROUNDS ) ) ), checks = [ gen_check_page ( accept = True ), Page ( Label ( 'Correct! One more check to pass.' ) ), gen_check_page ( accept = False ) ], attempts = 3 ), Page ( Label ( 'You passed the comprehension check!' ) ), Page ( Label ( 'Thank you for completing this survey!' ), terminal = True ) ) @C . register def random_proposal ( check_page , accept ): # PASTE YOUR RANDOM_PROPOSAL FUNCTION HERE Run your app and see your comprehension check at work! Summary In this part of the tutorial, you learned how to add comprehension checks to your studies. In the next part of the tutorial, you'll learn how to assign participants to conditions.","title":"Comprehension check"},{"location":"tutorial/comp_check/#comprehension-check","text":"In the previous part of the tutorial, you reviewed page logic. By the end of this part of the tutorial, you'll be able to set up comprehension checks. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why comprehension checks? We often give our participants instructions. To make sure they understand the instructions, we give them comprehension checks. Hemlock has a built-in tool for easy comprehension checks. The structure of a comprehension check is: One or more pages of instructions. One or more pages of 'checks'. If the participant fails a check, they return to the first instructions page. Participants do not have to repeat checks that they pass. We set a limit on the number of attempts participants have to pass each check. For example, suppose there are two checks, A and B. The participant passes check A but fails check B. He is brought back to the first page of the instructions. After rereading the instructions, he is brought directly to check B, skipping check A. (Think about what it would take to do this in Qualtrics, or program this from scratch).","title":"Comprehension check"},{"location":"tutorial/comp_check/#basic-syntax","text":"Although we usually start with jupyter, the logic of comprehension checks is best illustrated by running an app. Open app.py and replace import survey with import tmp_survey . Now make a new file, tmp_survey.py , and enter the following: from hemlock import ( Branch , Check , Compile as C , Page , Label , Validate as V , Submit as S , route ) from hemlock.tools import comprehension_check @route ( '/survey' ) def start (): return Branch ( * comprehension_check ( instructions = Page ( Label ( 'Here are some instructions' ) ), checks = Page ( Check ( 'Select the correct choice.' , [ 'Correct' , 'Incorrect' , 'Also incorrect' ], compile = [ C . clear_response (), C . shuffle ()], validate = V . require (), submit = S . correct_choices ( 'Correct' ) ) ), attempts = 3 ), Page ( Label ( 'You passed the comprehension check!' ), terminal = True ) ) Run the app and play with the comprehension check. Notice that when you select an incorrect choice, the survey brings you back to the instructions page.","title":"Basic syntax"},{"location":"tutorial/comp_check/#code-explanation","text":"First, we import our standard hemlock objects and the comprehension_check tool. As usual, we return a branch from our navigate function. We begin the branch with a comprehension check. The comprehension check takes a list of instructions pages (or a single instructions page), a list of check pages (or a single check page), and the number of allotted attempts. The comprehension_check tool returns a list of instructions + check pages. The branch constructor expects pages, not a list of pages, to be passed in as arguments. The asterisk in *comprehension_check(...) means 'unlist' the list of instructions + check pages as you pass them into the branch constructor . The check page contains a Check question. Note that 'check' has different meanings here. A 'check page' in a comprehension check means a page where you test the participant's understanding of the instructions . A 'check question' means a question where you can check one or more choices . By default, the check question records the participant's response and display the choices in their original order. These are both problems for testing comprehension. We don't want participants to simply click choices in order until the hit the right one. To fix this, we add two compile functions: one to clear the response, and one to shuffle the choices. A participant passes a check page when all of its questions' data evaluate to True . So, we'll add a submit function to the check question which converts its data to 1 if the participant selected the correct choice and 0 otherwise ( 1 and 0 evaluate to True and False in most programming languages). Finally, we set attempts=3 to give the participant 3 attempts to pass the check. If a participant fails the check 3 times, they'll simply continue the survey. We can require participants to pass the check by not passing an attempts parameter. What would happen if we didn't require a response? If we didn't require a response, participants wouldn't have to respond to our check question. However, no response is considered incorrect by correct_choices , so hemlock would bring the participant back to the instructions page.","title":"Code explanation"},{"location":"tutorial/comp_check/#ultimatum-game-comprehension-check","text":"We're going to use a comprehension check to explain the ultimatum game to our participants and test their understanding of it. First, open app.py and change import tmp_survey back to import survey .","title":"Ultimatum game comprehension check"},{"location":"tutorial/comp_check/#instructions","text":"We're going to write several paragraphs of instructions for our participants. Rather than put this directly in survey.py , we'll store it in a file ug_instructions.md , also in the root directory. ??? tip \"Why store instructions in a separate file?: It's good practice to store large blocks of text in separate markdown files for two reasons: 1. It avoids cluttering your python file 2. It allows you to iterate on the phrasing of important survey pages with your less tech-savvy collaborators, sparing them the enormous burden of having to parse a few lines of code Create a file named ug_instructions.md and paste the following: You are about to play an ultimatum game. The game involves two players: a **proposer** and a **responder**. The proposer has ${} to split between him/herself and the responder. The responder names an amount of money such that he/she accepts any proposed split which gives him/her at least this amount, and rejects any proposed split which gives him/her less than this amount. **If the split is accepted, the proposer and responder split the money according to the proposal. If the split is rejected, both players receive $0.** You will play {} rounds of this game. Each round, you will be paired with another randomly selected participant. **You will rarely, if ever, play two rounds with the same player.** We will test your understanding of these instructions on the next page. Open your notebook and let's preview the instructions page: from hemlock import Page , Label N_ROUNDS = 5 # the number of rounds participants play POT = 20 # the amount of money split Page ( Label ( open ( 'ug_instructions.md' , 'r' ) . read () . format ( POT , N_ROUNDS ) ) ) . preview ()","title":"Instructions"},{"location":"tutorial/comp_check/#checks","text":"For the check pages, we're going to give participants a hypothetical proposal and response and ask them how much money the proposer and responder receive. We'll do this twice: once where the proposal is accepted, the other where it is rejected. Additionally, we want to avoid biasing participants' responses by giving them all the same hypothetical proposal-response pairs. So, we'll write a function to randomly generate proposals. Enter the following in your notebook: from hemlock import Compile as C , Input def gen_check_page ( accept ): return Page ( Label (), Input ( 'How much money does the proposer receive?' , prepend = '$' , append = '.00' , type = 'number' , required = True ), Input ( 'How much money does the responder receive?' , prepend = '$' , append = '.00' , type = 'number' , required = True ), compile = [ C . clear_response (), C . random_proposal ( accept )] ) @C . register def random_proposal ( check_page , accept ): # WE'LL WRITE THIS FUNCTION IN A MOMENT pass gen_check_page ( accept = True ) . preview () The gen_check_page function generates a check page. The Label with which the page starts is going to be populated by a randomly generated proposal-response pair which we'll create with the compile function random_proposal . Both gen_check_page and random_proposal take an accept argument which indicates whether the proposal will be accepted or rejected. Now, fill in the random_proposal function in the next cell: from hemlock import Compile as C , Input , Submit as S from random import randint @C . register def random_proposal ( check_page , accept ): # randomly generate a proposed split and response n = randint ( 1 , POT - 1 ) proposal = POT - n , n # proposer receives POT-n, responder receives n response = randint ( 0 , n ) if accept else randint ( n + 1 , POT ) # compute the payoff payoff = proposal if response <= proposal [ 1 ] else ( 0 , 0 ) # describe the proposal and response in the label check_page . questions [ 0 ] . label = ''' Imagine the proposer proposes the following split: - Proposer: $ {} - Responder: $ {} The responder says, \"I will accept any proposal which gives me at least $ {} .\" ''' . format ( proposal [ 0 ], proposal [ 1 ], response ) # add submit functions to verify that the response was correct check_page . questions [ 1 ] . submit = S . eq ( payoff [ 0 ]) check_page . questions [ 2 ] . submit = S . eq ( payoff [ 1 ]) random_proposal begins by generating a random proposal. We then generate a random response which will accept the proposal if accept is True and reject the proposal if accept is False . The payoff is the proposal if the proposal is accepted and (0,0) if the proposal is rejected. We then fill in the check page's label with the proposal and response. Finally, we add submit functions to the check page's input questions to verify that the participant's responses equal ( eq ) the true payoffs. Let's preview our comprehension check page when the responder accepts the proposal: check_page = gen_check_page ( accept = True ) check_page . _compile () check_page . preview () ...and when the responder rejects the proposal: check_page = gen_check_page ( accept = False ) check_page . _compile () check_page . preview ()","title":"Checks"},{"location":"tutorial/comp_check/#adding-a-comprehension-check-to-our-app","text":"Let's put this all together in survey.py : from hemlock import ( Branch , Compile as C , Input , Label , Page , Validate as V , Submit as S , route ) from hemlock.tools import comprehension_check , join from hemlock_demographics import basic_demographics from random import randint N_ROUNDS = 5 # the number of rounds participants play POT = 20 # the amount of money split ... def ultimatum_game ( start_branch ): def gen_check_page ( accept ): # PASTE YOUR GEN_CHECK_PAGE FUNCTION HERE return Branch ( * comprehension_check ( instructions = Page ( Label ( open ( 'ug_instructions.md' , 'r' ) . read () . format ( POT , N_ROUNDS ) ) ), checks = [ gen_check_page ( accept = True ), Page ( Label ( 'Correct! One more check to pass.' ) ), gen_check_page ( accept = False ) ], attempts = 3 ), Page ( Label ( 'You passed the comprehension check!' ) ), Page ( Label ( 'Thank you for completing this survey!' ), terminal = True ) ) @C . register def random_proposal ( check_page , accept ): # PASTE YOUR RANDOM_PROPOSAL FUNCTION HERE Run your app and see your comprehension check at work!","title":"Adding a comprehension check to our app"},{"location":"tutorial/comp_check/#summary","text":"In this part of the tutorial, you learned how to add comprehension checks to your studies. In the next part of the tutorial, you'll learn how to assign participants to conditions.","title":"Summary"},{"location":"tutorial/compile/","text":"Compile In the previous part of the tutorial, you learned how to install and use extensions and third-party packages. In this part of the tutorial, you'll implement a confirmation page using compile functions. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why compile functions? Compile functions run just before a page's HTML is compiled. This allows us to make our survey responsive to participants. The most common use for compile functions is to 'pipe text' from a participant's previous responses onto a page. In our case, we're going to make a confirmation page for the participant's demographic information. Basic syntax Open your jupyter notebook and run the following: from hemlock import Check , Compile as C check = Check ( 'Choose the correct answer' , [ 'Correct' , 'Incorrect' , 'Also incorrect' ], compile = C . shuffle () ) check . compile Out: [<shuffle()>] You can add compile functions to a page or question by setting its compile attribute or passing a compile argument to its constructor. Compile functions run just before a page's HTML is compiled. The shuffle compile function shuffles a question's choices. (Or, if attached to a page, shuffles its page's questions). Let's watch our compile function at work: check._compile() check.choices Out: [<Choice 'Also incorrect'>, <Choice 'Correct'>, <Choice 'Incorrect'>] Run this a few times and notice how the order of the choices changes. This behavior is useful for comprehension checks, as we'll see later. Tip You don't need to run _compile yourself in the survey. Hemlock takes care of this automatically for you. More compile functions shuffle is just one of many native hemlock compile functions . An aside on tools To make our confirmation page, we're going to need a tool called join . This tool joins a list of items using a 'joiner' like 'and' or 'or'. We'll use this display the participant's race. from hemlock.tools import join print ( join ( 'and' , [ 'White' ])) print ( join ( 'and' , [ 'White' , 'Black' ])) print ( join ( 'and' , [ 'White' , 'Black' , 'South Asian' ])) Out: White White and Black White, Black, and South Asian More tools join is just one of many native hemlock tools. Check out the 'Tools' heading in the navigation bar for more. Custom compilation We're going to take the participant's responses to the demographics page and display them on a new page. We'll ask the participant to correct any errors by going back to the demographics page. The demographics page: a recap First, let's remind ourselves what's in the basic demographics page: from hemlock_demographics import basic_demographics demographics_page = basic_demographics ( page = True ) [ print ( q . label ) for q in demographics_page . questions ] Out: What is your gender? Please specify your gender. How old are you? Which race or ethnicity do you belong to? Check as many as apply. Please specify your race or ethnicity. The 0th question asks for gender, the 2nd for age, and the 3rd for race. (The 1st and 4th questions ask participants to specify gender and race if they choose 'Other'). Let's enter hypothetical responses for these questions. gender = demographics_page . questions [ 0 ] gender . response = 'Male' age = demographics_page . questions [ 2 ] age . response = '28' race = demographics_page . questions [ 3 ] race . response = [ 'White' ] The compile function It's time to write our custom compile function. from hemlock import Compile as C @C . register def confirm_demographics ( confirm_label , demographics_page ): gender = demographics_page . questions [ 0 ] . response age = demographics_page . questions [ 2 ] . response race = join ( 'and' , demographics_page . questions [ 3 ] . response ) confirm_label . label = ''' Confirm the following information: - Gender: {} - Age: {} - Race: {} To correct this information, click '<<'. ''' . format ( gender , age , race ) First, we register a new compile function with the @C.register decorator. The compile function takes the confirmation label as its first argument. In general, compile functions take their parent as their first argument. We also pass in the demographics page as the compile function's second argument. confirm_demographics begins by gathering the demographics data (gender, date of birth, and race) from the demographics page. We use the join tool to join the participant's races. Finally, we add the demographics information to the confirmation label. Label object vs. label attribute Note that we set the confirmation label with confirm_label.label='my awesome label' . confirm_label is a Label object. confirm_label.label is the attribute which contains the HTML. Don't confuse the Label object with the label attribute! Our compile function at work Finally, let's see our compile function at work. from hemlock import Page , Label confirm_page = Page ( Label ( compile = C . confirm_demographics ( demographics_page ) ), back = True ) confirm_page . _compile () confirm_page . preview () Note that we add a back button by passing back=True to the label's constructor. Compilation in our app Now that we've seen how to add compile functions in our notebook, let's add it to our app. In survey.py : from hemlock import Branch , Compile as C , Label , Page , route from hemlock.tools import join from hemlock_demographics import basic_demographics @route ( '/survey' ) def start (): demographics_page = basic_demographics ( page = True , require = True ) return Branch ( demographics_page , Page ( Label ( compile = C . confirm_demographics ( demographics_page ) ), back = True ), Page ( Label ( 'Thank you for completing this survey!' ), terminal = True ) ) @C . register def confirm_demographics ( confirm_label , demographics_page ): # COPY AND PASTE YOUR CONFIRM DEMOGRAPHICS FUNCTION HERE Run the app again to see your confirmation page. Summary In this part of the tutorial, you implemented a confirmation page using compile functions. In the next part of the tutorial, you'll learn how to set up navigation between branches.","title":"Compile"},{"location":"tutorial/compile/#compile","text":"In the previous part of the tutorial, you learned how to install and use extensions and third-party packages. In this part of the tutorial, you'll implement a confirmation page using compile functions. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why compile functions? Compile functions run just before a page's HTML is compiled. This allows us to make our survey responsive to participants. The most common use for compile functions is to 'pipe text' from a participant's previous responses onto a page. In our case, we're going to make a confirmation page for the participant's demographic information.","title":"Compile"},{"location":"tutorial/compile/#basic-syntax","text":"Open your jupyter notebook and run the following: from hemlock import Check , Compile as C check = Check ( 'Choose the correct answer' , [ 'Correct' , 'Incorrect' , 'Also incorrect' ], compile = C . shuffle () ) check . compile Out: [<shuffle()>] You can add compile functions to a page or question by setting its compile attribute or passing a compile argument to its constructor. Compile functions run just before a page's HTML is compiled. The shuffle compile function shuffles a question's choices. (Or, if attached to a page, shuffles its page's questions). Let's watch our compile function at work: check._compile() check.choices Out: [<Choice 'Also incorrect'>, <Choice 'Correct'>, <Choice 'Incorrect'>] Run this a few times and notice how the order of the choices changes. This behavior is useful for comprehension checks, as we'll see later. Tip You don't need to run _compile yourself in the survey. Hemlock takes care of this automatically for you. More compile functions shuffle is just one of many native hemlock compile functions .","title":"Basic syntax"},{"location":"tutorial/compile/#an-aside-on-tools","text":"To make our confirmation page, we're going to need a tool called join . This tool joins a list of items using a 'joiner' like 'and' or 'or'. We'll use this display the participant's race. from hemlock.tools import join print ( join ( 'and' , [ 'White' ])) print ( join ( 'and' , [ 'White' , 'Black' ])) print ( join ( 'and' , [ 'White' , 'Black' , 'South Asian' ])) Out: White White and Black White, Black, and South Asian More tools join is just one of many native hemlock tools. Check out the 'Tools' heading in the navigation bar for more.","title":"An aside on tools"},{"location":"tutorial/compile/#custom-compilation","text":"We're going to take the participant's responses to the demographics page and display them on a new page. We'll ask the participant to correct any errors by going back to the demographics page.","title":"Custom compilation"},{"location":"tutorial/compile/#the-demographics-page-a-recap","text":"First, let's remind ourselves what's in the basic demographics page: from hemlock_demographics import basic_demographics demographics_page = basic_demographics ( page = True ) [ print ( q . label ) for q in demographics_page . questions ] Out: What is your gender? Please specify your gender. How old are you? Which race or ethnicity do you belong to? Check as many as apply. Please specify your race or ethnicity. The 0th question asks for gender, the 2nd for age, and the 3rd for race. (The 1st and 4th questions ask participants to specify gender and race if they choose 'Other'). Let's enter hypothetical responses for these questions. gender = demographics_page . questions [ 0 ] gender . response = 'Male' age = demographics_page . questions [ 2 ] age . response = '28' race = demographics_page . questions [ 3 ] race . response = [ 'White' ]","title":"The demographics page: a recap"},{"location":"tutorial/compile/#the-compile-function","text":"It's time to write our custom compile function. from hemlock import Compile as C @C . register def confirm_demographics ( confirm_label , demographics_page ): gender = demographics_page . questions [ 0 ] . response age = demographics_page . questions [ 2 ] . response race = join ( 'and' , demographics_page . questions [ 3 ] . response ) confirm_label . label = ''' Confirm the following information: - Gender: {} - Age: {} - Race: {} To correct this information, click '<<'. ''' . format ( gender , age , race ) First, we register a new compile function with the @C.register decorator. The compile function takes the confirmation label as its first argument. In general, compile functions take their parent as their first argument. We also pass in the demographics page as the compile function's second argument. confirm_demographics begins by gathering the demographics data (gender, date of birth, and race) from the demographics page. We use the join tool to join the participant's races. Finally, we add the demographics information to the confirmation label. Label object vs. label attribute Note that we set the confirmation label with confirm_label.label='my awesome label' . confirm_label is a Label object. confirm_label.label is the attribute which contains the HTML. Don't confuse the Label object with the label attribute!","title":"The compile function"},{"location":"tutorial/compile/#our-compile-function-at-work","text":"Finally, let's see our compile function at work. from hemlock import Page , Label confirm_page = Page ( Label ( compile = C . confirm_demographics ( demographics_page ) ), back = True ) confirm_page . _compile () confirm_page . preview () Note that we add a back button by passing back=True to the label's constructor.","title":"Our compile function at work"},{"location":"tutorial/compile/#compilation-in-our-app","text":"Now that we've seen how to add compile functions in our notebook, let's add it to our app. In survey.py : from hemlock import Branch , Compile as C , Label , Page , route from hemlock.tools import join from hemlock_demographics import basic_demographics @route ( '/survey' ) def start (): demographics_page = basic_demographics ( page = True , require = True ) return Branch ( demographics_page , Page ( Label ( compile = C . confirm_demographics ( demographics_page ) ), back = True ), Page ( Label ( 'Thank you for completing this survey!' ), terminal = True ) ) @C . register def confirm_demographics ( confirm_label , demographics_page ): # COPY AND PASTE YOUR CONFIRM DEMOGRAPHICS FUNCTION HERE Run the app again to see your confirmation page.","title":"Compilation in our app"},{"location":"tutorial/compile/#summary","text":"In this part of the tutorial, you implemented a confirmation page using compile functions. In the next part of the tutorial, you'll learn how to set up navigation between branches.","title":"Summary"},{"location":"tutorial/data/","text":"Data In the previous part of the tutorial, you learned how to create a demographics questionnaire using several question polymorphs. By the end of this part of the tutorial, you'll be able to store and download data. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Previewing data from a single participant Each hemlock project has a downloadable data frame containing the data for all participants. We'll start by looking at the data belonging to a 'test participant'. Run the following in your jupyter notebook: from hemlock import Participant part = Participant . gen_test_participant () dict ( part . get_data ()) Out: {'ID': [1], 'EndTime': ['2021-02-10 15:34:28.116156'], 'StartTime': ['2021-02-10 15:34:28.116156'], 'Status': ['InProgress']} This shows the data our test participant contributes to the data frame. The keys are variable names, and values are list of entries for that variable. An easy way to add data is with 'embedded data': from hemlock import Embedded part . embedded = [ Embedded ( var = 'MyVariable' , data = 'MyData' )] dict ( part . get_data ()) Out: {'ID': [1], 'EndTime': ['2021-02-10 15:34:28.116156'], 'StartTime': ['2021-02-10 15:34:28.116156'], 'Status': ['InProgress'], 'MyVariable': ['MyData']} This adds an Embedded data object to our participant. Embedded data are a type of data element, like questions, but unlike questions, are not displayed to participants. We can add embedded data to a participant, branch, or page. Looking at the data, we see that the participant has a new variable named 'MyVariable' with data ['MyData'] . What happens when multiple data elements have the same variable name? When you have multiple data elements contributing data to the same variable, hemlock automatically orders them in a sensible way. If you find that hemlock's default ordering algorithm isn't ordering your data the way you want, come back and reread this. The order in which data elements appear in the data frame is the order in which they were added to the database; not necessarily the order in which they appear to the participant. For example: from hemlock import db embedded1 = Embedded ( 'MyVariable' , 1 ) embedded0 = Embedded ( 'MyVariable' , 0 ) db . session . add_all ([ embedded1 , embedded0 ]) db . session . flush ([ embedded1 , embedded0 ]) part . embedded = [ embedded0 , embedded1 ] dict ( part . get_data ()) Out: {'ID': [1, 1], 'EndTime': ['2021-02-10 15:34:28.116156', '2021-02-10 15:34:28.116156'], 'StartTime': ['2021-02-10 15:34:28.116156', '2021-02-10 15:34:28.116156'], 'Status': ['InProgress', 'InProgress'], 'MyVariable': [1, 0]} Note that the data for 'MyVariable' are [1, 0] because we added embedded1 before to the database before embedded0 using db.session.add_all and db.session.flush . Again, hemlock automatically manages your database, so you you'll only need to use db.session.add_all and db.session.flush when you want to customize the order of your data elements. Data on multiple rows By default, data elements (embedded data and questions) contribute 1 row to the data frame. But we often want the same data to be repeated on multiple rows. We do this by setting the data_rows attribute: part . embedded = [ Embedded ( 'MyVariable' , 'MyData' , data_rows = 3 )] dict ( part . get_data ()) Out: {'ID': [1, 1, 1], 'EndTime': ['2021-02-10 15:34:28.116156', '2021-02-10 15:34:28.116156', '2021-02-10 15:34:28.116156'], 'StartTime': ['2021-02-10 15:34:28.116156', '2021-02-10 15:34:28.116156', '2021-02-10 15:34:28.116156'], 'Status': ['InProgress', 'InProgress', 'InProgress'], 'MyVariable': ['MyData', 'MyData', 'MyData']} Filling in rows We often want to 'fill in' rows of a variable to match the length of a data frame. For example, we may not know in advance how many rows a participant will contribute to the data frame, but we know that we want the participant's demographic information to appear on all rows. To do this, we set data_rows to a negative number. For example, data_rows=-2 means 'fill in two rows with this data entry and, when you download the data, fill in any blank rows after this with the same data': part . embedded = [ # these data will appear on three rows of the data frame Embedded ( 'MyVariable' , 'MyData' , data_rows = 3 ), # these data will fill in empty rows at the bottom of the data frame Embedded ( 'MyFilledVariable' , 'MyFilledData' , data_rows =- 1 ) ] dict ( part . get_data ()) Out: {'ID': [1, 1, 1], 'EndTime': ['2021-02-10 15:59:28.018253', '2021-02-10 15:59:28.018253', '2021-02-10 15:59:28.018253'], 'StartTime': ['2021-02-10 15:59:28.018253', '2021-02-10 15:59:28.018253', '2021-02-10 15:59:28.018253'], 'Status': ['InProgress', 'InProgress', 'InProgress'], 'MyVariable': ['MyData', 'MyData', 'MyData'], 'MyFilledVariable': ['MyFilledData', 'MyFilledData', 'MyFilledData']} Multiple data values Finally, a data element can contribute a list of values to the data frame: part . embedded = [ Embedded ( 'var' , [ 0 , 1 , 2 ])] dict ( part . get_data ()) Out: {'ID': [1, 1, 1], 'EndTime': ['2021-02-10 15:58:34.743335', '2021-02-10 15:58:34.743335', '2021-02-10 15:58:34.743335'], 'StartTime': ['2021-02-10 15:58:34.743335', '2021-02-10 15:58:34.743335', '2021-02-10 15:58:34.743335'], 'Status': ['InProgress', 'InProgress', 'InProgress'], 'var': [0, 1, 2]} Adding data to our survey We can add data to our existing survey in much the same way: by setting a question's var and (when necessary) data_rows attribute. We generally want demographics information to appear in all rows of the data frame, so we'll set data_rows=-1 . In survey.py : ... @route ( '/survey' ) def start (): return Branch ( Page ( Select ( 'What is your gender?' , [ '' , 'Male' , 'Female' , 'Other' ], var = 'Gender' , data_rows =- 1 ), Input ( 'How old are you?' , type = 'number' , min = 0 , var = 'Age' , data_rows =- 1 ), # SET THE `var` AND `data_rows` ATTRIBUTES FOR THE REST OF THE QUESTIONS ... Note When a participant submits a page, the questions' data are recorded in a data attribute. A question's data will be added to the data frame if and only if you set its var attribute. However, data will be stored in a question's data attribute whether or not the variable is set, allowing you to access it later. Downloading data Run your survey locally, fill in the demographics page, and continue to the end of the survey. Your data will be recorded in the database. To download your data, navigate to http://localhost:5000/download in your browser. Select 'Data frame', then click the download button. This will download a zip file containing your data in .csv format. Automatic one-hot encoding The data of questions for which you can select multiple choices are automatically one-hot encoded. For example, if RaceWhite and RaceBlack are both 1, and the rest of the race variables are 0, this means means the participant is part White and part Black. Summary In this part of the tutorial, you learned how to store and download data. In the next part of the tutorial, you'll implement validation for participant responses.","title":"Data"},{"location":"tutorial/data/#data","text":"In the previous part of the tutorial, you learned how to create a demographics questionnaire using several question polymorphs. By the end of this part of the tutorial, you'll be able to store and download data. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Data"},{"location":"tutorial/data/#previewing-data-from-a-single-participant","text":"Each hemlock project has a downloadable data frame containing the data for all participants. We'll start by looking at the data belonging to a 'test participant'. Run the following in your jupyter notebook: from hemlock import Participant part = Participant . gen_test_participant () dict ( part . get_data ()) Out: {'ID': [1], 'EndTime': ['2021-02-10 15:34:28.116156'], 'StartTime': ['2021-02-10 15:34:28.116156'], 'Status': ['InProgress']} This shows the data our test participant contributes to the data frame. The keys are variable names, and values are list of entries for that variable. An easy way to add data is with 'embedded data': from hemlock import Embedded part . embedded = [ Embedded ( var = 'MyVariable' , data = 'MyData' )] dict ( part . get_data ()) Out: {'ID': [1], 'EndTime': ['2021-02-10 15:34:28.116156'], 'StartTime': ['2021-02-10 15:34:28.116156'], 'Status': ['InProgress'], 'MyVariable': ['MyData']} This adds an Embedded data object to our participant. Embedded data are a type of data element, like questions, but unlike questions, are not displayed to participants. We can add embedded data to a participant, branch, or page. Looking at the data, we see that the participant has a new variable named 'MyVariable' with data ['MyData'] . What happens when multiple data elements have the same variable name? When you have multiple data elements contributing data to the same variable, hemlock automatically orders them in a sensible way. If you find that hemlock's default ordering algorithm isn't ordering your data the way you want, come back and reread this. The order in which data elements appear in the data frame is the order in which they were added to the database; not necessarily the order in which they appear to the participant. For example: from hemlock import db embedded1 = Embedded ( 'MyVariable' , 1 ) embedded0 = Embedded ( 'MyVariable' , 0 ) db . session . add_all ([ embedded1 , embedded0 ]) db . session . flush ([ embedded1 , embedded0 ]) part . embedded = [ embedded0 , embedded1 ] dict ( part . get_data ()) Out: {'ID': [1, 1], 'EndTime': ['2021-02-10 15:34:28.116156', '2021-02-10 15:34:28.116156'], 'StartTime': ['2021-02-10 15:34:28.116156', '2021-02-10 15:34:28.116156'], 'Status': ['InProgress', 'InProgress'], 'MyVariable': [1, 0]} Note that the data for 'MyVariable' are [1, 0] because we added embedded1 before to the database before embedded0 using db.session.add_all and db.session.flush . Again, hemlock automatically manages your database, so you you'll only need to use db.session.add_all and db.session.flush when you want to customize the order of your data elements.","title":"Previewing data from a single participant"},{"location":"tutorial/data/#data-on-multiple-rows","text":"By default, data elements (embedded data and questions) contribute 1 row to the data frame. But we often want the same data to be repeated on multiple rows. We do this by setting the data_rows attribute: part . embedded = [ Embedded ( 'MyVariable' , 'MyData' , data_rows = 3 )] dict ( part . get_data ()) Out: {'ID': [1, 1, 1], 'EndTime': ['2021-02-10 15:34:28.116156', '2021-02-10 15:34:28.116156', '2021-02-10 15:34:28.116156'], 'StartTime': ['2021-02-10 15:34:28.116156', '2021-02-10 15:34:28.116156', '2021-02-10 15:34:28.116156'], 'Status': ['InProgress', 'InProgress', 'InProgress'], 'MyVariable': ['MyData', 'MyData', 'MyData']}","title":"Data on multiple rows"},{"location":"tutorial/data/#filling-in-rows","text":"We often want to 'fill in' rows of a variable to match the length of a data frame. For example, we may not know in advance how many rows a participant will contribute to the data frame, but we know that we want the participant's demographic information to appear on all rows. To do this, we set data_rows to a negative number. For example, data_rows=-2 means 'fill in two rows with this data entry and, when you download the data, fill in any blank rows after this with the same data': part . embedded = [ # these data will appear on three rows of the data frame Embedded ( 'MyVariable' , 'MyData' , data_rows = 3 ), # these data will fill in empty rows at the bottom of the data frame Embedded ( 'MyFilledVariable' , 'MyFilledData' , data_rows =- 1 ) ] dict ( part . get_data ()) Out: {'ID': [1, 1, 1], 'EndTime': ['2021-02-10 15:59:28.018253', '2021-02-10 15:59:28.018253', '2021-02-10 15:59:28.018253'], 'StartTime': ['2021-02-10 15:59:28.018253', '2021-02-10 15:59:28.018253', '2021-02-10 15:59:28.018253'], 'Status': ['InProgress', 'InProgress', 'InProgress'], 'MyVariable': ['MyData', 'MyData', 'MyData'], 'MyFilledVariable': ['MyFilledData', 'MyFilledData', 'MyFilledData']}","title":"Filling in rows"},{"location":"tutorial/data/#multiple-data-values","text":"Finally, a data element can contribute a list of values to the data frame: part . embedded = [ Embedded ( 'var' , [ 0 , 1 , 2 ])] dict ( part . get_data ()) Out: {'ID': [1, 1, 1], 'EndTime': ['2021-02-10 15:58:34.743335', '2021-02-10 15:58:34.743335', '2021-02-10 15:58:34.743335'], 'StartTime': ['2021-02-10 15:58:34.743335', '2021-02-10 15:58:34.743335', '2021-02-10 15:58:34.743335'], 'Status': ['InProgress', 'InProgress', 'InProgress'], 'var': [0, 1, 2]}","title":"Multiple data values"},{"location":"tutorial/data/#adding-data-to-our-survey","text":"We can add data to our existing survey in much the same way: by setting a question's var and (when necessary) data_rows attribute. We generally want demographics information to appear in all rows of the data frame, so we'll set data_rows=-1 . In survey.py : ... @route ( '/survey' ) def start (): return Branch ( Page ( Select ( 'What is your gender?' , [ '' , 'Male' , 'Female' , 'Other' ], var = 'Gender' , data_rows =- 1 ), Input ( 'How old are you?' , type = 'number' , min = 0 , var = 'Age' , data_rows =- 1 ), # SET THE `var` AND `data_rows` ATTRIBUTES FOR THE REST OF THE QUESTIONS ... Note When a participant submits a page, the questions' data are recorded in a data attribute. A question's data will be added to the data frame if and only if you set its var attribute. However, data will be stored in a question's data attribute whether or not the variable is set, allowing you to access it later.","title":"Adding data to our survey"},{"location":"tutorial/data/#downloading-data","text":"Run your survey locally, fill in the demographics page, and continue to the end of the survey. Your data will be recorded in the database. To download your data, navigate to http://localhost:5000/download in your browser. Select 'Data frame', then click the download button. This will download a zip file containing your data in .csv format. Automatic one-hot encoding The data of questions for which you can select multiple choices are automatically one-hot encoded. For example, if RaceWhite and RaceBlack are both 1, and the rest of the race variables are 0, this means means the participant is part White and part Black.","title":"Downloading data"},{"location":"tutorial/data/#summary","text":"In this part of the tutorial, you learned how to store and download data. In the next part of the tutorial, you'll implement validation for participant responses.","title":"Summary"},{"location":"tutorial/debug/","text":"Debugging In the previous part of the tutorial, you implemented the responder branch. By the end of this part of the tutorial, you'll be able to use hemlock's debugging tool to make sure your app is running smoothly. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why a custom debugging tool? In the early days of hemlock, I coded a study in which I asked participants to estimate the ages of people in photographs. I used a submit function to change their data from strings to integers. Everything was running smoothly until one mischievous participant entered 'twenty-seven', breaking my survey and sending me home in a fit of rage. Since then, I took two steps to maintain equipoise when I launch my studies. First, I began daily mindfulness practice. Second, I wrote a custom debugger for hemlock. We often underestimate just how strangely participants will respond to our studies in ways that we can't foresee. Hemlock's debugger sends an AI participant through your survey to check things out. 'AI participant' is a bit of a misnomer. If anything, it's an artificially stupid participant. It clicks random buttons, enters random things into inputs and text boxes, drags range sliders to random values; basically stress testing your code. Setup To run hemlock's custom debugging tool locally, you'll need Google Chrome and Chromedriver . Check out the setup page for your OS for specific instructions: Windows Windows Subsystem for Linux Mac Linux Basic syntax Open your jupyter notebook and run the following: from hemlock import Debug as D , Input inpt = Input ( debug = D . send_keys ( 'Hello, World!' ) ) inpt . debug Out: [<send_keys('Hello, World!')>] You can add debug functions to a page or quesiton by settings its debug attribute or passing a debug argument to its constructor. Debug functions run when we run the debugger (in just a moment). As its name suggests, the send_keys debug function tells the AI participant to send keys to the input. Let's watch our debug function at work: from hemlock import Page from hemlock.tools import chromedriver driver = chromedriver () page = Page ( Input ( debug = D . send_keys ( 'Hello, World!' ) ), debug = D . debug_questions () ) page . preview ( driver ) page . _debug ( driver ) First, we use chromedriver to open Chromedriver with selenium python . Next, we create a page with our input question. By default, a page has two debug functions. The first runs its questions' debug functions, and the second clicks the forward or back button. Here, we just want the page to run the question's debug function, so we pass debug=D.debug_questions() to the page's constructor. Finally, we run the debug function. You'll notice it enters 'Hello, World!' in the input. After you're done, close the driver: driver . close () Tip You don't need to run _debug yourself in the survey. Hemlock takes care of this automatically for you. More debug functions send_keys is just one of many native hemlock debug functions . Default debug functions We can attach debug functions to pages or questions. Most questions have a default debug function. For example, input questions have a default debug function which sends random ASCII characters to the input. Check out the default debug function at work: page = Page ( Input (), debug = D . debug_questions () ) page . preview ( driver ) page . _debug ( driver ) Custom debug functions We won't need custom debug functions for our survey, but you may need them elsewhere. Creating custom debug function is similar to creating custom compile, validate, submit, and navigate functions, with one important difference. While the functions you've seen take their parent as their first argument, debug functions take a selenium webdriver as their first argument and their parent as their second argument: Simple pattern: def my_debug_function ( driver , parent ): # your awesome debug function Input ( debug = my_debug_function ) Decorator pattern: @D . register def my_debug_function ( driver , parent , my_argument ): # your awesome debug function Input ( debug = D . my_debug_function ( my_argument ) ) Before writing custom debug functions, I recommend checking out the source code for inspiration. Run the debugger It's time to run hemlock's debugger through our app. Open another terminal window. As always, change to your project directory: $ cd $ cd my-first-project You should have three terminals open: one for jupyter, one for editing survey.py and running hlk serve , and now a third for running the debugger. In one of the terminal windows, run the hemlock app as usual ( hlk serve ). In the third terminal, run the debugger: $ hlk debug To run several AI participants through the survey, e.g. 3, use: $ hlk debug -n 3 Summary In this part of the tutorial, you learned how to debug your app with hemlock's custom debugging tool. In the next part of the tutorial, you'll learn how to deploy your application (i.e., put it on the web).","title":"Debugging"},{"location":"tutorial/debug/#debugging","text":"In the previous part of the tutorial, you implemented the responder branch. By the end of this part of the tutorial, you'll be able to use hemlock's debugging tool to make sure your app is running smoothly. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why a custom debugging tool? In the early days of hemlock, I coded a study in which I asked participants to estimate the ages of people in photographs. I used a submit function to change their data from strings to integers. Everything was running smoothly until one mischievous participant entered 'twenty-seven', breaking my survey and sending me home in a fit of rage. Since then, I took two steps to maintain equipoise when I launch my studies. First, I began daily mindfulness practice. Second, I wrote a custom debugger for hemlock. We often underestimate just how strangely participants will respond to our studies in ways that we can't foresee. Hemlock's debugger sends an AI participant through your survey to check things out. 'AI participant' is a bit of a misnomer. If anything, it's an artificially stupid participant. It clicks random buttons, enters random things into inputs and text boxes, drags range sliders to random values; basically stress testing your code.","title":"Debugging"},{"location":"tutorial/debug/#setup","text":"To run hemlock's custom debugging tool locally, you'll need Google Chrome and Chromedriver . Check out the setup page for your OS for specific instructions: Windows Windows Subsystem for Linux Mac Linux","title":"Setup"},{"location":"tutorial/debug/#basic-syntax","text":"Open your jupyter notebook and run the following: from hemlock import Debug as D , Input inpt = Input ( debug = D . send_keys ( 'Hello, World!' ) ) inpt . debug Out: [<send_keys('Hello, World!')>] You can add debug functions to a page or quesiton by settings its debug attribute or passing a debug argument to its constructor. Debug functions run when we run the debugger (in just a moment). As its name suggests, the send_keys debug function tells the AI participant to send keys to the input. Let's watch our debug function at work: from hemlock import Page from hemlock.tools import chromedriver driver = chromedriver () page = Page ( Input ( debug = D . send_keys ( 'Hello, World!' ) ), debug = D . debug_questions () ) page . preview ( driver ) page . _debug ( driver ) First, we use chromedriver to open Chromedriver with selenium python . Next, we create a page with our input question. By default, a page has two debug functions. The first runs its questions' debug functions, and the second clicks the forward or back button. Here, we just want the page to run the question's debug function, so we pass debug=D.debug_questions() to the page's constructor. Finally, we run the debug function. You'll notice it enters 'Hello, World!' in the input. After you're done, close the driver: driver . close () Tip You don't need to run _debug yourself in the survey. Hemlock takes care of this automatically for you. More debug functions send_keys is just one of many native hemlock debug functions .","title":"Basic syntax"},{"location":"tutorial/debug/#default-debug-functions","text":"We can attach debug functions to pages or questions. Most questions have a default debug function. For example, input questions have a default debug function which sends random ASCII characters to the input. Check out the default debug function at work: page = Page ( Input (), debug = D . debug_questions () ) page . preview ( driver ) page . _debug ( driver )","title":"Default debug functions"},{"location":"tutorial/debug/#custom-debug-functions","text":"We won't need custom debug functions for our survey, but you may need them elsewhere. Creating custom debug function is similar to creating custom compile, validate, submit, and navigate functions, with one important difference. While the functions you've seen take their parent as their first argument, debug functions take a selenium webdriver as their first argument and their parent as their second argument: Simple pattern: def my_debug_function ( driver , parent ): # your awesome debug function Input ( debug = my_debug_function ) Decorator pattern: @D . register def my_debug_function ( driver , parent , my_argument ): # your awesome debug function Input ( debug = D . my_debug_function ( my_argument ) ) Before writing custom debug functions, I recommend checking out the source code for inspiration.","title":"Custom debug functions"},{"location":"tutorial/debug/#run-the-debugger","text":"It's time to run hemlock's debugger through our app. Open another terminal window. As always, change to your project directory: $ cd $ cd my-first-project You should have three terminals open: one for jupyter, one for editing survey.py and running hlk serve , and now a third for running the debugger. In one of the terminal windows, run the hemlock app as usual ( hlk serve ). In the third terminal, run the debugger: $ hlk debug To run several AI participants through the survey, e.g. 3, use: $ hlk debug -n 3","title":"Run the debugger"},{"location":"tutorial/debug/#summary","text":"In this part of the tutorial, you learned how to debug your app with hemlock's custom debugging tool. In the next part of the tutorial, you'll learn how to deploy your application (i.e., put it on the web).","title":"Summary"},{"location":"tutorial/deploy/","text":"Deployment In the previous part of the tutorial, you learned how to debug your app with hemlock's custom debugging tool. In this part of the tutorial, you'll learn how to deploy your application (i.e., put it into production or put it on the web). Setup The easiest way to deploy web apps is with heroku . Hemlock-CLI builds on the heroku-CLI for deployment. Find the setup page for your OS for specific instructions: Windows Windows Subsystem for Linux Mac Linux Deploy using free resources for testing Before deploying your app 'for real', I recommend deploying it using free resources and going through the survey once or twice to make sure everything's working. If it works on my computer, why wouldn't it work online? You'll deploy your app with cloud computing resources (a server, database, etc.). The goal is for the cloud computing environment to match the environment on your computer (your local environment). Unfortunately, the cloud computing environment occasionally differs from your local environment. For example, you might have a python package installed on your computer which isn't in your requirements.txt file, so the cloud computing environment won't know to download it. This is why I recommend testing your app with free or cheap cloud computing resources before scaling it up. Deploying your application is as easy as: $ hlk deploy (You may have to give heroku access to your github account the first time you do this.) This opens a web page with the deployment information. Give your application an awesome name and click 'Deploy app' at the bottom of the page. Heroku needs about 2-4 minutes to set up your cloud computing environment. Use this time to reflect on the meaning of life. When it's done, head to https://my-awesome-app-name.herokuapp.com/ (replace 'my-awesome-app-name' with the name you gave to your application) to see your study online. Give it a few test runs and, when you're satisfied it's working, destroy it: $ heroku apps:destroy -a <your-awesome-app-name> You'll be prompted to confirm by re-typing the app name. Deploy for real We're finally ready to deploy our application for real . This is similar to what we just did, with a few small changes. First, open app.json : $ code app.json We're going to modify this to give us more powerful compute resources. At the top of the file, we'll change our addons and formation from: { \"addons\" : [ \"heroku-postgresql:hobby-dev\" ], \"formation\" : { \"web\" : { \"quantity\" : 1 , \"size\" : \"free\" } }, ... to: { \"addons\" : [ \"heroku-postgresql:standard-0\" ], \"formation\" : { \"web\" : { \"quantity\" : 10 , \"size\" : \"standard-1x\" } }, ... Save app.json . What just happened? app.json specifies the cloud computing resources we want to rent from heroku. The original file (the one you used to deploy your app the first time) used a free database ( \"heroku-postgresql:hobby-dev\" ) and a free web server ( \"size\": \"free\" ). The new file uses a more powerful database ( \"heroku-postgresql:standard-0\" ) and 10 more powerful web servers ( \"quantity\": 10, \"size\": \"standard-1x\" ). See here for more on heroku database (postgres) plans. See here for more on heroku servers (dynos). Let's deploy our app and set our configuration variables like we did before: $ hlk deploy Enter a name for your application. Set your PASSWORD . Like before, click 'Deploy app' at the bottom of the page. Congratulations! Your app is now online. Send it to your friends and family to show off your wizardly programming skills. Don't forget to download your data and destroy your application when you're finished: $ heroku apps:destroy -a <my-app-name> How much does this cost? How much will it cost me to play with my app for 15 min? Answer: $0.10. Calculation: This formation gives us a standard-0 database ($50/mo) and 10 standard-1x 'dynos' (like servers, $25/mo/dyno * 10 dynos = $250/mo). That's $300/mo total. Heroku prorates by the second, meaning that if you mess around with the app for 15 minutes, you'll be charged $300/mo * 1 mo/30 days * 1 day/24 hours * 1 hour/60 min * 15 min = $0.10. How much will it cost me to run a study? Answer: $5. Do the same math, but assume your study is online for half a day. The exact amount of compute power you need depends on the application. My recommendation for a standard-0 database and 10 standard-1x web dynos is a rough recommendation that will work well for most academic studies. Altnernative deployment options Hemlock uses a Flask backend, which means you can deploy it as you would any other Flask app. The Flask Mega-Tutorial is, imho, the best resource for learning Flask, including deployment. Summary Congratulations! You've made it through the hemlock tutorial. You can now initialize, modify, and deploy hemlock projects. On the next page, I talk about some extra bells and whistles you'll likely find helpful.","title":"Deployment"},{"location":"tutorial/deploy/#deployment","text":"In the previous part of the tutorial, you learned how to debug your app with hemlock's custom debugging tool. In this part of the tutorial, you'll learn how to deploy your application (i.e., put it into production or put it on the web).","title":"Deployment"},{"location":"tutorial/deploy/#setup","text":"The easiest way to deploy web apps is with heroku . Hemlock-CLI builds on the heroku-CLI for deployment. Find the setup page for your OS for specific instructions: Windows Windows Subsystem for Linux Mac Linux","title":"Setup"},{"location":"tutorial/deploy/#deploy-using-free-resources-for-testing","text":"Before deploying your app 'for real', I recommend deploying it using free resources and going through the survey once or twice to make sure everything's working. If it works on my computer, why wouldn't it work online? You'll deploy your app with cloud computing resources (a server, database, etc.). The goal is for the cloud computing environment to match the environment on your computer (your local environment). Unfortunately, the cloud computing environment occasionally differs from your local environment. For example, you might have a python package installed on your computer which isn't in your requirements.txt file, so the cloud computing environment won't know to download it. This is why I recommend testing your app with free or cheap cloud computing resources before scaling it up. Deploying your application is as easy as: $ hlk deploy (You may have to give heroku access to your github account the first time you do this.) This opens a web page with the deployment information. Give your application an awesome name and click 'Deploy app' at the bottom of the page. Heroku needs about 2-4 minutes to set up your cloud computing environment. Use this time to reflect on the meaning of life. When it's done, head to https://my-awesome-app-name.herokuapp.com/ (replace 'my-awesome-app-name' with the name you gave to your application) to see your study online. Give it a few test runs and, when you're satisfied it's working, destroy it: $ heroku apps:destroy -a <your-awesome-app-name> You'll be prompted to confirm by re-typing the app name.","title":"Deploy using free resources for testing"},{"location":"tutorial/deploy/#deploy-for-real","text":"We're finally ready to deploy our application for real . This is similar to what we just did, with a few small changes. First, open app.json : $ code app.json We're going to modify this to give us more powerful compute resources. At the top of the file, we'll change our addons and formation from: { \"addons\" : [ \"heroku-postgresql:hobby-dev\" ], \"formation\" : { \"web\" : { \"quantity\" : 1 , \"size\" : \"free\" } }, ... to: { \"addons\" : [ \"heroku-postgresql:standard-0\" ], \"formation\" : { \"web\" : { \"quantity\" : 10 , \"size\" : \"standard-1x\" } }, ... Save app.json . What just happened? app.json specifies the cloud computing resources we want to rent from heroku. The original file (the one you used to deploy your app the first time) used a free database ( \"heroku-postgresql:hobby-dev\" ) and a free web server ( \"size\": \"free\" ). The new file uses a more powerful database ( \"heroku-postgresql:standard-0\" ) and 10 more powerful web servers ( \"quantity\": 10, \"size\": \"standard-1x\" ). See here for more on heroku database (postgres) plans. See here for more on heroku servers (dynos). Let's deploy our app and set our configuration variables like we did before: $ hlk deploy Enter a name for your application. Set your PASSWORD . Like before, click 'Deploy app' at the bottom of the page. Congratulations! Your app is now online. Send it to your friends and family to show off your wizardly programming skills. Don't forget to download your data and destroy your application when you're finished: $ heroku apps:destroy -a <my-app-name> How much does this cost? How much will it cost me to play with my app for 15 min? Answer: $0.10. Calculation: This formation gives us a standard-0 database ($50/mo) and 10 standard-1x 'dynos' (like servers, $25/mo/dyno * 10 dynos = $250/mo). That's $300/mo total. Heroku prorates by the second, meaning that if you mess around with the app for 15 minutes, you'll be charged $300/mo * 1 mo/30 days * 1 day/24 hours * 1 hour/60 min * 15 min = $0.10. How much will it cost me to run a study? Answer: $5. Do the same math, but assume your study is online for half a day. The exact amount of compute power you need depends on the application. My recommendation for a standard-0 database and 10 standard-1x web dynos is a rough recommendation that will work well for most academic studies. Altnernative deployment options Hemlock uses a Flask backend, which means you can deploy it as you would any other Flask app. The Flask Mega-Tutorial is, imho, the best resource for learning Flask, including deployment.","title":"Deploy for real"},{"location":"tutorial/deploy/#summary","text":"Congratulations! You've made it through the hemlock tutorial. You can now initialize, modify, and deploy hemlock projects. On the next page, I talk about some extra bells and whistles you'll likely find helpful.","title":"Summary"},{"location":"tutorial/extensions/","text":"Extensions In the previous part of the tutorial, you learned how to add submit functions to pages and questions. In this part of the tutorial, you'll learn how to install and use hemlock extensions and other python packages. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. What are extensions and why should I use them? Building the demographics page took a while, didn't it? Now imagine making a new demographics page every time you make a survey for the rest of your life. Not fun. Instead, what if you could install a package to create a demographics page in one line of code? That's what hemlock extensions are for. Extensions package up commonly used questions, psychological scales, and other tools so you can download and use them simply and easily. Installation Install the hemlock-demographics extension like so: $ hlk install hemlock-demographics In general, you'll install hemlock extensions and other python packages with: $ hlk install <my-requested-package> Why use hlk install instead of pip install ? We've already installed python packages with pip install . Why use hlk install instead? It's good practice to use virtual environments for all your coding projects. hlk install automatically installs your new package in the correct virtual environment for your hemlock project. Deployment services like heroku (my recommended method) often need a requirements.txt file to know what packages to install to run your application. hlk install automatically updates your requirements files. A demographics page in one line of code Restart your jupyter notebook. In general, you need to restart jupyter notebook after installing new packages for the notebook to recognize them. Run the first cell to push the application context, then run: from hemlock_demographics import basic_demographics basic_demographics ( page = True ) . preview () Voila! A demographics page in one import and one line of code. The demographics package comes with several default groups of demographics questions. basic_demographics is one group. You can include the entire World Values Survey demographics questionnaire just as easily: from hemlock_demographics import comprehensive_demographics comprehensive_demographics ( page = True ) . preview () You can also customize your demographics page: from hemlock_demographics import demographics demographics ( 'gender' , 'age' , 'race' , 'children' , 'primary_wage_earner' , 'income_group' , page = True , require = True ) . preview () This time we also passed require=True , which requires participants to respond to every demographics question. You can read more about the demographics extension here . Demographics in our survey Here's your entire survey file: from hemlock import Branch , Label , Page , route from hemlock_demographics import basic_demographics @route ( '/survey' ) def start (): return Branch ( basic_demographics ( page = True , require = True ), Page ( Label ( 'Thank you for completing this survey!' ), terminal = True ) ) Run your app again to see what it looks like. Summary In this part of the tutorial, you created a demographics page using a hemlock extension. In the next part of the tutorial, you'll implement a confirmation page using compile functions.","title":"Extensions"},{"location":"tutorial/extensions/#extensions","text":"In the previous part of the tutorial, you learned how to add submit functions to pages and questions. In this part of the tutorial, you'll learn how to install and use hemlock extensions and other python packages. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. What are extensions and why should I use them? Building the demographics page took a while, didn't it? Now imagine making a new demographics page every time you make a survey for the rest of your life. Not fun. Instead, what if you could install a package to create a demographics page in one line of code? That's what hemlock extensions are for. Extensions package up commonly used questions, psychological scales, and other tools so you can download and use them simply and easily.","title":"Extensions"},{"location":"tutorial/extensions/#installation","text":"Install the hemlock-demographics extension like so: $ hlk install hemlock-demographics In general, you'll install hemlock extensions and other python packages with: $ hlk install <my-requested-package> Why use hlk install instead of pip install ? We've already installed python packages with pip install . Why use hlk install instead? It's good practice to use virtual environments for all your coding projects. hlk install automatically installs your new package in the correct virtual environment for your hemlock project. Deployment services like heroku (my recommended method) often need a requirements.txt file to know what packages to install to run your application. hlk install automatically updates your requirements files.","title":"Installation"},{"location":"tutorial/extensions/#a-demographics-page-in-one-line-of-code","text":"Restart your jupyter notebook. In general, you need to restart jupyter notebook after installing new packages for the notebook to recognize them. Run the first cell to push the application context, then run: from hemlock_demographics import basic_demographics basic_demographics ( page = True ) . preview () Voila! A demographics page in one import and one line of code. The demographics package comes with several default groups of demographics questions. basic_demographics is one group. You can include the entire World Values Survey demographics questionnaire just as easily: from hemlock_demographics import comprehensive_demographics comprehensive_demographics ( page = True ) . preview () You can also customize your demographics page: from hemlock_demographics import demographics demographics ( 'gender' , 'age' , 'race' , 'children' , 'primary_wage_earner' , 'income_group' , page = True , require = True ) . preview () This time we also passed require=True , which requires participants to respond to every demographics question. You can read more about the demographics extension here .","title":"A demographics page in one line of code"},{"location":"tutorial/extensions/#demographics-in-our-survey","text":"Here's your entire survey file: from hemlock import Branch , Label , Page , route from hemlock_demographics import basic_demographics @route ( '/survey' ) def start (): return Branch ( basic_demographics ( page = True , require = True ), Page ( Label ( 'Thank you for completing this survey!' ), terminal = True ) ) Run your app again to see what it looks like.","title":"Demographics in our survey"},{"location":"tutorial/extensions/#summary","text":"In this part of the tutorial, you created a demographics page using a hemlock extension. In the next part of the tutorial, you'll implement a confirmation page using compile functions.","title":"Summary"},{"location":"tutorial/extra/","text":"Bells and whistles You already know the important stuff. Here are some tips and tricks to make your life easier. Redis One of hemlock's most impressive features is seamless integration with Redis for running complex background processes during surveys. Read more here . Settings We can use settings to change the default values of most attributes of most hemlock objects (see the API documentation for precise details). For example, let's add a back button to every page by default: from hemlock import Page , settings settings [ 'Page' ] . update ({ 'back' : True }) Page () . preview () Duplicates We often want to block the same participant from going through our survey multiple times. We do this with the duplicate_keys setting. This blocks visitors who match participants who've already completed the study on certain keys. For example: from hemlock import settings settings . update ({ 'duplicate_keys' : [ 'IPv4' , 'workerId' ]}) This blocks participants who match existing participants on IP address (IPv4) or their MTurk workerId. Screenouts We may also want to screen out participants, e.g. if they've participated in similar studies we've run in the past. We do this by 1) uploading a file called screenouts.csv to the root directory of our hemlock project. The top row of the csv are keys on which we want to screen (much like the duplicate keys we saw above). Then modify the screenout_keys setting: from hemlock import settings settings . update ({ 'screenout_keys' : [ 'IPv4' , 'workerId' ]})","title":"Bells and whistles"},{"location":"tutorial/extra/#bells-and-whistles","text":"You already know the important stuff. Here are some tips and tricks to make your life easier.","title":"Bells and whistles"},{"location":"tutorial/extra/#redis","text":"One of hemlock's most impressive features is seamless integration with Redis for running complex background processes during surveys. Read more here .","title":"Redis"},{"location":"tutorial/extra/#settings","text":"We can use settings to change the default values of most attributes of most hemlock objects (see the API documentation for precise details). For example, let's add a back button to every page by default: from hemlock import Page , settings settings [ 'Page' ] . update ({ 'back' : True }) Page () . preview ()","title":"Settings"},{"location":"tutorial/extra/#duplicates","text":"We often want to block the same participant from going through our survey multiple times. We do this with the duplicate_keys setting. This blocks visitors who match participants who've already completed the study on certain keys. For example: from hemlock import settings settings . update ({ 'duplicate_keys' : [ 'IPv4' , 'workerId' ]}) This blocks participants who match existing participants on IP address (IPv4) or their MTurk workerId.","title":"Duplicates"},{"location":"tutorial/extra/#screenouts","text":"We may also want to screen out participants, e.g. if they've participated in similar studies we've run in the past. We do this by 1) uploading a file called screenouts.csv to the root directory of our hemlock project. The top row of the csv are keys on which we want to screen (much like the duplicate keys we saw above). Then modify the screenout_keys setting: from hemlock import settings settings . update ({ 'screenout_keys' : [ 'IPv4' , 'workerId' ]})","title":"Screenouts"},{"location":"tutorial/first_project/","text":"Your first project By the end of this part of the tutorial, you'll be able to initialize a new hemlock project and create and preview hemlock survey pages. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Getting started I've written setup pages for different operating systems (OS) below. You don't need everything in the setup page right now. First, read this list of things you need. Then, check out the setup page for your OS for download and installation instructions. What you need to get started: Git and github (and a github authentication token) Python3 and pip3 Hemlock-CLI Visual studio code Jupyter Google chrome Check out the setup page for your OS: Windows Windows Subsystem for Linux Mac Linux Initialize a new hemlock project Run the following, replacing <my-github-username> with your github username and <my-github-token> with your github authentication token: $ hlk init my-first-project <my-github-username> <my-github-token> For example, I would enter: $ hlk init my-first-project dsbowen bts4rxpmw2x6tsy2qel1y7p5hwmhd7wxopmk5vsp (This isn't my real authentication token!) This will 'clone' the template into a folder my-first-project , initialize an eponymous github repository for your project, and set up a virtual environment. Change into the project directory and setup your virtual environment: $ cd my-first-project $ hlk setup-venv <my-operating-system> # replace <my-operating-system> with win, mac, linux, or wsl Note You will only have to run hlk init and hlk setup-venv once per project. Cannot uninstall PyYAML To fix this, run: $ pip install --ignore-installed pyyaml Preview a page in jupyter notebook Jupyter notebook is a great tool for iterating quickly on project designs. I recommend using it for most of your work. Open the jupyter dashboard with: $ jupyter notebook Jupyter will attempt to open the dashboard automatically in your browser. If this fails, the terminal window will show you links to the dashboard that you can manually copy and paste into your browser. Open the file named blackboard.ipynb . You may be propted to choose a 'kernel' when you open blackboard.ipynb . If so, choose 'my-first-project' (in general, your project name). If you aren't prompted to choose a kernel, manually change the kernel to 'my-first-project'. At the top of the notebook click Kernel >> Change kernel >> my-first-project . Run the first cell (Shift + Enter) to set up the environment and application context. It's not important to what it does right now. Now, create your first hemlock page. In a new code cell below the first one, enter the following: from hemlock import Page , Label p = Page ( Label ( 'Hello, World!' ) ) p . preview () This should automatically open a preview of your page in your browser. Troubleshooting if the page didn't open Underneath the cell you just ran is a file path ending in preview.html . This is the location of your preview file. Copy and paste this into your browser. Code explanation The first line simply imports Page and Label objects. The next line, p = Page(Label('Hello, World!')) , creates a Page instance. A Page contains a list of 'questions' which it displays to participants. We can set a page's questions by passing them as arguments to the Page constructor. Alternatively, we can set a page's questions by setting the page's questions attribute, meaning that the following are equivalent: p = Page ( Label ( 'Label 0' ), Label ( 'Label 1' ) ) p = Page () p . questions = [ Label ( 'Label 0' ), Label ( 'Label 1' ) ] The page's question is a Label , although this is in some sense a misnomer because label objects only contains text. The first argument to Label is a string, written in markdown, which the label object displays on its page. Markdown Hemlock expects text which appears on the page, such as labels and error messages, to be markdown formatted. Markdown is exceptionally easy to use. Check out this basic syntax guide for more details. Summary In this part of the tutorial, you learned how to initialize a new hemlock project and create and preview a page. In the next part of the tutorial, you'll learn how to run a hemlock application locally.","title":"Your first project"},{"location":"tutorial/first_project/#your-first-project","text":"By the end of this part of the tutorial, you'll be able to initialize a new hemlock project and create and preview hemlock survey pages. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Your first project"},{"location":"tutorial/first_project/#getting-started","text":"I've written setup pages for different operating systems (OS) below. You don't need everything in the setup page right now. First, read this list of things you need. Then, check out the setup page for your OS for download and installation instructions. What you need to get started: Git and github (and a github authentication token) Python3 and pip3 Hemlock-CLI Visual studio code Jupyter Google chrome Check out the setup page for your OS: Windows Windows Subsystem for Linux Mac Linux","title":"Getting started"},{"location":"tutorial/first_project/#initialize-a-new-hemlock-project","text":"Run the following, replacing <my-github-username> with your github username and <my-github-token> with your github authentication token: $ hlk init my-first-project <my-github-username> <my-github-token> For example, I would enter: $ hlk init my-first-project dsbowen bts4rxpmw2x6tsy2qel1y7p5hwmhd7wxopmk5vsp (This isn't my real authentication token!) This will 'clone' the template into a folder my-first-project , initialize an eponymous github repository for your project, and set up a virtual environment. Change into the project directory and setup your virtual environment: $ cd my-first-project $ hlk setup-venv <my-operating-system> # replace <my-operating-system> with win, mac, linux, or wsl Note You will only have to run hlk init and hlk setup-venv once per project. Cannot uninstall PyYAML To fix this, run: $ pip install --ignore-installed pyyaml","title":"Initialize a new hemlock project"},{"location":"tutorial/first_project/#preview-a-page-in-jupyter-notebook","text":"Jupyter notebook is a great tool for iterating quickly on project designs. I recommend using it for most of your work. Open the jupyter dashboard with: $ jupyter notebook Jupyter will attempt to open the dashboard automatically in your browser. If this fails, the terminal window will show you links to the dashboard that you can manually copy and paste into your browser. Open the file named blackboard.ipynb . You may be propted to choose a 'kernel' when you open blackboard.ipynb . If so, choose 'my-first-project' (in general, your project name). If you aren't prompted to choose a kernel, manually change the kernel to 'my-first-project'. At the top of the notebook click Kernel >> Change kernel >> my-first-project . Run the first cell (Shift + Enter) to set up the environment and application context. It's not important to what it does right now. Now, create your first hemlock page. In a new code cell below the first one, enter the following: from hemlock import Page , Label p = Page ( Label ( 'Hello, World!' ) ) p . preview () This should automatically open a preview of your page in your browser. Troubleshooting if the page didn't open Underneath the cell you just ran is a file path ending in preview.html . This is the location of your preview file. Copy and paste this into your browser.","title":"Preview a page in jupyter notebook"},{"location":"tutorial/first_project/#code-explanation","text":"The first line simply imports Page and Label objects. The next line, p = Page(Label('Hello, World!')) , creates a Page instance. A Page contains a list of 'questions' which it displays to participants. We can set a page's questions by passing them as arguments to the Page constructor. Alternatively, we can set a page's questions by setting the page's questions attribute, meaning that the following are equivalent: p = Page ( Label ( 'Label 0' ), Label ( 'Label 1' ) ) p = Page () p . questions = [ Label ( 'Label 0' ), Label ( 'Label 1' ) ] The page's question is a Label , although this is in some sense a misnomer because label objects only contains text. The first argument to Label is a string, written in markdown, which the label object displays on its page. Markdown Hemlock expects text which appears on the page, such as labels and error messages, to be markdown formatted. Markdown is exceptionally easy to use. Check out this basic syntax guide for more details.","title":"Code explanation"},{"location":"tutorial/first_project/#summary","text":"In this part of the tutorial, you learned how to initialize a new hemlock project and create and preview a page. In the next part of the tutorial, you'll learn how to run a hemlock application locally.","title":"Summary"},{"location":"tutorial/intro/","text":"Introduction This tutorial will guide you through the essentials of hemlock. By the end of it, you'll be able to initialize hemlock projects, create powerful experiments and surveys, and deploy them on the web. Start with the end product in mind When learning to program - or anything else - start with the end product in mind. This is my spin-off of Covey's start with the end in mind , where the end is something you've produced rather than knowledge you've acquired. I personally find that aiming at a product makes me more knowledgable about a topic than aiming at knowledge itself. In this spirit, our goal is to create a behavioral study in which participants play an ultimatum game with each other in real time. You can see the end product here: https://hemlock-tutorial.herokuapp.com/ . The complete survey code is on github . The ultimatum game is famous; studied in hundreds of academic papers in disciplines such as game theory, behavioral economics, experimental economics, marketing, psychology, sociology, and neuroscience. It involves two players; a proposer and a responder . We begin by endowing the proposer with a 'pot' of (usually) money, e.g. $20. The proposer then proposes a 'split' of the pot between him/herself and the responder (e.g. I get $15, you get $5 ). The responder can accept or reject the proposed split. If the responder accepts, the pot is split according to the proposal (e.g. proposer gets $15, responder gets $5). If the responder rejects the proposal, both players get nothing. With nearly 2000 citations, this 1991 American Economic Review paper studies how play evolves over successive rounds. It finds that proposers usually make 'fair' offers (about a 50-50 split), and responders usually reject unfair offers, in early rounds. As the game continues, proposers make more unfair offers, and responders are more accepting of them. The study we'll make in the hemlock tutorial is designed to replicate this finding. Prerequisites This tutorial assumes a very basic knowledge of two programming languages: bash and python. Tutorials There are a thousand excellent 'bash/python for beginners' tutorials online. The following should teach you enough bash and python to get started with hemlock in about 1-2 hours. Read up to 'Viewing Files' in this bash tutorial . Complete up to Lesson 15 in code the blocks . Learn how dictionaries work in thinkcspy . What to do if something doesn't make sense If and when you run into something which doesn't make sense to you, try the following: Keep going. As best you can, press on with the tutorial. You don't have to 100% understand what's going on to get things working. You'll also find that things which don't make sense now often 'fall into place' just a short while later. Look it up. I've done my best to write a clear, thorough tutorial. But no tutorial is comprehensive. If you run into something so puzzling that you can't just keep going, look it up! The internet is inundated with great programming resources.","title":"Introduction"},{"location":"tutorial/intro/#introduction","text":"This tutorial will guide you through the essentials of hemlock. By the end of it, you'll be able to initialize hemlock projects, create powerful experiments and surveys, and deploy them on the web.","title":"Introduction"},{"location":"tutorial/intro/#start-with-the-end-product-in-mind","text":"When learning to program - or anything else - start with the end product in mind. This is my spin-off of Covey's start with the end in mind , where the end is something you've produced rather than knowledge you've acquired. I personally find that aiming at a product makes me more knowledgable about a topic than aiming at knowledge itself. In this spirit, our goal is to create a behavioral study in which participants play an ultimatum game with each other in real time. You can see the end product here: https://hemlock-tutorial.herokuapp.com/ . The complete survey code is on github . The ultimatum game is famous; studied in hundreds of academic papers in disciplines such as game theory, behavioral economics, experimental economics, marketing, psychology, sociology, and neuroscience. It involves two players; a proposer and a responder . We begin by endowing the proposer with a 'pot' of (usually) money, e.g. $20. The proposer then proposes a 'split' of the pot between him/herself and the responder (e.g. I get $15, you get $5 ). The responder can accept or reject the proposed split. If the responder accepts, the pot is split according to the proposal (e.g. proposer gets $15, responder gets $5). If the responder rejects the proposal, both players get nothing. With nearly 2000 citations, this 1991 American Economic Review paper studies how play evolves over successive rounds. It finds that proposers usually make 'fair' offers (about a 50-50 split), and responders usually reject unfair offers, in early rounds. As the game continues, proposers make more unfair offers, and responders are more accepting of them. The study we'll make in the hemlock tutorial is designed to replicate this finding.","title":"Start with the end product in mind"},{"location":"tutorial/intro/#prerequisites","text":"This tutorial assumes a very basic knowledge of two programming languages: bash and python.","title":"Prerequisites"},{"location":"tutorial/intro/#tutorials","text":"There are a thousand excellent 'bash/python for beginners' tutorials online. The following should teach you enough bash and python to get started with hemlock in about 1-2 hours. Read up to 'Viewing Files' in this bash tutorial . Complete up to Lesson 15 in code the blocks . Learn how dictionaries work in thinkcspy .","title":"Tutorials"},{"location":"tutorial/intro/#what-to-do-if-something-doesnt-make-sense","text":"If and when you run into something which doesn't make sense to you, try the following: Keep going. As best you can, press on with the tutorial. You don't have to 100% understand what's going on to get things working. You'll also find that things which don't make sense now often 'fall into place' just a short while later. Look it up. I've done my best to write a clear, thorough tutorial. But no tutorial is comprehensive. If you run into something so puzzling that you can't just keep going, look it up! The internet is inundated with great programming resources.","title":"What to do if something doesn't make sense"},{"location":"tutorial/navigate/","text":"Navigate In the previous part of the tutorial, you implemented a confirmation page using compile functions. By the end of this part of the tutorial, you'll be able to set up navigation between branches. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why navigate functions? Navigate functions move participants through different branches of the survey. For example, participants in the control group might follow one branch, while participants in the treatment group follow another. In our case, we'll use a navigate function to bring participants from the demographics branch of our survey to an 'utlimatum game' branch. In this branch, participants will play an ultimatum game with each other. Visualizing the 'branch stack' We'll start by visualizing a participant's 'branch stack'. Open your jupter notebook and run the following: from hemlock import Branch , Page , Participant def start (): return Branch ( Page (), Page ( terminal = True ) ) part = Participant . gen_test_participant ( start ) part . view_nav () Out: <Branch 1> <Page 1> C <Page 2> T C = current page T = terminal page part.view_nav() prints the participant's branch stack. Right now there's only one branch in the stack (the one returned by start ). The branch has two pages. The participant is currently on the first page. The terminal survey page is the next page, at the end of the branch. Basic syntax You can add a navigation to a branch or page the same we we added validate, submit, and compile functions to pages and questions - by setting its navigate attribute or passing a navigate argument to its constructor. def start (): return Branch ( Page (), Page (), navigate = end ) def end ( start_branch ): return Branch ( Page ( terminal = True ) ) part = Participant . gen_test_participant ( start ) part . view_nav () Out: <Branch 2> <Page 3> C <Page 4> The navigate function end takes the start branch (the branch returned by start ) as its first argument. In general, navigate functions take an 'origin' branch or page as their first argument. Navigate functions return a Branch object. Let's make our test participant navigate forward and view the navigation again: part . forward () . view_nav () Out: <Branch 2> <Page 3> <Page 4> C And again: part . forward () . view_nav () Out: <Branch 2> <Page 3> <Page 4> <Branch (transient 139923798691696)> <Page (transient 139922995840960)> C T What happened? Our participant reached the end of the start branch and navigated to the end branch. It's currently on the first page of the end branch, which is the last (terminal) page of the survey. Tip You don't need to run forward yourself in the survey. Hemlock takes care of this automatically for you. Decorator pattern Like validate, submit, and compile functions, we can add navigate functions using the simple pattern or the decorator pattern. We can re-write the above navigate functions using the decorator pattern like this: from hemlock import Navigate as N def start (): return Branch ( Page (), Page (), navigate = N . end () ) @N . register def end ( start_branch ): return Branch ( Page ( terminal = True ) ) Branching off pages Branching off of branches allows us to navigate to a new branch at the end of our current branch. But sometimes we'll want to navigate to a new branch from the middle of our current branch. To do this, we'll branch off of a page. This time, instead of attaching the navigate function to the branch, we'll attach it to the first page of the branch: def start (): return Branch ( Page ( navigate = middle ), Page ( terminal = True ) ) def middle ( first_page ): return Branch ( Page () ) part = Participant . gen_test_participant ( start ) As before, run part.view_nav() and part.forward() a few times. This is what you'll see: <Branch 5> <Page 8> C <Page 9> T <Branch 5> <Page 8> <Branch (transient 140643401377680)> <Page (transient 140643401377200)> C <Page 9> T <Branch 5> <Page 8> <Branch (transient 140643401377680)> <Page (transient 140643401377200)> <Page 9> C T What happened? We started on the first page of the start branch. Then, we branched off of the first page to the middle (the branch returned by middle ). At the end of the middle branch, we picked up where we left off on the start branch. Navigating back You'll often want to allow participants to navigate to a previous page. To do this, simply set a page's back attribute to True , or pass back=True to a page's constructor. You can also navigate backward in the notebook. Run this line a few times: part . back () . view_nav () Out: <Branch 5> <Page 8> <Branch (transient 140643401377680)> <Page (transient 140643401377200)> C <Page 9> T <Branch 5> <Page 8> C <Page 9> T Navigation in our app Now that we've seen how to add navigate functions in our notebook, let's add it to our app. In survey.py : ... @route ( '/survey' ) def start (): demographics_page = basic_demographics ( page = True , require = True ) return Branch ( ... navigate = ultimatum_game ) ... def ultimatum_game ( start_branch ): return Branch ( Page ( Label ( 'You are about to play an ultimatum game...' ) ), Page ( Label ( 'Thank you for completing this survey!' ), terminal = True ) ) Run the app again and navigate past the demographics page. You'll find yourself on our new ultimatum game branch. Summary In this part of the tutorial, you learned how to navigate between branches. In the next part of the tutorial, we'll tie together some of the things you've learned about page logic.","title":"Navigate"},{"location":"tutorial/navigate/#navigate","text":"In the previous part of the tutorial, you implemented a confirmation page using compile functions. By the end of this part of the tutorial, you'll be able to set up navigation between branches. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why navigate functions? Navigate functions move participants through different branches of the survey. For example, participants in the control group might follow one branch, while participants in the treatment group follow another. In our case, we'll use a navigate function to bring participants from the demographics branch of our survey to an 'utlimatum game' branch. In this branch, participants will play an ultimatum game with each other.","title":"Navigate"},{"location":"tutorial/navigate/#visualizing-the-branch-stack","text":"We'll start by visualizing a participant's 'branch stack'. Open your jupter notebook and run the following: from hemlock import Branch , Page , Participant def start (): return Branch ( Page (), Page ( terminal = True ) ) part = Participant . gen_test_participant ( start ) part . view_nav () Out: <Branch 1> <Page 1> C <Page 2> T C = current page T = terminal page part.view_nav() prints the participant's branch stack. Right now there's only one branch in the stack (the one returned by start ). The branch has two pages. The participant is currently on the first page. The terminal survey page is the next page, at the end of the branch.","title":"Visualizing the 'branch stack'"},{"location":"tutorial/navigate/#basic-syntax","text":"You can add a navigation to a branch or page the same we we added validate, submit, and compile functions to pages and questions - by setting its navigate attribute or passing a navigate argument to its constructor. def start (): return Branch ( Page (), Page (), navigate = end ) def end ( start_branch ): return Branch ( Page ( terminal = True ) ) part = Participant . gen_test_participant ( start ) part . view_nav () Out: <Branch 2> <Page 3> C <Page 4> The navigate function end takes the start branch (the branch returned by start ) as its first argument. In general, navigate functions take an 'origin' branch or page as their first argument. Navigate functions return a Branch object. Let's make our test participant navigate forward and view the navigation again: part . forward () . view_nav () Out: <Branch 2> <Page 3> <Page 4> C And again: part . forward () . view_nav () Out: <Branch 2> <Page 3> <Page 4> <Branch (transient 139923798691696)> <Page (transient 139922995840960)> C T What happened? Our participant reached the end of the start branch and navigated to the end branch. It's currently on the first page of the end branch, which is the last (terminal) page of the survey. Tip You don't need to run forward yourself in the survey. Hemlock takes care of this automatically for you. Decorator pattern Like validate, submit, and compile functions, we can add navigate functions using the simple pattern or the decorator pattern. We can re-write the above navigate functions using the decorator pattern like this: from hemlock import Navigate as N def start (): return Branch ( Page (), Page (), navigate = N . end () ) @N . register def end ( start_branch ): return Branch ( Page ( terminal = True ) )","title":"Basic syntax"},{"location":"tutorial/navigate/#branching-off-pages","text":"Branching off of branches allows us to navigate to a new branch at the end of our current branch. But sometimes we'll want to navigate to a new branch from the middle of our current branch. To do this, we'll branch off of a page. This time, instead of attaching the navigate function to the branch, we'll attach it to the first page of the branch: def start (): return Branch ( Page ( navigate = middle ), Page ( terminal = True ) ) def middle ( first_page ): return Branch ( Page () ) part = Participant . gen_test_participant ( start ) As before, run part.view_nav() and part.forward() a few times. This is what you'll see: <Branch 5> <Page 8> C <Page 9> T <Branch 5> <Page 8> <Branch (transient 140643401377680)> <Page (transient 140643401377200)> C <Page 9> T <Branch 5> <Page 8> <Branch (transient 140643401377680)> <Page (transient 140643401377200)> <Page 9> C T What happened? We started on the first page of the start branch. Then, we branched off of the first page to the middle (the branch returned by middle ). At the end of the middle branch, we picked up where we left off on the start branch.","title":"Branching off pages"},{"location":"tutorial/navigate/#navigating-back","text":"You'll often want to allow participants to navigate to a previous page. To do this, simply set a page's back attribute to True , or pass back=True to a page's constructor. You can also navigate backward in the notebook. Run this line a few times: part . back () . view_nav () Out: <Branch 5> <Page 8> <Branch (transient 140643401377680)> <Page (transient 140643401377200)> C <Page 9> T <Branch 5> <Page 8> C <Page 9> T","title":"Navigating back"},{"location":"tutorial/navigate/#navigation-in-our-app","text":"Now that we've seen how to add navigate functions in our notebook, let's add it to our app. In survey.py : ... @route ( '/survey' ) def start (): demographics_page = basic_demographics ( page = True , require = True ) return Branch ( ... navigate = ultimatum_game ) ... def ultimatum_game ( start_branch ): return Branch ( Page ( Label ( 'You are about to play an ultimatum game...' ) ), Page ( Label ( 'Thank you for completing this survey!' ), terminal = True ) ) Run the app again and navigate past the demographics page. You'll find yourself on our new ultimatum game branch.","title":"Navigation in our app"},{"location":"tutorial/navigate/#summary","text":"In this part of the tutorial, you learned how to navigate between branches. In the next part of the tutorial, we'll tie together some of the things you've learned about page logic.","title":"Summary"},{"location":"tutorial/page_logic/","text":"Page logic Now that you've seen compile, validate, submit, and navigate functions, it's time to discuss the logic of hemlock pages. It's not important to fully understand this now, as long as you have a rough sense of the order in which things happen. Compile. The page executes its compile functions. By default, a page's first compile function runs its questions' compile functions. Render. The page HTML is rendered and displayed to the participant. Record responses. When the participant submits a page, we record their responses to every question on the page. This sets the questions' response attribute. Validate. After recording all responses, the page executes its validate functions. By default, a page's first validate function runs its questions' validate functions. When a page or question executes its validate functions, it does so one by one, and if any of them uncover an error (i.e., return a string instead of None ), validation for that object stops. For example, suppose we attach two validate functions with Input(validate=[V.require(), V.match('Hello, *!')]) . When the input question runs its validate functions, the first validate function checks that the participant entered a response. Only if they entered a response does the second validate function check that the participant's response matches the pattern 'Hello, *!' . Record data. The page records the data associated with the participant's responses to every question on the page. This sets the questions' data attribute. Submit. The page executes its submit functions. By default, a page's first submit function runs its questions' submit functions. Navigate. If the page has a navigate function, execute the function and bring the participant to the start of the new branch the function returns. If the page has no navigate function, and the participant has reached the end a a branch, the branch executes its navigate function and brings the participant to the start of the new branch returned by the function. You can visualize compile functions (validate and submit functions are similar) as follows: Page 1 compile function 1 Question 1 compile function 1 Question 1 compile function 2 ... Question 2 compile function 1 Question 2 compile function 2 ... Page 1 compile function 2 ... In the next part of the tutorial, we'll give our participants instructions on how to play the ultimatum game and verify their understanding with a comprehension check.","title":"Page logic"},{"location":"tutorial/page_logic/#page-logic","text":"Now that you've seen compile, validate, submit, and navigate functions, it's time to discuss the logic of hemlock pages. It's not important to fully understand this now, as long as you have a rough sense of the order in which things happen. Compile. The page executes its compile functions. By default, a page's first compile function runs its questions' compile functions. Render. The page HTML is rendered and displayed to the participant. Record responses. When the participant submits a page, we record their responses to every question on the page. This sets the questions' response attribute. Validate. After recording all responses, the page executes its validate functions. By default, a page's first validate function runs its questions' validate functions. When a page or question executes its validate functions, it does so one by one, and if any of them uncover an error (i.e., return a string instead of None ), validation for that object stops. For example, suppose we attach two validate functions with Input(validate=[V.require(), V.match('Hello, *!')]) . When the input question runs its validate functions, the first validate function checks that the participant entered a response. Only if they entered a response does the second validate function check that the participant's response matches the pattern 'Hello, *!' . Record data. The page records the data associated with the participant's responses to every question on the page. This sets the questions' data attribute. Submit. The page executes its submit functions. By default, a page's first submit function runs its questions' submit functions. Navigate. If the page has a navigate function, execute the function and bring the participant to the start of the new branch the function returns. If the page has no navigate function, and the participant has reached the end a a branch, the branch executes its navigate function and brings the participant to the start of the new branch returned by the function. You can visualize compile functions (validate and submit functions are similar) as follows: Page 1 compile function 1 Question 1 compile function 1 Question 1 compile function 2 ... Question 2 compile function 1 Question 2 compile function 2 ... Page 1 compile function 2 ... In the next part of the tutorial, we'll give our participants instructions on how to play the ultimatum game and verify their understanding with a comprehension check.","title":"Page logic"},{"location":"tutorial/proposer_branch/","text":"Proposer branch In the previous part of the tutorial, you learned how to randomly assign participants to conditions. In this part of the tutorial, you'll implement the proposer branch of the ultimatum game. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Note This is the most difficult part of the tutorial. It uses advanced techniques that you'll rarely need. Don't sweat the details here. Try to get the gist of what's going on and feel free to 'cheat' by copying and pasting liberally. Brace yourself. Deep breath... jump in. Aside on fill-in-the-blank inputs We're going to ask proposers to make their proposals by filling in a blank. Open your notebook and run this: from hemlock import Blank , Page Page ( Blank ( ( 'Hello, ' , '!' ), blank_empty = '_____' ) ) . preview () Note that the blank's first argument isn't a string like we're used to seeing. Instead, it's a tuple. Whatever the participant enters in the input field gets inserted in between the tuple entries. A key attribute of blanks is blank_empty . This is what fills in the blank when the participant's response is empty. Aside on progress bars Each participant plays several rounds of the ultimatum game. It's common courtesy to inform participants of how far along they are in your survey. We can use a progress bar for this: from hemlock import Label from hemlock.tools import progress Page ( Label ( progress ( 2 / 5 )) ) . preview () The first argument to progress is how far along the participant is. The (optional) second argument to progress customizes the text: Page ( Label ( progress ( 2 / 5 , 'Round 3 of 5' )) ) . preview () The proposal page We're ready to create a page where the proposer will input the proposed split. Enter the following in your jupyter notebook: N_ROUNDS = 5 POT = 20 i = 1 Page ( Label ( progress ( i / N_ROUNDS , 'Round {} of {} ' . format ( i + 1 , N_ROUNDS )) ), Blank ( ( ''' You have $ {} to split between you and the responder. Fill in the blank: I would like to offer the responder **$''' . format ( POT ), '.00**.' ), prepend = '$' , append = '.00' , var = 'Proposal' , blank_empty = '__' , type = 'number' , min = 0 , max = POT , required = True ) ) . preview () Finding a responder We can use the SQLAlchemy Query API to pair the proposer with a random responder this round. First, we create an input with variable name 'Response' and data 5 : from hemlock import db response = Blank ( var = 'Response' , data = 5 ) db . session . add ( response ) db . session . flush ([ response ]) response Out: <Blank 1> Next, we get all Blank objects in the database with the variable name 'Response' whose data is not None : responses = Blank . query . filter ( Blank . var == 'Response' , Blank . data != None ) . all () responses Out: [<Blank 1>] Finally, we choose one of these inputs randomly and get its data: import random random . choice ( responses ) . data Out: 5 Displaying the proposer outcome Now we want to display the outcome of the round to the proposer. This calls for a compile function: from hemlock import Compile as C , Embedded from random import randint @C . register def display_proposer_outcome ( outcome_label , proposal_input ): # get the proposal proposal = POT - proposal_input . data , proposal_input . data # get all responses responses = Blank . query . filter ( Blank . var == 'Response' , Blank . data != None ) . all () if responses : # randomly choose a response response = random . choice ( responses ) . data else : # no responses are available # e.g. if this is the first participant response = randint ( 0 , POT ) # compute the payoff accept = response <= proposal [ 1 ] payoff = proposal if accept else ( 0 , 0 ) # record results as embedded data outcome_label . page . embedded = [ Embedded ( 'Response' , response ), Embedded ( 'Accept' , int ( accept )), Embedded ( 'ProposerPayoff' , payoff [ 0 ]), Embedded ( 'ResponderPayoff' , payoff [ 1 ]) ] # describe the outcome of the round outcome_label . label = ''' You proposed the following split: - You: $ {} - Responder: $ {} The responder said they will accept any proposal which gives them at least $ {} . **Your proposal was {} , giving you a payoff of $ {} .** ''' . format ( proposal [ 0 ], proposal [ 1 ], response , 'accepted' if accept else 'rejected' , payoff [ 0 ] ) Let's go through this step by step. First, we get the proposal from the proposal input question. Remember that we converted the data for this input to an integer using a submit function. The data for this input is the amount of money the proposer offered to the responder, meaning that the proposed split is (POT-proposal_input.data, proposal_input.data) . Second, we use the Query API to randomly select a response input question. We modify our above code to account for the fact that, if the first participant is a proposer, there won't be any responses to choose from. So, if our query can't find any response input questions, we return a random response. Third, we compute the payoff and record the results of the round using embedded data. Finally, we set the outcome label's label attribute to display the outcome of the round. Let's see what the proposer outcome would have been if they had offered $10 to the responder: page = Page ( Label ( compile = C . display_proposer_outcome ( Blank ( data = 10 )) ) ) page . _compile () page . preview () Notice that the outcome of the round is recorded in the proposer's outcome page's embedded data: [( e . var , e . data ) for e in page . embedded ] Out: [('Response', 5), ('Accept', 1), ('ProposerPayoff', 10), ('ResponderPayoff', 10)] What would the proposer outcome have been if they had offered $4 to the responder? page = Page ( Label ( compile = C . display_proposer_outcome ( Blank ( data = 4 )) ) ) page . _compile () page . preview () In: [( e . var , e . data ) for e in page . embedded ] Out: [('Response', 5), ('Accept', 0), ('ProposerPayoff', 0), ('ResponderPayoff', 0)] Adding the proposer branch to our survey Imports We'll begin by updating our imports: from hemlock import ( Blank , Branch , Compile as C , Embedded , Input , Label , Page , Validate as V , Submit as S , route ) from hemlock.tools import Assigner , comprehension_check , join , progress from hemlock_demographics import basic_demographics import random from random import randint ... Navigating to the proposer branch Next we'll modify the ultimatum game branch to navigate to the proposer branch if the participant was assigned to be a proposer. In survey.py : ... def ultimatum_game ( start_branch ): proposer = assigner . next ()[ 'Proposer' ] return Branch ( ... Page ( Label ( ''' You are about to play an ultimatum game as a <b>{}</b>. ''' . format ( 'proposer' if proposer else 'responder' ) ) ), navigate = proposer_branch ) ... The proposer branch navigate function Next we'll add our proposer navigate function to the bottom of survey.py : ... def proposer_branch ( ug_branch ): branch = Branch ( navigate = end ) for i in range ( N_ROUNDS ): proposal_input = Blank ( ( ''' You have $ {} to split between you and the responder. Fill in the blank: I would like to offer the responder **$''' . format ( POT ), '.00**.' ), prepend = '$' , append = '.00' , var = 'Proposal' , blank_empty = '__' , type = 'number' , min = 0 , max = POT , required = True ) branch . pages += [ Page ( Label ( progress ( i / N_ROUNDS , 'Round {} of {} ' . format ( i + 1 , N_ROUNDS ) )), proposal_input ), Page ( Label ( compile = C . display_proposer_outcome ( proposal_input ) ) ) ] return branch This navigate function simply adds two pages to the proposer branch for each of N_ROUNDS . The first page asks the proposer to propose a split. The second page displays the outcome of the round. Displaying the proposer outcome Next, we'll add the display_proposer_outcome function we wrote in our notebook: ... @C . register def display_proposer_outcome ( outcome_label , proposal_input ): # AS IN THE NOTEBOOK Ending the survey Finally, we'll add a function to take the participant to the completion page: def end ( rounds_branch ): return Branch ( Page ( Label ( 'Thank you for completing the survey!' ), terminal = True ) ) Run the app and see what the survey looks like in the proposer condition. Summary In this part of the tutorial, you implemented the proposer branch. Give yourself a giant pat on the back. You're officially a hemlock expert. The rest will smooth sailing. In the next part of the tutorial, you'll implement the responder branch.","title":"Proposer branch"},{"location":"tutorial/proposer_branch/#proposer-branch","text":"In the previous part of the tutorial, you learned how to randomly assign participants to conditions. In this part of the tutorial, you'll implement the proposer branch of the ultimatum game. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Note This is the most difficult part of the tutorial. It uses advanced techniques that you'll rarely need. Don't sweat the details here. Try to get the gist of what's going on and feel free to 'cheat' by copying and pasting liberally. Brace yourself. Deep breath... jump in.","title":"Proposer branch"},{"location":"tutorial/proposer_branch/#aside-on-fill-in-the-blank-inputs","text":"We're going to ask proposers to make their proposals by filling in a blank. Open your notebook and run this: from hemlock import Blank , Page Page ( Blank ( ( 'Hello, ' , '!' ), blank_empty = '_____' ) ) . preview () Note that the blank's first argument isn't a string like we're used to seeing. Instead, it's a tuple. Whatever the participant enters in the input field gets inserted in between the tuple entries. A key attribute of blanks is blank_empty . This is what fills in the blank when the participant's response is empty.","title":"Aside on fill-in-the-blank inputs"},{"location":"tutorial/proposer_branch/#aside-on-progress-bars","text":"Each participant plays several rounds of the ultimatum game. It's common courtesy to inform participants of how far along they are in your survey. We can use a progress bar for this: from hemlock import Label from hemlock.tools import progress Page ( Label ( progress ( 2 / 5 )) ) . preview () The first argument to progress is how far along the participant is. The (optional) second argument to progress customizes the text: Page ( Label ( progress ( 2 / 5 , 'Round 3 of 5' )) ) . preview ()","title":"Aside on progress bars"},{"location":"tutorial/proposer_branch/#the-proposal-page","text":"We're ready to create a page where the proposer will input the proposed split. Enter the following in your jupyter notebook: N_ROUNDS = 5 POT = 20 i = 1 Page ( Label ( progress ( i / N_ROUNDS , 'Round {} of {} ' . format ( i + 1 , N_ROUNDS )) ), Blank ( ( ''' You have $ {} to split between you and the responder. Fill in the blank: I would like to offer the responder **$''' . format ( POT ), '.00**.' ), prepend = '$' , append = '.00' , var = 'Proposal' , blank_empty = '__' , type = 'number' , min = 0 , max = POT , required = True ) ) . preview ()","title":"The proposal page"},{"location":"tutorial/proposer_branch/#finding-a-responder","text":"We can use the SQLAlchemy Query API to pair the proposer with a random responder this round. First, we create an input with variable name 'Response' and data 5 : from hemlock import db response = Blank ( var = 'Response' , data = 5 ) db . session . add ( response ) db . session . flush ([ response ]) response Out: <Blank 1> Next, we get all Blank objects in the database with the variable name 'Response' whose data is not None : responses = Blank . query . filter ( Blank . var == 'Response' , Blank . data != None ) . all () responses Out: [<Blank 1>] Finally, we choose one of these inputs randomly and get its data: import random random . choice ( responses ) . data Out: 5","title":"Finding a responder"},{"location":"tutorial/proposer_branch/#displaying-the-proposer-outcome","text":"Now we want to display the outcome of the round to the proposer. This calls for a compile function: from hemlock import Compile as C , Embedded from random import randint @C . register def display_proposer_outcome ( outcome_label , proposal_input ): # get the proposal proposal = POT - proposal_input . data , proposal_input . data # get all responses responses = Blank . query . filter ( Blank . var == 'Response' , Blank . data != None ) . all () if responses : # randomly choose a response response = random . choice ( responses ) . data else : # no responses are available # e.g. if this is the first participant response = randint ( 0 , POT ) # compute the payoff accept = response <= proposal [ 1 ] payoff = proposal if accept else ( 0 , 0 ) # record results as embedded data outcome_label . page . embedded = [ Embedded ( 'Response' , response ), Embedded ( 'Accept' , int ( accept )), Embedded ( 'ProposerPayoff' , payoff [ 0 ]), Embedded ( 'ResponderPayoff' , payoff [ 1 ]) ] # describe the outcome of the round outcome_label . label = ''' You proposed the following split: - You: $ {} - Responder: $ {} The responder said they will accept any proposal which gives them at least $ {} . **Your proposal was {} , giving you a payoff of $ {} .** ''' . format ( proposal [ 0 ], proposal [ 1 ], response , 'accepted' if accept else 'rejected' , payoff [ 0 ] ) Let's go through this step by step. First, we get the proposal from the proposal input question. Remember that we converted the data for this input to an integer using a submit function. The data for this input is the amount of money the proposer offered to the responder, meaning that the proposed split is (POT-proposal_input.data, proposal_input.data) . Second, we use the Query API to randomly select a response input question. We modify our above code to account for the fact that, if the first participant is a proposer, there won't be any responses to choose from. So, if our query can't find any response input questions, we return a random response. Third, we compute the payoff and record the results of the round using embedded data. Finally, we set the outcome label's label attribute to display the outcome of the round. Let's see what the proposer outcome would have been if they had offered $10 to the responder: page = Page ( Label ( compile = C . display_proposer_outcome ( Blank ( data = 10 )) ) ) page . _compile () page . preview () Notice that the outcome of the round is recorded in the proposer's outcome page's embedded data: [( e . var , e . data ) for e in page . embedded ] Out: [('Response', 5), ('Accept', 1), ('ProposerPayoff', 10), ('ResponderPayoff', 10)] What would the proposer outcome have been if they had offered $4 to the responder? page = Page ( Label ( compile = C . display_proposer_outcome ( Blank ( data = 4 )) ) ) page . _compile () page . preview () In: [( e . var , e . data ) for e in page . embedded ] Out: [('Response', 5), ('Accept', 0), ('ProposerPayoff', 0), ('ResponderPayoff', 0)]","title":"Displaying the proposer outcome"},{"location":"tutorial/proposer_branch/#adding-the-proposer-branch-to-our-survey","text":"","title":"Adding the proposer branch to our survey"},{"location":"tutorial/proposer_branch/#imports","text":"We'll begin by updating our imports: from hemlock import ( Blank , Branch , Compile as C , Embedded , Input , Label , Page , Validate as V , Submit as S , route ) from hemlock.tools import Assigner , comprehension_check , join , progress from hemlock_demographics import basic_demographics import random from random import randint ...","title":"Imports"},{"location":"tutorial/proposer_branch/#navigating-to-the-proposer-branch","text":"Next we'll modify the ultimatum game branch to navigate to the proposer branch if the participant was assigned to be a proposer. In survey.py : ... def ultimatum_game ( start_branch ): proposer = assigner . next ()[ 'Proposer' ] return Branch ( ... Page ( Label ( ''' You are about to play an ultimatum game as a <b>{}</b>. ''' . format ( 'proposer' if proposer else 'responder' ) ) ), navigate = proposer_branch ) ...","title":"Navigating to the proposer branch"},{"location":"tutorial/proposer_branch/#the-proposer-branch-navigate-function","text":"Next we'll add our proposer navigate function to the bottom of survey.py : ... def proposer_branch ( ug_branch ): branch = Branch ( navigate = end ) for i in range ( N_ROUNDS ): proposal_input = Blank ( ( ''' You have $ {} to split between you and the responder. Fill in the blank: I would like to offer the responder **$''' . format ( POT ), '.00**.' ), prepend = '$' , append = '.00' , var = 'Proposal' , blank_empty = '__' , type = 'number' , min = 0 , max = POT , required = True ) branch . pages += [ Page ( Label ( progress ( i / N_ROUNDS , 'Round {} of {} ' . format ( i + 1 , N_ROUNDS ) )), proposal_input ), Page ( Label ( compile = C . display_proposer_outcome ( proposal_input ) ) ) ] return branch This navigate function simply adds two pages to the proposer branch for each of N_ROUNDS . The first page asks the proposer to propose a split. The second page displays the outcome of the round.","title":"The proposer branch navigate function"},{"location":"tutorial/proposer_branch/#displaying-the-proposer-outcome_1","text":"Next, we'll add the display_proposer_outcome function we wrote in our notebook: ... @C . register def display_proposer_outcome ( outcome_label , proposal_input ): # AS IN THE NOTEBOOK","title":"Displaying the proposer outcome"},{"location":"tutorial/proposer_branch/#ending-the-survey","text":"Finally, we'll add a function to take the participant to the completion page: def end ( rounds_branch ): return Branch ( Page ( Label ( 'Thank you for completing the survey!' ), terminal = True ) ) Run the app and see what the survey looks like in the proposer condition.","title":"Ending the survey"},{"location":"tutorial/proposer_branch/#summary","text":"In this part of the tutorial, you implemented the proposer branch. Give yourself a giant pat on the back. You're officially a hemlock expert. The rest will smooth sailing. In the next part of the tutorial, you'll implement the responder branch.","title":"Summary"},{"location":"tutorial/qpolymorphs/","text":"Question polymorphs In the previous part of the tutorial, you learned how to initialize a hemlock application and run it locally. By the end of this part of the tutorial, you'll be able to add a variety of question polymorphs to your survey pages. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. What are 'question polymorphs'? Question polymorphs are basically different types of questions. They're called 'polymorphs' because they're polymorphic with the Question table in your database. There's no reason you should know this, other than to sound sophisticated at dinner parties. You'll be a hit. Trust me. Creating a demographics page We'll use jupyter notebook as a blackboard to iterate on our demographics page design. After pushing the application context, we'll create a demographics page based on the World Values Survey: from hemlock import Check , Input , Page , Label , RangeInput , Select , binary p = Page ( Select ( 'What is your gender?' , [ '' , 'Male' , 'Female' , 'Other' ] ), Input ( 'How old are you?' , type = 'number' , min = 0 , ), Check ( ''' Which race or ethnicity do you belong to? Check as many as apply. ''' , [ 'White' , 'Black' , ( 'South Asian (Indian, Pakistani, etc.)' , 'South Asian' ), ( 'East Asian (Chinese, Japanese, etc.)' , 'East Asian' ), 'Arabic or Central Asian' , 'Other' , ], multiple = True ), binary ( 'Are you the primary wage earner in your household?' ), RangeInput ( ''' On a scale from 0 (lowest) to 10 (highest), which income group does your household belong to? ''' , min = 0 , max = 10 ) ) p . preview () As usual, use p.preview() to preview the page. Code explanation Here we add several 'question polymorphs' (i.e., types of questions) to our page. The first question is a select, or dropdown, question. Again, the first argument is the question label. The second argument is a list of choices the participant can select. The next question is an input. The first argument is the question label ( 'How old are you?' ). We specify the type of input by passing type='number' to the Input constructor. Without the type argument, participants can enter any text they want into the input. You can check out other HTML input types here . We also specify the minimum value participants can enter, min=0 . The third question is a check question. Like a select question, this allows participants to select from a list of choices. The first argument is the question label, and the second argument is a list of choices. Notice that some of the choices are strings ( 'White' , 'Black' ) while some are tuples ( ('South Asian (Indian, Pakistani, etc.)', 'South Asian') ). Passing the choice as a tuple tells hemlock to 'recode' the value when you download the data. Participants taking the survey see 'South Asian (Indian, Pakistani, etc.)' as one of the choices, but when you download the data, the corresponding column is named South Asian . Also notice that we pass multiple=True to the Check constructor. This allows participants to select multiple choices. By default, multiple is False , meaning participants can only select one choice. We can also pass multiple=True to Select questions to allow participants to select multiple choices from a dropdown menu. We create the fourth question using the binary function. binary creates a check question with two choices. By default, the choices are 'Yes' and 'No' , and their values are recoded as 1 and 0 when you download the data. The last question is a RangeInput , which is what you get when a range slider and an input give each other a special hug. By default, range inputs go from 0 to 100, but we change it from 0 to 10 by specifying the min and max values. More question polymorphs These are just some of the many question types hemlock offers. Check out the 'Question Polymorphs' header in the navigation bar for more. Adding the page to the survey Once we're satisfied with the preview, we incorporate the page into our survey. Our survey.py file should be: from hemlock import Branch , Check , Input , Page , Label , Range , Select , route @route ( '/survey' ) def start (): return Branch ( Page ( Select ( 'What is your gender?' , [ '' , 'Male' , 'Female' , 'Other' ] ), # INSERT THE REST OF THE DEMOGRAPHICS PAGE HERE ), Page ( Label ( 'Thank you for completing this survey!' ), terminal = True ) ) Summary In this part of the tutorial, you learned how to create a demographics questionnaire using several question polymorphs. In the next part of the tutorial, you'll learn how to store and download survey data.","title":"Question polymorphs"},{"location":"tutorial/qpolymorphs/#question-polymorphs","text":"In the previous part of the tutorial, you learned how to initialize a hemlock application and run it locally. By the end of this part of the tutorial, you'll be able to add a variety of question polymorphs to your survey pages. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. What are 'question polymorphs'? Question polymorphs are basically different types of questions. They're called 'polymorphs' because they're polymorphic with the Question table in your database. There's no reason you should know this, other than to sound sophisticated at dinner parties. You'll be a hit. Trust me.","title":"Question polymorphs"},{"location":"tutorial/qpolymorphs/#creating-a-demographics-page","text":"We'll use jupyter notebook as a blackboard to iterate on our demographics page design. After pushing the application context, we'll create a demographics page based on the World Values Survey: from hemlock import Check , Input , Page , Label , RangeInput , Select , binary p = Page ( Select ( 'What is your gender?' , [ '' , 'Male' , 'Female' , 'Other' ] ), Input ( 'How old are you?' , type = 'number' , min = 0 , ), Check ( ''' Which race or ethnicity do you belong to? Check as many as apply. ''' , [ 'White' , 'Black' , ( 'South Asian (Indian, Pakistani, etc.)' , 'South Asian' ), ( 'East Asian (Chinese, Japanese, etc.)' , 'East Asian' ), 'Arabic or Central Asian' , 'Other' , ], multiple = True ), binary ( 'Are you the primary wage earner in your household?' ), RangeInput ( ''' On a scale from 0 (lowest) to 10 (highest), which income group does your household belong to? ''' , min = 0 , max = 10 ) ) p . preview () As usual, use p.preview() to preview the page.","title":"Creating a demographics page"},{"location":"tutorial/qpolymorphs/#code-explanation","text":"Here we add several 'question polymorphs' (i.e., types of questions) to our page. The first question is a select, or dropdown, question. Again, the first argument is the question label. The second argument is a list of choices the participant can select. The next question is an input. The first argument is the question label ( 'How old are you?' ). We specify the type of input by passing type='number' to the Input constructor. Without the type argument, participants can enter any text they want into the input. You can check out other HTML input types here . We also specify the minimum value participants can enter, min=0 . The third question is a check question. Like a select question, this allows participants to select from a list of choices. The first argument is the question label, and the second argument is a list of choices. Notice that some of the choices are strings ( 'White' , 'Black' ) while some are tuples ( ('South Asian (Indian, Pakistani, etc.)', 'South Asian') ). Passing the choice as a tuple tells hemlock to 'recode' the value when you download the data. Participants taking the survey see 'South Asian (Indian, Pakistani, etc.)' as one of the choices, but when you download the data, the corresponding column is named South Asian . Also notice that we pass multiple=True to the Check constructor. This allows participants to select multiple choices. By default, multiple is False , meaning participants can only select one choice. We can also pass multiple=True to Select questions to allow participants to select multiple choices from a dropdown menu. We create the fourth question using the binary function. binary creates a check question with two choices. By default, the choices are 'Yes' and 'No' , and their values are recoded as 1 and 0 when you download the data. The last question is a RangeInput , which is what you get when a range slider and an input give each other a special hug. By default, range inputs go from 0 to 100, but we change it from 0 to 10 by specifying the min and max values. More question polymorphs These are just some of the many question types hemlock offers. Check out the 'Question Polymorphs' header in the navigation bar for more.","title":"Code explanation"},{"location":"tutorial/qpolymorphs/#adding-the-page-to-the-survey","text":"Once we're satisfied with the preview, we incorporate the page into our survey. Our survey.py file should be: from hemlock import Branch , Check , Input , Page , Label , Range , Select , route @route ( '/survey' ) def start (): return Branch ( Page ( Select ( 'What is your gender?' , [ '' , 'Male' , 'Female' , 'Other' ] ), # INSERT THE REST OF THE DEMOGRAPHICS PAGE HERE ), Page ( Label ( 'Thank you for completing this survey!' ), terminal = True ) )","title":"Adding the page to the survey"},{"location":"tutorial/qpolymorphs/#summary","text":"In this part of the tutorial, you learned how to create a demographics questionnaire using several question polymorphs. In the next part of the tutorial, you'll learn how to store and download survey data.","title":"Summary"},{"location":"tutorial/random_ass/","text":"Random assignment In the previous part of the tutorial, you leanred how to add comprehension checks to your studies. By the end of this part of the tutorial, you'll be able to randomly assign your participants to conditions, for example treatment and control. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Basic syntax Open your jupyter notebook and run the following: from hemlock import Participant from hemlock.tools import Assigner assigner = Assigner ({ 'Manipulation' : ( 'happy' , 'sad' ), 'Level' : ( 'low' , 'medium' , 'high' ) }) part = Participant . gen_test_participant () assigner . next () Out: {'Manipulation': 'happy', 'Level': 'low'} Code explanation FIrst, we created an Assigner instance. It randomly and evenly assigns participants to conditions, and easily handles factorial designs. The Assigner 's argument is a dictionary mapping treatment names to levels. In this example, we use a 2 (happy or sad manipulation) x 3 (low, medium, or high level) design. We assign a participant to conditions using assigner.next() . This returns the treatment assignment and automatically records the assignment in the participant's meta attribute: part . meta Out: {'Manipulation': 'happy', 'Level': 'low'} Random assignment in our app In survey.py : ... from hemlock.tools import Assigner , comprehension_check , join ... N_ROUNDS = 5 # the number of rounds participants play POT = 20 # the amount of money split assigner = Assigner ({ 'Proposer' : ( 0 , 1 )}) ... def ultimatum_game ( start_branch ): ... proposer = assigner . next ()[ 'Proposer' ] return Branch ( ... Page ( Label ( 'You passed the comprehension check!' ) ), Page ( Label ( ''' You are about to play an ultimatum game as a **{}**. ''' . format ( 'proposer' if proposer else 'responder' ) ) ), Page ( Label ( 'Thank you for completing this survey!' ), terminal = True ) ) ... Run your app and pass the comprehenion check to see which condition you've been assigned to. Summary In this part of the tutorial, you learned how to assign participants to conditions. In the next part of the tutorial, you'll implement the proposer branch of the ultimatum game.","title":"Random assignment"},{"location":"tutorial/random_ass/#random-assignment","text":"In the previous part of the tutorial, you leanred how to add comprehension checks to your studies. By the end of this part of the tutorial, you'll be able to randomly assign your participants to conditions, for example treatment and control. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Random assignment"},{"location":"tutorial/random_ass/#basic-syntax","text":"Open your jupyter notebook and run the following: from hemlock import Participant from hemlock.tools import Assigner assigner = Assigner ({ 'Manipulation' : ( 'happy' , 'sad' ), 'Level' : ( 'low' , 'medium' , 'high' ) }) part = Participant . gen_test_participant () assigner . next () Out: {'Manipulation': 'happy', 'Level': 'low'}","title":"Basic syntax"},{"location":"tutorial/random_ass/#code-explanation","text":"FIrst, we created an Assigner instance. It randomly and evenly assigns participants to conditions, and easily handles factorial designs. The Assigner 's argument is a dictionary mapping treatment names to levels. In this example, we use a 2 (happy or sad manipulation) x 3 (low, medium, or high level) design. We assign a participant to conditions using assigner.next() . This returns the treatment assignment and automatically records the assignment in the participant's meta attribute: part . meta Out: {'Manipulation': 'happy', 'Level': 'low'}","title":"Code explanation"},{"location":"tutorial/random_ass/#random-assignment-in-our-app","text":"In survey.py : ... from hemlock.tools import Assigner , comprehension_check , join ... N_ROUNDS = 5 # the number of rounds participants play POT = 20 # the amount of money split assigner = Assigner ({ 'Proposer' : ( 0 , 1 )}) ... def ultimatum_game ( start_branch ): ... proposer = assigner . next ()[ 'Proposer' ] return Branch ( ... Page ( Label ( 'You passed the comprehension check!' ) ), Page ( Label ( ''' You are about to play an ultimatum game as a **{}**. ''' . format ( 'proposer' if proposer else 'responder' ) ) ), Page ( Label ( 'Thank you for completing this survey!' ), terminal = True ) ) ... Run your app and pass the comprehenion check to see which condition you've been assigned to.","title":"Random assignment in our app"},{"location":"tutorial/random_ass/#summary","text":"In this part of the tutorial, you learned how to assign participants to conditions. In the next part of the tutorial, you'll implement the proposer branch of the ultimatum game.","title":"Summary"},{"location":"tutorial/responder_branch/","text":"Responder branch In the previous part of the tutorial, you implemented the proposer branch. In this part of the tutorial, you'll implement the responder branch. The responder branch is similar to the proposer branch. For a great exercise, see if you can create it yourself without looking at my code. Click here to see what your survey.py file should look like at the end of this part of the tutorial. Adding the responder branch to our survey Because the responder branch is similar to the proposer branch, we'll skip the notebook and work straight in survey.py . I'll point out the differences as we go along. First, let's add a navigate function to the end of our ultimatum game branch to bring us to the responder branch: ... def ultimatum_game ( start_branch ): proposer = assigner . next ()[ 'Proposer' ] return Branch ( ... navigate = proposer_branch if proposer else responder_branch ) ... def responder_branch ( ug_branch ): branch = Branch ( navigate = end ) for i in range ( N_ROUNDS ): response_input = Blank ( ( ''' The proposer has $ {} to split between him/herself and you. Fill in the blank: I will accept any proposal which gives me at least **$''' . format ( POT ), '.00**.' ), prepend = '$' , append = '.00' , var = 'Response' , blank_empty = '__' , type = 'number' , min = 0 , max = POT , required = True ) branch . pages += [ Page ( Label ( progress ( i / N_ROUNDS , 'Round {} of {} ' . format ( i + 1 , N_ROUNDS ) )), response_input ), Page ( Label ( compile = C . display_responder_outcome ( response_input ) ) ) ] return branch Like in the proposer branch, we add two pages to the responder branch for each of N_ROUNDS . Just as the first of these two pages asked the proposer for the proposal in the proposer branch, the first of these two pages asks the responder for their response in the responder branch. Like in the proposer branch, the second of these pages displays the outcome of the round. Displaying the responder outcome We register a compile function to display the responder outcome. ... @C . register def display_responder_outcome ( outcome_label , response_input ): # get the response response = response_input . data #randomly select a proposal proposal_inputs = Blank . query . filter ( Blank . var == 'Proposal' , Blank . data != None ) . all () if proposal_inputs : # randomly choose a proposal offer = random . choice ( proposal_inputs ) . data else : # no proposals are available # e.g. if this is the first participant offer = randint ( 0 , POT ) proposal = POT - offer , offer # compute the payoff accept = response <= proposal [ 1 ] payoff = proposal if accept else ( 0 , 0 ) # record results as embedded data outcome_label . page . embedded = [ Embedded ( 'Proposal' , proposal [ 1 ]), Embedded ( 'Accept' , int ( accept )), Embedded ( 'ProposerPayoff' , payoff [ 0 ]), Embedded ( 'ResponderPayoff' , payoff [ 1 ]) ] # describe the outcome of the round outcome_label . label = ''' The proposer proposed the following split: - Proposer: $ {} - You: $ {} You said you will accept any proposal that gives you at least $ {} . **You {} the proposal, giving you a payoff of $ {} .** ''' . format ( proposal [ 0 ], proposal [ 1 ], response , 'accepted' if accept else 'rejected' , payoff [ 1 ] ) This is similar to the display_proposer_outcome compile function. First, it gets the responder's response. Second, it matches the responder with a random proposer. If no proposer is avaiable (e.g. if the responder is the first participant in the survey), it generates a random proposal. Third, we compute the payoff for the round and record it using embedded data. Finally, we update the label to display the outcome of the round to the responder. Run the app to see what the survey looks like in the responder condition. Summary In this part of the tutorial, you implemented the responder branch. In the next part of the tutorial, you'll learn how to use hemlock's cutom debugger to make sure everything is running smoothly.","title":"Responder branch"},{"location":"tutorial/responder_branch/#responder-branch","text":"In the previous part of the tutorial, you implemented the proposer branch. In this part of the tutorial, you'll implement the responder branch. The responder branch is similar to the proposer branch. For a great exercise, see if you can create it yourself without looking at my code. Click here to see what your survey.py file should look like at the end of this part of the tutorial.","title":"Responder branch"},{"location":"tutorial/responder_branch/#adding-the-responder-branch-to-our-survey","text":"Because the responder branch is similar to the proposer branch, we'll skip the notebook and work straight in survey.py . I'll point out the differences as we go along. First, let's add a navigate function to the end of our ultimatum game branch to bring us to the responder branch: ... def ultimatum_game ( start_branch ): proposer = assigner . next ()[ 'Proposer' ] return Branch ( ... navigate = proposer_branch if proposer else responder_branch ) ... def responder_branch ( ug_branch ): branch = Branch ( navigate = end ) for i in range ( N_ROUNDS ): response_input = Blank ( ( ''' The proposer has $ {} to split between him/herself and you. Fill in the blank: I will accept any proposal which gives me at least **$''' . format ( POT ), '.00**.' ), prepend = '$' , append = '.00' , var = 'Response' , blank_empty = '__' , type = 'number' , min = 0 , max = POT , required = True ) branch . pages += [ Page ( Label ( progress ( i / N_ROUNDS , 'Round {} of {} ' . format ( i + 1 , N_ROUNDS ) )), response_input ), Page ( Label ( compile = C . display_responder_outcome ( response_input ) ) ) ] return branch Like in the proposer branch, we add two pages to the responder branch for each of N_ROUNDS . Just as the first of these two pages asked the proposer for the proposal in the proposer branch, the first of these two pages asks the responder for their response in the responder branch. Like in the proposer branch, the second of these pages displays the outcome of the round.","title":"Adding the responder branch to our survey"},{"location":"tutorial/responder_branch/#displaying-the-responder-outcome","text":"We register a compile function to display the responder outcome. ... @C . register def display_responder_outcome ( outcome_label , response_input ): # get the response response = response_input . data #randomly select a proposal proposal_inputs = Blank . query . filter ( Blank . var == 'Proposal' , Blank . data != None ) . all () if proposal_inputs : # randomly choose a proposal offer = random . choice ( proposal_inputs ) . data else : # no proposals are available # e.g. if this is the first participant offer = randint ( 0 , POT ) proposal = POT - offer , offer # compute the payoff accept = response <= proposal [ 1 ] payoff = proposal if accept else ( 0 , 0 ) # record results as embedded data outcome_label . page . embedded = [ Embedded ( 'Proposal' , proposal [ 1 ]), Embedded ( 'Accept' , int ( accept )), Embedded ( 'ProposerPayoff' , payoff [ 0 ]), Embedded ( 'ResponderPayoff' , payoff [ 1 ]) ] # describe the outcome of the round outcome_label . label = ''' The proposer proposed the following split: - Proposer: $ {} - You: $ {} You said you will accept any proposal that gives you at least $ {} . **You {} the proposal, giving you a payoff of $ {} .** ''' . format ( proposal [ 0 ], proposal [ 1 ], response , 'accepted' if accept else 'rejected' , payoff [ 1 ] ) This is similar to the display_proposer_outcome compile function. First, it gets the responder's response. Second, it matches the responder with a random proposer. If no proposer is avaiable (e.g. if the responder is the first participant in the survey), it generates a random proposal. Third, we compute the payoff for the round and record it using embedded data. Finally, we update the label to display the outcome of the round to the responder. Run the app to see what the survey looks like in the responder condition.","title":"Displaying the responder outcome"},{"location":"tutorial/responder_branch/#summary","text":"In this part of the tutorial, you implemented the responder branch. In the next part of the tutorial, you'll learn how to use hemlock's cutom debugger to make sure everything is running smoothly.","title":"Summary"},{"location":"tutorial/run_local/","text":"Running hemlock locally In the previous part of the tutorial, you learned how to initialize a hemlock project and create and preview a hemlock page. By the end of this part of the tutorial, you'll be able to initialize a hemlock application and run it locally. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. What does it mean to 'run locally'? Running an app 'locally' means that you can play with it on your own computer, but it won't be available on the internet. We'll cover deployment later. Why run locally? In the previous part of the tutorial, we created and previewed a page in a jupyter notebook. Hemlock + jupyter notebook is great for trying out ideas and iterating quickly, like working on a blackboard. However, it won't create a fully responsive application. The application itself derives from survey.py . To preview our survey as a fully responsive web application, we need to run our app locally. Open a second terminal window You should have jupyter running in a terminal window from the previous part of the tutorial. Open a second terminal window. In general, I recommend having one terminal open for jupyter, and a second for editing python files and running your app. In the second terminal window, change to your project folder: $ cd $ cd my-first-project Run your application Create a python file called survey.py in the root directory of your project. If you're working with Visual Studio Code, enter the following in your terminal: $ code survey.py Enter the following code in survey.py : from hemlock import Branch , Page , Label , route @route ( '/survey' ) def start (): return Branch ( Page ( Label ( 'Hello, World!' ), terminal = True ) ) To preview your survey, go to your (second) terminal window and enter: $ hlk serve Prepare to get served. * Restarting with stat * Debugger is active! * Debugger PIN: 183 -643-336 ( 2841 ) wsgi starting up on http://127.0.0.1:5000 Then navigate to http://localhost:5000/ in your browser. Code explanation After our imports, we use the @route('/survey') decorator to register our first 'navigate' function. This essentially tells our application, 'start here'. Navigate functions direct the 'survey flow'. All navigate functions return Branch objects. A branch contains a list of pages which it displays to participants. We set a branch's pages by passing them as arguments to the constructor, or by setting a branch's pages attribute, meaning that the following are equivalent: b = Branch ( Page ( Label ( 'Label 0' ) ), Page ( Label ( 'Label 1' ) ) ) b = Branch () b . pages = [ Page ( Label ( 'Label 0' ) ), Page ( Label ( 'Label 1' ) ) ] We also passed a keyword (named) argument to the page constructor, terminal=True . This tells the application 'end here'. Workflow In the previous part of the tutorial, we designed a page in jupyter notebook. In this part of the tutorial, we used that design in our survey file. The entire hemlock tutorial follows this general workflow: Iterate quickly on the next part of your survey in jupyter. When you're happy with the design, update your survey files (e.g. survey.py ). Run the app locally with hlk serve (or python3 app.py ). When you're happy with how the app runs, close the app (click on your terminal and hit Ctrl + C). Repeat. As the name blackboard.ipynb suggests, I treat jupyter like a blackboard. Once I'm happy with a design and it's running in my app, I like to start the next design on a fresh blackboard: Delete every cell in the notebook (except the first, where we push the application context, and the last, where we remove temporary files). Restart the kernel ( Kernel >> Restart ). Run the first cell to re-push the application context. Troubleshooting The classic advice, \"try restarting it\", applies here. You can fix about 20% of your errors simply by closing the app (Ctrl+C) and restarting it ( hlk serve ). Summary In this part of the tutorial, you learned how to initialize a hemlock application and run it locally. In the next part of the tutorial, you'll learn how to use question polymorphs to add a demographics questionnaire to your survey.","title":"Running hemlock locally"},{"location":"tutorial/run_local/#running-hemlock-locally","text":"In the previous part of the tutorial, you learned how to initialize a hemlock project and create and preview a hemlock page. By the end of this part of the tutorial, you'll be able to initialize a hemlock application and run it locally. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. What does it mean to 'run locally'? Running an app 'locally' means that you can play with it on your own computer, but it won't be available on the internet. We'll cover deployment later. Why run locally? In the previous part of the tutorial, we created and previewed a page in a jupyter notebook. Hemlock + jupyter notebook is great for trying out ideas and iterating quickly, like working on a blackboard. However, it won't create a fully responsive application. The application itself derives from survey.py . To preview our survey as a fully responsive web application, we need to run our app locally.","title":"Running hemlock locally"},{"location":"tutorial/run_local/#open-a-second-terminal-window","text":"You should have jupyter running in a terminal window from the previous part of the tutorial. Open a second terminal window. In general, I recommend having one terminal open for jupyter, and a second for editing python files and running your app. In the second terminal window, change to your project folder: $ cd $ cd my-first-project","title":"Open a second terminal window"},{"location":"tutorial/run_local/#run-your-application","text":"Create a python file called survey.py in the root directory of your project. If you're working with Visual Studio Code, enter the following in your terminal: $ code survey.py Enter the following code in survey.py : from hemlock import Branch , Page , Label , route @route ( '/survey' ) def start (): return Branch ( Page ( Label ( 'Hello, World!' ), terminal = True ) ) To preview your survey, go to your (second) terminal window and enter: $ hlk serve Prepare to get served. * Restarting with stat * Debugger is active! * Debugger PIN: 183 -643-336 ( 2841 ) wsgi starting up on http://127.0.0.1:5000 Then navigate to http://localhost:5000/ in your browser.","title":"Run your application"},{"location":"tutorial/run_local/#code-explanation","text":"After our imports, we use the @route('/survey') decorator to register our first 'navigate' function. This essentially tells our application, 'start here'. Navigate functions direct the 'survey flow'. All navigate functions return Branch objects. A branch contains a list of pages which it displays to participants. We set a branch's pages by passing them as arguments to the constructor, or by setting a branch's pages attribute, meaning that the following are equivalent: b = Branch ( Page ( Label ( 'Label 0' ) ), Page ( Label ( 'Label 1' ) ) ) b = Branch () b . pages = [ Page ( Label ( 'Label 0' ) ), Page ( Label ( 'Label 1' ) ) ] We also passed a keyword (named) argument to the page constructor, terminal=True . This tells the application 'end here'.","title":"Code explanation"},{"location":"tutorial/run_local/#workflow","text":"In the previous part of the tutorial, we designed a page in jupyter notebook. In this part of the tutorial, we used that design in our survey file. The entire hemlock tutorial follows this general workflow: Iterate quickly on the next part of your survey in jupyter. When you're happy with the design, update your survey files (e.g. survey.py ). Run the app locally with hlk serve (or python3 app.py ). When you're happy with how the app runs, close the app (click on your terminal and hit Ctrl + C). Repeat. As the name blackboard.ipynb suggests, I treat jupyter like a blackboard. Once I'm happy with a design and it's running in my app, I like to start the next design on a fresh blackboard: Delete every cell in the notebook (except the first, where we push the application context, and the last, where we remove temporary files). Restart the kernel ( Kernel >> Restart ). Run the first cell to re-push the application context. Troubleshooting The classic advice, \"try restarting it\", applies here. You can fix about 20% of your errors simply by closing the app (Ctrl+C) and restarting it ( hlk serve ).","title":"Workflow"},{"location":"tutorial/run_local/#summary","text":"In this part of the tutorial, you learned how to initialize a hemlock application and run it locally. In the next part of the tutorial, you'll learn how to use question polymorphs to add a demographics questionnaire to your survey.","title":"Summary"},{"location":"tutorial/submit/","text":"Submit In the previous part of the tutorial, you learned how to validate participant responses. By the end of this part of the tutorial, you'll be able to run functions to handle form submission. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why submit functions? Submit functions run after a participant submits a page and their responses are validated. The most common use for submit functions is adding or transforming data based on a participant's responses. In our example, we're going to use a submit function to record a binary variable indicating whether the participant is female based on our gender question. Basic syntax Open your jupyter notebook and run the following: from hemlock import Input , Submit as S inpt = Input ( 'Enter \"hello world\"' , submit = S . match ( 'hello world' ) ) inpt . submit Out: [<match('hello world')>] You can add submit functions to a page or question by settings its submit attribute or passing a submit argument to its constructor. Submit functions run when a participant successfully submits a page. The match submit function sets a question's data to 1 if the response matches a regex pattern, in this case 'hello world' , and 0 if it does not. Let's set the input question's response and watch our submit function work: inpt . response = 'hello world' inpt . _submit () . data Out: 1 Now let's set the question's response to something other than 'hello world' and see what happens: inpt . response = 'something other than hello world' inpt . _submit () . data Out: 0 Tip You don't need to run _submit yourself in the survey. Hemlock takes care of this automatically for you. More submit functions match is just one of many native hemlock submit functions . Custom submission We're going to use a custom submit function to record the female indicator. Let's do this in our notebook first. from hemlock import Embedded , Page , Select def record_female ( gender ): gender . page . embedded = [ Embedded ( 'Female' , gender . response == 'Female' , data_rows =- 1 ) ] page = Page ( Select ( 'What is your gender?' , [ '' , 'Male' , 'Female' , 'Other' ], submit = record_female ) ) select = page . questions [ 0 ] select . response = 'Female' select . _submit () page . embedded [ 0 ] . data Out: True In: select . response = 'Male' select . _submit () page . embedded [ 0 ] . data Out: False Code explanation We created a custom submit function to add an embedded data element to the demographics page. The submit function takes the gender select question as its argument. In general, submit functions take their parent as their first argument. gender.page is the page to which the gender question belongs. gender.page.embedded is a list of embedded data elements belonging to that page. We set embedded to a list containing a single embedded data element. The embedded data element has a variable name 'Female' and data which indicates whether the participant is female. As we did for the demographics questions, we pass data_rows=-1 , meaning 'this value should appear on every row the participant contributes to the data frame'. Finally, we add the submit function to the gender select question by passing submit=record_female to the question's constructor. This creates a 'sticky note' reminding the select question to run the submit function at the appropriate time. Function patterns In the previous part of the tutorial, we created a custom validate function by registering a new validate function with @V.register . We then added it to a question by passing validate=V.my_function(my_argument) to the question's constructor. Here, we added a submit function without registering it, simply by passing submit=my_function to the question's constructor. Why are validate and submit functions treated differently? The answer is that they aren't. You can add both validate and submit functions using one of two 'patterns'. Simple pattern: def my_validate_function ( question ): # your amazing function here def my_submit_function ( question ): # your amazing function here Input ( validate = my_validate_function , submit = my_submit_function ) Decorator pattern: @V . register def my_validate_function ( question , my_argument ): # your amazing function here @S . register def my_submit_function ( question , my_argument ): # your amazing function here Input ( validate = V . my_validate_function ( my_validate_argument ), submit = S . my_submit_function ( my_submit_argument ) ) The main advantage of the simple pattern is, well, its simplicity. The main advantage of the decorator pattern is that it allows you to pass additional arguments to validate and submit functions. To see the decorator pattern in action for submit functions, run the following in a jupyter notebook cell: @S . register def my_function ( parent , my_argument ): print ( 'My parent is' , parent ) print ( 'My argument is' , my_argument ) select = Select ( submit = S . my_function ( 'hello world' ) ) select . _submit () Out: My parent is <Select (transient 140423771774256)> My argument is hello world Submission in our app Now that we've seen how to add submit functions in our notebook, let's add it to our app. In survey.py : from hemlock import ( Branch , Check , Embedded , Input , Page , Label , RangeInput , Select , Submit as S , Validate as V , binary , route ) @route ( '/survey' ) def start (): return Branch ( Page ( Select ( 'What is your gender?' , [ '' , 'Male' , 'Female' , 'Other' ], var = 'Gender' , data_rows =- 1 , validate = V . require (), submit = record_female ), # REST OF THE DEMOGRAPHICS PAGE ), Page ( Label ( 'Thank you for completing this survey!' ), terminal = True ) ) def record_female ( gender ): gender . page . embedded = [ Embedded ( 'Female' , gender . response == 'Female' , data_rows =- 1 ) ] Run the app again, fill in the demographics page, and download the data. You'll now see a variable 'Female' in the data frame. Summary In this part of the tutorial, you learned how create and run submit functions. In the next part of the tutorial, you'll learn how to create an entire demographics page in one line of code using hemlock extensions.","title":"Submit"},{"location":"tutorial/submit/#submit","text":"In the previous part of the tutorial, you learned how to validate participant responses. By the end of this part of the tutorial, you'll be able to run functions to handle form submission. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why submit functions? Submit functions run after a participant submits a page and their responses are validated. The most common use for submit functions is adding or transforming data based on a participant's responses. In our example, we're going to use a submit function to record a binary variable indicating whether the participant is female based on our gender question.","title":"Submit"},{"location":"tutorial/submit/#basic-syntax","text":"Open your jupyter notebook and run the following: from hemlock import Input , Submit as S inpt = Input ( 'Enter \"hello world\"' , submit = S . match ( 'hello world' ) ) inpt . submit Out: [<match('hello world')>] You can add submit functions to a page or question by settings its submit attribute or passing a submit argument to its constructor. Submit functions run when a participant successfully submits a page. The match submit function sets a question's data to 1 if the response matches a regex pattern, in this case 'hello world' , and 0 if it does not. Let's set the input question's response and watch our submit function work: inpt . response = 'hello world' inpt . _submit () . data Out: 1 Now let's set the question's response to something other than 'hello world' and see what happens: inpt . response = 'something other than hello world' inpt . _submit () . data Out: 0 Tip You don't need to run _submit yourself in the survey. Hemlock takes care of this automatically for you. More submit functions match is just one of many native hemlock submit functions .","title":"Basic syntax"},{"location":"tutorial/submit/#custom-submission","text":"We're going to use a custom submit function to record the female indicator. Let's do this in our notebook first. from hemlock import Embedded , Page , Select def record_female ( gender ): gender . page . embedded = [ Embedded ( 'Female' , gender . response == 'Female' , data_rows =- 1 ) ] page = Page ( Select ( 'What is your gender?' , [ '' , 'Male' , 'Female' , 'Other' ], submit = record_female ) ) select = page . questions [ 0 ] select . response = 'Female' select . _submit () page . embedded [ 0 ] . data Out: True In: select . response = 'Male' select . _submit () page . embedded [ 0 ] . data Out: False","title":"Custom submission"},{"location":"tutorial/submit/#code-explanation","text":"We created a custom submit function to add an embedded data element to the demographics page. The submit function takes the gender select question as its argument. In general, submit functions take their parent as their first argument. gender.page is the page to which the gender question belongs. gender.page.embedded is a list of embedded data elements belonging to that page. We set embedded to a list containing a single embedded data element. The embedded data element has a variable name 'Female' and data which indicates whether the participant is female. As we did for the demographics questions, we pass data_rows=-1 , meaning 'this value should appear on every row the participant contributes to the data frame'. Finally, we add the submit function to the gender select question by passing submit=record_female to the question's constructor. This creates a 'sticky note' reminding the select question to run the submit function at the appropriate time.","title":"Code explanation"},{"location":"tutorial/submit/#function-patterns","text":"In the previous part of the tutorial, we created a custom validate function by registering a new validate function with @V.register . We then added it to a question by passing validate=V.my_function(my_argument) to the question's constructor. Here, we added a submit function without registering it, simply by passing submit=my_function to the question's constructor. Why are validate and submit functions treated differently? The answer is that they aren't. You can add both validate and submit functions using one of two 'patterns'. Simple pattern: def my_validate_function ( question ): # your amazing function here def my_submit_function ( question ): # your amazing function here Input ( validate = my_validate_function , submit = my_submit_function ) Decorator pattern: @V . register def my_validate_function ( question , my_argument ): # your amazing function here @S . register def my_submit_function ( question , my_argument ): # your amazing function here Input ( validate = V . my_validate_function ( my_validate_argument ), submit = S . my_submit_function ( my_submit_argument ) ) The main advantage of the simple pattern is, well, its simplicity. The main advantage of the decorator pattern is that it allows you to pass additional arguments to validate and submit functions. To see the decorator pattern in action for submit functions, run the following in a jupyter notebook cell: @S . register def my_function ( parent , my_argument ): print ( 'My parent is' , parent ) print ( 'My argument is' , my_argument ) select = Select ( submit = S . my_function ( 'hello world' ) ) select . _submit () Out: My parent is <Select (transient 140423771774256)> My argument is hello world","title":"Function patterns"},{"location":"tutorial/submit/#submission-in-our-app","text":"Now that we've seen how to add submit functions in our notebook, let's add it to our app. In survey.py : from hemlock import ( Branch , Check , Embedded , Input , Page , Label , RangeInput , Select , Submit as S , Validate as V , binary , route ) @route ( '/survey' ) def start (): return Branch ( Page ( Select ( 'What is your gender?' , [ '' , 'Male' , 'Female' , 'Other' ], var = 'Gender' , data_rows =- 1 , validate = V . require (), submit = record_female ), # REST OF THE DEMOGRAPHICS PAGE ), Page ( Label ( 'Thank you for completing this survey!' ), terminal = True ) ) def record_female ( gender ): gender . page . embedded = [ Embedded ( 'Female' , gender . response == 'Female' , data_rows =- 1 ) ] Run the app again, fill in the demographics page, and download the data. You'll now see a variable 'Female' in the data frame.","title":"Submission in our app"},{"location":"tutorial/submit/#summary","text":"In this part of the tutorial, you learned how create and run submit functions. In the next part of the tutorial, you'll learn how to create an entire demographics page in one line of code using hemlock extensions.","title":"Summary"},{"location":"tutorial/validate/","text":"Validation In the previous part of the tutorial, you learned how to store and download data. By the end of this part of the tutorial, you'll be able to validate participant responses. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why validation? I often run studies where I elicit numerical estimates. Early on, I noticed that a small but annoying faction of participants, rather than entering actual numbers (e.g., 50), answered the question in full sentences: I believe the answer is fifty. We often need to make sure participants are entering the right kind of answer, whether it's typing the same password twice, answering a comprehension check by clicking on the correct choice, or entering a number instead of a word. Native HTML validation You've already seen native HTML validation when you specified the type of input participants could enter (e.g., type='number' ) or restricted the numerical range of their responses (e.g., min=0 , max=10 ). You'll often want to require participants to respond to certain questions. For Input questions, you can do this using native HTML validation. Open jupyter notebook and run the following: from hemlock import Page , Input Page ( Input ( required = True ) ) . preview () This opens a page with a blank input. Click '>>' without filling it in. Notice that you get an error message. Fill in the input, click '>>' again, and notice that you don't get the error message this time. Learn more about native HTML attributes You can set the HTML attributes of most question polymorphs by passing arguments to the constructor or by setting their attributes. Enter the following in a cell and run it. Input ( required = True ) . input_attrs Out: {'class': ['form-control'], 'type': 'text', 'required': True} This is a dictionary of attributes for the HTML input tag. Check out this resourse for a full list of input tag attributes. Native hemlock validation Hemlock provides an extensive library of validation functions beyond those of standard HTML. To see the limitations of native HTML validation, preview this page: from hemlock import Check Page ( Check ( 'Pick one' , [ 'World' , 'Moon' , 'Sun' ], required = True ) ) . preview () Click '>>' without checking any of the choices. Notice that there's no error message. Native HTML would have let you continue the survey without responding. Hemlock's validation functions overcome problems like this. You can add validation functions to a page or question by passing a validate argument to its constructor or by setting its validate attribute. Validate functions run when a participant attempts to submit a page. If the participant's response is valid, the function returns None , allowing the participant to continue the survey. If the participant's response is invalid, the function returns an error message. Let's use hemlock's validation to require a response to the check question from above: from hemlock import Validate as V check = Check ( 'Pick one!' , [ 'World' , 'Moon' , 'Star' ], validate = V . require () ) check . validate Out: [<require()>] We can verify that the check question doesn't have a response or an error message yet. check . response , check . error Out: (None, None) Let's run the validate function. Because the check has no response, the validate function will return an error message. The check stores the error message in its error attribute. check . _validate () check . error Out: 'Please respond to this question.' Now suppose the participant's response was 'World' (i.e., the participant clicked 'World'), and re-run the validate function. check . response = 'World' check . _validate () check . error No error message this time! Tip You don't need to run _validate yourself in the survey. Hemlock takes care of this automatically for you. More validate functions require is just one of many native hemlock validate functions . Custom validation Hemlock also allows you to easily write custom validation functions. For example, some of my early research involved asking participants to make two different estimates of the same quantity (don't ask, long story). I needed to validate that their second estimate was different from their first. Here's how I did it: @V . register def different_second_estimate ( second_estimate , first_estimate ): if second_estimate . response == first_estimate . response : return 'Make sure your second estimate is different from your first' first_estimate = Input ( 'Enter your first esimate' , type = 'number' ) second_estimate = Input ( 'Enter a second estimate which is different from your first' , type = 'number' , validate = V . different_second_estimate ( first_estimate ) ) If the responses to the first and second estimate inputs are the same, the validate function returns an error message: first_estimate . response = 0 second_estimate . response = 0 second_estimate . _validate () second_estimate . error Out: 'Make sure your second estimate is different from your first' Let's see what happens when the participant's responses to the first and second estimate question are different: first_estimate . response = 0 second_estimate . response = 1 second_estimate . _validate () second_estimate . error No error message this time! Code explanation First, we register a new validate function with the @V.register decorator. The validate function takes two arguments: the second and first estimate Input objects. The function checks if the responses to these inputs are the same and, if they are, returns an error message. Next, we create two inputs for the first and second estimate. We attach the validate function to the second estimate by passing validate=V.different_second_estimate(first_estimate) to its constructor. Importantly, V.my_function does not return the result of my_function . V.my_function returns an object which evaluates my_function when a participant submits a page. V.my_function basically returns a sticky note reminding the survey to run my_function at the appropriate time. Pages and questions store these sticky notes in their validate attribute. Note that different_second_estimate takes two arguments (the second and first estimate) but V.different_second_estimate only takes one (the first estimate). What's going on? In general, validate functions take their 'parent' (the page or question to which they belong) as their first argument. The arguments passed to V.my_function will be passed to my_function after the parent. For example: @V . register def my_function ( parent , my_argument ): print ( 'My parent is' , parent ) print ( 'My argument is' , my_argument ) inpt = Input ( validate = V . my_function ( 'hello world' )) inpt Out: <Input (transient 139890227379456)> In: inpt . _validate () Out: My parent is <Input (transient 139890227379456)> My argument is hello world Notice that the 'parent' is the input associated with the validation function (look at the digits after 'transient'). The same pattern holds for the other function models (submit, compile, and navigate functions) we will see in the coming sections. Validation in our app Now that we've seen how to add validation in our notebook, let's add it to our app. Your goal is to require responses to each of the demographics questions. In survey.py : from hemlock import ( Branch , Check , Input , Page , Label , RangeInput , Select , Validate as V , binary , route ) @route ( '/survey' ) def start (): return Branch ( Page ( Select ( 'What is your gender?' , [ '' , 'Male' , 'Female' , 'Other' ], var = 'Gender' , data_rows =- 1 , validate = V . require () ), Input ( 'How old are you?' , type = 'number' , min = 0 , var = 'Age' , data_rows =- 1 , required = True ), # REST OF THE DEMOGRAPHICS PAGE HERE ), Page ( Label ( 'Thank you for completing the survey!' ), terminal = True ) ) Tips for adding validation to your survey For the input questions (age, income level), use native HTML validation, required=True . For questions that ask you to select one choice (gender, primary wage earner), use validate=V.require() . For questions that ask you to select at least one choice (race), use validate=V.min_len(1) . This means, 'select a minimum of 1 choice'. Run the app again. Try to continue past the demographics page without filling in some of the questions, and see your validation at work! Multiple validate functions You can attach multiple validation functions to a page or question by setting validate to a list of functions. Validate functions run in the order in which you add them, stopping with the first validate function that returns an error. Summary In this part of the tutorial, you learned how to validate participant responses. In the next part of the tutorial, you'll learn how to run submit functions to modify participant data after they submit a page.","title":"Validate"},{"location":"tutorial/validate/#validation","text":"In the previous part of the tutorial, you learned how to store and download data. By the end of this part of the tutorial, you'll be able to validate participant responses. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why validation? I often run studies where I elicit numerical estimates. Early on, I noticed that a small but annoying faction of participants, rather than entering actual numbers (e.g., 50), answered the question in full sentences: I believe the answer is fifty. We often need to make sure participants are entering the right kind of answer, whether it's typing the same password twice, answering a comprehension check by clicking on the correct choice, or entering a number instead of a word.","title":"Validation"},{"location":"tutorial/validate/#native-html-validation","text":"You've already seen native HTML validation when you specified the type of input participants could enter (e.g., type='number' ) or restricted the numerical range of their responses (e.g., min=0 , max=10 ). You'll often want to require participants to respond to certain questions. For Input questions, you can do this using native HTML validation. Open jupyter notebook and run the following: from hemlock import Page , Input Page ( Input ( required = True ) ) . preview () This opens a page with a blank input. Click '>>' without filling it in. Notice that you get an error message. Fill in the input, click '>>' again, and notice that you don't get the error message this time. Learn more about native HTML attributes You can set the HTML attributes of most question polymorphs by passing arguments to the constructor or by setting their attributes. Enter the following in a cell and run it. Input ( required = True ) . input_attrs Out: {'class': ['form-control'], 'type': 'text', 'required': True} This is a dictionary of attributes for the HTML input tag. Check out this resourse for a full list of input tag attributes.","title":"Native HTML validation"},{"location":"tutorial/validate/#native-hemlock-validation","text":"Hemlock provides an extensive library of validation functions beyond those of standard HTML. To see the limitations of native HTML validation, preview this page: from hemlock import Check Page ( Check ( 'Pick one' , [ 'World' , 'Moon' , 'Sun' ], required = True ) ) . preview () Click '>>' without checking any of the choices. Notice that there's no error message. Native HTML would have let you continue the survey without responding. Hemlock's validation functions overcome problems like this. You can add validation functions to a page or question by passing a validate argument to its constructor or by setting its validate attribute. Validate functions run when a participant attempts to submit a page. If the participant's response is valid, the function returns None , allowing the participant to continue the survey. If the participant's response is invalid, the function returns an error message. Let's use hemlock's validation to require a response to the check question from above: from hemlock import Validate as V check = Check ( 'Pick one!' , [ 'World' , 'Moon' , 'Star' ], validate = V . require () ) check . validate Out: [<require()>] We can verify that the check question doesn't have a response or an error message yet. check . response , check . error Out: (None, None) Let's run the validate function. Because the check has no response, the validate function will return an error message. The check stores the error message in its error attribute. check . _validate () check . error Out: 'Please respond to this question.' Now suppose the participant's response was 'World' (i.e., the participant clicked 'World'), and re-run the validate function. check . response = 'World' check . _validate () check . error No error message this time! Tip You don't need to run _validate yourself in the survey. Hemlock takes care of this automatically for you. More validate functions require is just one of many native hemlock validate functions .","title":"Native hemlock validation"},{"location":"tutorial/validate/#custom-validation","text":"Hemlock also allows you to easily write custom validation functions. For example, some of my early research involved asking participants to make two different estimates of the same quantity (don't ask, long story). I needed to validate that their second estimate was different from their first. Here's how I did it: @V . register def different_second_estimate ( second_estimate , first_estimate ): if second_estimate . response == first_estimate . response : return 'Make sure your second estimate is different from your first' first_estimate = Input ( 'Enter your first esimate' , type = 'number' ) second_estimate = Input ( 'Enter a second estimate which is different from your first' , type = 'number' , validate = V . different_second_estimate ( first_estimate ) ) If the responses to the first and second estimate inputs are the same, the validate function returns an error message: first_estimate . response = 0 second_estimate . response = 0 second_estimate . _validate () second_estimate . error Out: 'Make sure your second estimate is different from your first' Let's see what happens when the participant's responses to the first and second estimate question are different: first_estimate . response = 0 second_estimate . response = 1 second_estimate . _validate () second_estimate . error No error message this time!","title":"Custom validation"},{"location":"tutorial/validate/#code-explanation","text":"First, we register a new validate function with the @V.register decorator. The validate function takes two arguments: the second and first estimate Input objects. The function checks if the responses to these inputs are the same and, if they are, returns an error message. Next, we create two inputs for the first and second estimate. We attach the validate function to the second estimate by passing validate=V.different_second_estimate(first_estimate) to its constructor. Importantly, V.my_function does not return the result of my_function . V.my_function returns an object which evaluates my_function when a participant submits a page. V.my_function basically returns a sticky note reminding the survey to run my_function at the appropriate time. Pages and questions store these sticky notes in their validate attribute. Note that different_second_estimate takes two arguments (the second and first estimate) but V.different_second_estimate only takes one (the first estimate). What's going on? In general, validate functions take their 'parent' (the page or question to which they belong) as their first argument. The arguments passed to V.my_function will be passed to my_function after the parent. For example: @V . register def my_function ( parent , my_argument ): print ( 'My parent is' , parent ) print ( 'My argument is' , my_argument ) inpt = Input ( validate = V . my_function ( 'hello world' )) inpt Out: <Input (transient 139890227379456)> In: inpt . _validate () Out: My parent is <Input (transient 139890227379456)> My argument is hello world Notice that the 'parent' is the input associated with the validation function (look at the digits after 'transient'). The same pattern holds for the other function models (submit, compile, and navigate functions) we will see in the coming sections.","title":"Code explanation"},{"location":"tutorial/validate/#validation-in-our-app","text":"Now that we've seen how to add validation in our notebook, let's add it to our app. Your goal is to require responses to each of the demographics questions. In survey.py : from hemlock import ( Branch , Check , Input , Page , Label , RangeInput , Select , Validate as V , binary , route ) @route ( '/survey' ) def start (): return Branch ( Page ( Select ( 'What is your gender?' , [ '' , 'Male' , 'Female' , 'Other' ], var = 'Gender' , data_rows =- 1 , validate = V . require () ), Input ( 'How old are you?' , type = 'number' , min = 0 , var = 'Age' , data_rows =- 1 , required = True ), # REST OF THE DEMOGRAPHICS PAGE HERE ), Page ( Label ( 'Thank you for completing the survey!' ), terminal = True ) ) Tips for adding validation to your survey For the input questions (age, income level), use native HTML validation, required=True . For questions that ask you to select one choice (gender, primary wage earner), use validate=V.require() . For questions that ask you to select at least one choice (race), use validate=V.min_len(1) . This means, 'select a minimum of 1 choice'. Run the app again. Try to continue past the demographics page without filling in some of the questions, and see your validation at work! Multiple validate functions You can attach multiple validation functions to a page or question by setting validate to a list of functions. Validate functions run in the order in which you add them, stopping with the first validate function that returns an error.","title":"Validation in our app"},{"location":"tutorial/validate/#summary","text":"In this part of the tutorial, you learned how to validate participant responses. In the next part of the tutorial, you'll learn how to run submit functions to modify participant data after they submit a page.","title":"Summary"}]}