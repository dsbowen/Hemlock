{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hemlock Hemlock aspires to be the most powerful and flexible way to create online studies, with applications in marketing and behavioral science research. If you're new to python, or the installation and quickstart instructions don't make sense to you, check out the tutorial . Installation $ pip install hemlock-survey Quickstart First, create a file app.py in the root directory of your project: import survey from hemlock import create_app app = create_app() if __name__ == '__main__': from hemlock.app import socketio socketio.run(app, debug=True) Create another file survey.py in the same directory: from hemlock import Branch, Label, Page, route @route('/survey') def start(): return Branch(Page(Label('<p>Hello, World!</p>'), terminal=True)) Run your app: $ python3 app.py And navigate to http://localhost:5000/ in your browser. Citation @software{bowen2020hemlock, author = {Dillon Bowen}, title = {Hemlock}, url = {https://dsbowen.github.io/hemlock/}, date = {2020-07-10}, } License Users must cite this package in any publications which use it. It is licensed with the Hemlock Research License . The license permits free use for academic research, and requires written permission from hemlock's author, Dillon Bowen, for commercial use.","title":"Home"},{"location":"#hemlock","text":"Hemlock aspires to be the most powerful and flexible way to create online studies, with applications in marketing and behavioral science research. If you're new to python, or the installation and quickstart instructions don't make sense to you, check out the tutorial .","title":"Hemlock"},{"location":"#installation","text":"$ pip install hemlock-survey","title":"Installation"},{"location":"#quickstart","text":"First, create a file app.py in the root directory of your project: import survey from hemlock import create_app app = create_app() if __name__ == '__main__': from hemlock.app import socketio socketio.run(app, debug=True) Create another file survey.py in the same directory: from hemlock import Branch, Label, Page, route @route('/survey') def start(): return Branch(Page(Label('<p>Hello, World!</p>'), terminal=True)) Run your app: $ python3 app.py And navigate to http://localhost:5000/ in your browser.","title":"Quickstart"},{"location":"#citation","text":"@software{bowen2020hemlock, author = {Dillon Bowen}, title = {Hemlock}, url = {https://dsbowen.github.io/hemlock/}, date = {2020-07-10}, }","title":"Citation"},{"location":"#license","text":"Users must cite this package in any publications which use it. It is licensed with the Hemlock Research License . The license permits free use for academic research, and requires written permission from hemlock's author, Dillon Bowen, for commercial use.","title":"License"},{"location":"app/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Application factory and settings hemlock.app. push_app_context def hemlock.app. push_app_context ( ) [source] Push an app context for debugging in shell or notebook. Returns: app : flask.app.Flask Examples from hemlock import push_app_context app = push_app_context() Out: <Flask 'hemlock.app'> hemlock.app. create_app def hemlock.app. create_app ( settings=settings ) [source] Create a Hemlock application. Parameters: settings : dict Default settings for the application, extensions, and models. Returns: app : flask.app.Flask Examples In this example, we add a back button to every page in our survey. from hemlock import Page, create_app, settings settings['Page'].update({'back': True}) app = create_app() app.app_context().push() Page().preview() Default application settings Below are the default settings for Hemlock applications and extensions. App settings: clean_data : callable or None, default=None Callable which cleans your data before downloading or creating a data profile. This callable takes and returns pandas.DataFrame . If None , no additional cleaning is performend. duplicate_keys : list, default=[] List of keys (column names) on which to block duplicate participants. If empty, the app will not screen out duplicates. password : str, default='' Password for accessing the researcher dashboard. restart_option : bool, default=True Indicates that participants who attempt to re-navigate to the index page will be given the option to restart the survey. If False , participants to attempt to re-navigate to the index page will be redirected to their current survey page. restart_text : str, default='Click << to return...' Text displayed to participants when given the option to restart or continue with the survey. screenout_csv : str, default='screenout.csv' Name of the csv file containing criteria for screening out participants. screenout_keys : list, default=[] List of keys (column names) on which to screen out participants. If empty, participants will be screened out based on all keys in the screenout csv. screenout_text : str, default='...you have already participated...' Text displayed to participants who are ineligible to participate in this survey. socket_js_src : Source of the websocket javascript. static_folder : str, default='static' Path to the static folder. template_folder : str, default='templates' Path to the template folder. time_expired_text : str, default='You have exceeded your time limit...' Text displayed to participants whose time has expired. time_limit : datetime.timedelta or None, default=None Time limit for participants to complete the survey. validate : bool, default=True Indicate that all validation is active. Set to False to turn off all validation for testing. Config: SECRET_KEY : str Looks for a SECRET_KEY environment variable. SQLALCHEMY_DATABASE_URI : str Looks for DATABASE_URL environment variable. Otherwise, we use a SQLite database data.db in the current working directory. SQLALCHEMY_TRACK_MODIFICATIONS : bool, default=False REDIS_URL : Looks for a REDIS_URL environment variable. DownloadBtnManager: Manager: loading_img_blueprint : str or None, default='hemlock' Name of the blueprint to which the loading image belongs. If None , the loading image is assumed to be in the app's static directory. loading_img_filename : str or None, default='img/worker_loading.gif' Name of the loading image file. Notes See https://flask.palletsprojects.com/en/1.1.x/config/ for more detail on Flask application configuration. See https://dsbowen.github.io/flask-download-btn/manager/ for more detail on DownloadBtnManager settings. See https://dsbowen.github.io/flask-worker/manager/ for more detail on Manager settings.","title":"Basics"},{"location":"app/#application-factory-and-settings","text":"","title":"Application factory and settings"},{"location":"app/#hemlockapppush_app_context","text":"def hemlock.app. push_app_context ( ) [source] Push an app context for debugging in shell or notebook. Returns: app : flask.app.Flask","title":"hemlock.app.push_app_context"},{"location":"app/#examples","text":"from hemlock import push_app_context app = push_app_context() Out: <Flask 'hemlock.app'>","title":"Examples"},{"location":"app/#hemlockappcreate_app","text":"def hemlock.app. create_app ( settings=settings ) [source] Create a Hemlock application. Parameters: settings : dict Default settings for the application, extensions, and models. Returns: app : flask.app.Flask","title":"hemlock.app.create_app"},{"location":"app/#examples_1","text":"In this example, we add a back button to every page in our survey. from hemlock import Page, create_app, settings settings['Page'].update({'back': True}) app = create_app() app.app_context().push() Page().preview()","title":"Examples"},{"location":"app/#default-application-settings","text":"Below are the default settings for Hemlock applications and extensions. App settings: clean_data : callable or None, default=None Callable which cleans your data before downloading or creating a data profile. This callable takes and returns pandas.DataFrame . If None , no additional cleaning is performend. duplicate_keys : list, default=[] List of keys (column names) on which to block duplicate participants. If empty, the app will not screen out duplicates. password : str, default='' Password for accessing the researcher dashboard. restart_option : bool, default=True Indicates that participants who attempt to re-navigate to the index page will be given the option to restart the survey. If False , participants to attempt to re-navigate to the index page will be redirected to their current survey page. restart_text : str, default='Click << to return...' Text displayed to participants when given the option to restart or continue with the survey. screenout_csv : str, default='screenout.csv' Name of the csv file containing criteria for screening out participants. screenout_keys : list, default=[] List of keys (column names) on which to screen out participants. If empty, participants will be screened out based on all keys in the screenout csv. screenout_text : str, default='...you have already participated...' Text displayed to participants who are ineligible to participate in this survey. socket_js_src : Source of the websocket javascript. static_folder : str, default='static' Path to the static folder. template_folder : str, default='templates' Path to the template folder. time_expired_text : str, default='You have exceeded your time limit...' Text displayed to participants whose time has expired. time_limit : datetime.timedelta or None, default=None Time limit for participants to complete the survey. validate : bool, default=True Indicate that all validation is active. Set to False to turn off all validation for testing. Config: SECRET_KEY : str Looks for a SECRET_KEY environment variable. SQLALCHEMY_DATABASE_URI : str Looks for DATABASE_URL environment variable. Otherwise, we use a SQLite database data.db in the current working directory. SQLALCHEMY_TRACK_MODIFICATIONS : bool, default=False REDIS_URL : Looks for a REDIS_URL environment variable. DownloadBtnManager: Manager: loading_img_blueprint : str or None, default='hemlock' Name of the blueprint to which the loading image belongs. If None , the loading image is assumed to be in the app's static directory. loading_img_filename : str or None, default='img/worker_loading.gif' Name of the loading image file.","title":"Default application settings"},{"location":"app/#notes","text":"See https://flask.palletsprojects.com/en/1.1.x/config/ for more detail on Flask application configuration. See https://dsbowen.github.io/flask-download-btn/manager/ for more detail on DownloadBtnManager settings. See https://dsbowen.github.io/flask-worker/manager/ for more detail on Manager settings.","title":"Notes"},{"location":"bases/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Common bases and mixins hemlock. Base class hemlock. Base ( **kwargs ) [source] Base for all Hemlock models. Interits from sqlalchemy_function.FunctionRelator , sqlalchemy_orderingitem.Orderingitem and sqlalchemy_modelid.ModelIdBase . Parameters: **kwargs : You can set any attribute by passing it as a keyword argument. Attributes: name : str or None, default=None Used primarily as a filter for database querying. hemlock. Data Polymorphic base for all objects which contribute data to the dataframe. Data elements 'pack' their data and return it to their participant, who in turn sends it to the data store. Attributes: data : sqlalchemy_mutable.MutableType, default=None Data this element contributes to the dataframe. data_rows : int, default=1 Number of rows this data element contributes to the dataframe for its participant. If negative, this data element will 'fill in' any emtpy rows at the end of the dataframe with its most recent value. index : int or None, default=None Order in which this data element appears in its parent; usually a hemlock.Branch , hemlock.Page , or hemlock.Question . var : str or None, default=None Variable name associated with this data element. If None , the data will not be recorded. hemlock. HTMLMixin class hemlock. HTMLMixin ( template=None, **kwargs ) [source] Mixin for models which contribute html to a page. Parameters: template : str, default depends on object Jinja template which is rendered to produce self.body . Attributes: body : sqlalchemy_mutablesoup.MutableSoupType The main html of the object. css : sqlalchemy_mutablesoup.MutableSoupType, default=None CSS the object contributes to the page. js : sqlalchemy_mutablesoup.MutableSoupType, default=None Javascript the object contributes to the page. Methods add_external_css ( self, **attrs ) [source] Add external css to self.css . The external css is a <link> tag with the specified attributes. In particular, specify the href attribute. Parameters: **attrs : Attribute names and values in the <link> tag. Returns: self : hemlock.HTMLMiixn add_external_js ( self, **attrs ) [source] Add external javascript to self.js . The external js is a <script> tag with the specified attributes. In particular, specify the src attribute. Parameters: **attrs : Attribute names and values in the <script> tag. Returns: self : hemlock.HTMLMixin add_internal_css ( self, style ) [source] Add internal css to self.css . The internal css is a <style> tag with the specified css selector : style dictionary. Parameters: style : dict Maps css selector to a style dictionary. The style dictionary maps attribute names to values. Returns: self : hemlock.HTMLMixin add_internal_js ( self, js ) [source] Add internal javascript to self.js . The interal js is a <script> tag with the specified js code. Parameters: js : str Javascript code. Returns: self : hemlock.HTMLMixin hemlock. InputBase Base for models which contain <input> tags. Attributes: input : bs4.Tag or None Input tag associated with this model. Methods input_from_driver ( self, driver=None ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.Webdriver Driver which will be used to select the input. Does not need to be Chrome. Returns: input : selenium.webdriver.remote.webelement.WebElement Web element of the <input> tag associated with this model. label_from_driver ( self, driver ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.Webdriver Driver which will be used to select the label. Does not need to be Chrome. Returns: label : selenium.webdriver.remote.webelement.WebElement Web element of the label tag associated with this model.","title":"Bases"},{"location":"bases/#common-bases-and-mixins","text":"","title":"Common bases and mixins"},{"location":"bases/#hemlockbase","text":"class hemlock. Base ( **kwargs ) [source] Base for all Hemlock models. Interits from sqlalchemy_function.FunctionRelator , sqlalchemy_orderingitem.Orderingitem and sqlalchemy_modelid.ModelIdBase . Parameters: **kwargs : You can set any attribute by passing it as a keyword argument. Attributes: name : str or None, default=None Used primarily as a filter for database querying.","title":"hemlock.Base"},{"location":"bases/#hemlockdata","text":"Polymorphic base for all objects which contribute data to the dataframe. Data elements 'pack' their data and return it to their participant, who in turn sends it to the data store. Attributes: data : sqlalchemy_mutable.MutableType, default=None Data this element contributes to the dataframe. data_rows : int, default=1 Number of rows this data element contributes to the dataframe for its participant. If negative, this data element will 'fill in' any emtpy rows at the end of the dataframe with its most recent value. index : int or None, default=None Order in which this data element appears in its parent; usually a hemlock.Branch , hemlock.Page , or hemlock.Question . var : str or None, default=None Variable name associated with this data element. If None , the data will not be recorded.","title":"hemlock.Data"},{"location":"bases/#hemlockhtmlmixin","text":"class hemlock. HTMLMixin ( template=None, **kwargs ) [source] Mixin for models which contribute html to a page. Parameters: template : str, default depends on object Jinja template which is rendered to produce self.body . Attributes: body : sqlalchemy_mutablesoup.MutableSoupType The main html of the object. css : sqlalchemy_mutablesoup.MutableSoupType, default=None CSS the object contributes to the page. js : sqlalchemy_mutablesoup.MutableSoupType, default=None Javascript the object contributes to the page.","title":"hemlock.HTMLMixin"},{"location":"bases/#methods","text":"add_external_css ( self, **attrs ) [source] Add external css to self.css . The external css is a <link> tag with the specified attributes. In particular, specify the href attribute. Parameters: **attrs : Attribute names and values in the <link> tag. Returns: self : hemlock.HTMLMiixn add_external_js ( self, **attrs ) [source] Add external javascript to self.js . The external js is a <script> tag with the specified attributes. In particular, specify the src attribute. Parameters: **attrs : Attribute names and values in the <script> tag. Returns: self : hemlock.HTMLMixin add_internal_css ( self, style ) [source] Add internal css to self.css . The internal css is a <style> tag with the specified css selector : style dictionary. Parameters: style : dict Maps css selector to a style dictionary. The style dictionary maps attribute names to values. Returns: self : hemlock.HTMLMixin add_internal_js ( self, js ) [source] Add internal javascript to self.js . The interal js is a <script> tag with the specified js code. Parameters: js : str Javascript code. Returns: self : hemlock.HTMLMixin","title":"Methods"},{"location":"bases/#hemlockinputbase","text":"Base for models which contain <input> tags. Attributes: input : bs4.Tag or None Input tag associated with this model.","title":"hemlock.InputBase"},{"location":"bases/#methods_1","text":"input_from_driver ( self, driver=None ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.Webdriver Driver which will be used to select the input. Does not need to be Chrome. Returns: input : selenium.webdriver.remote.webelement.WebElement Web element of the <input> tag associated with this model. label_from_driver ( self, driver ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.Webdriver Driver which will be used to select the label. Does not need to be Chrome. Returns: label : selenium.webdriver.remote.webelement.WebElement Web element of the label tag associated with this model.","title":"Methods"},{"location":"branch/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Branch hemlock. Branch class hemlock. Branch ( *pages, **kwargs ) [source] Branches are stacked in a participant's branch stack. A branch contains a queue of pages which it displays to its participant. Inherits from hemlock.models.Base . Parameters: *pages : hemlock.Page Pages which belong to this branch. Attributes: index : int or None, default=None Order in which this branch appears in its participant's branch stack. Relationships: part : hemlock.Participant Participant to whose branch stack this page belongs. origin_branch : hemlock.Branch The branch from which this branch originated. next_branch : hemlock.Branch The branch which originated from this branch. origin_page : hemlock.Page The page from which this branch originated. Note that branches can originate from other branches or pages. pages : list of hemlock.Page The queue of pages belonging to this branch. start_page : hemlock.Page or None The first page in the page queue, if non-empty. current_page : hemlock.Page Current page of this branch (head of the page queue). embedded : list of hemlock.Embedded Embedded data elements. data_elements : list of hemlock.DataElement All data elements belonging to this branch, in order of embedded data then page data. navigate_function : hemlock.Navigate Navigate function which returns a new branch once the participant has reached the end of this branch (i.e. the end of the page queue associated with this branch). navigate_worker : hemlock.NavigateWorker Worker which handles complex navigate functions. Examples from hemlock import Branch, Label, Page, push_app_context app = push_app_context() Branch( Page(Label('<p>Hello World</p>')), Page(Label('<p>Hello Moon</p>')), Page(Label('<p>Hello Star</p>')) ).preview() This will open all of the branch's pages in separate tabs. Methods preview ( self, driver=None ) [source] Preview the page queue in the a browser window. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver or None, default=None Driver to preview page debugging. If None , the page will be opened in a web browser. Returns: self : helock.Branch view_nav ( self ) [source] Print this branch's page queue for debugging purposes. Returns: self : hemlock.Branch","title":"Branch"},{"location":"branch/#branch","text":"","title":"Branch"},{"location":"branch/#hemlockbranch","text":"class hemlock. Branch ( *pages, **kwargs ) [source] Branches are stacked in a participant's branch stack. A branch contains a queue of pages which it displays to its participant. Inherits from hemlock.models.Base . Parameters: *pages : hemlock.Page Pages which belong to this branch. Attributes: index : int or None, default=None Order in which this branch appears in its participant's branch stack. Relationships: part : hemlock.Participant Participant to whose branch stack this page belongs. origin_branch : hemlock.Branch The branch from which this branch originated. next_branch : hemlock.Branch The branch which originated from this branch. origin_page : hemlock.Page The page from which this branch originated. Note that branches can originate from other branches or pages. pages : list of hemlock.Page The queue of pages belonging to this branch. start_page : hemlock.Page or None The first page in the page queue, if non-empty. current_page : hemlock.Page Current page of this branch (head of the page queue). embedded : list of hemlock.Embedded Embedded data elements. data_elements : list of hemlock.DataElement All data elements belonging to this branch, in order of embedded data then page data. navigate_function : hemlock.Navigate Navigate function which returns a new branch once the participant has reached the end of this branch (i.e. the end of the page queue associated with this branch). navigate_worker : hemlock.NavigateWorker Worker which handles complex navigate functions.","title":"hemlock.Branch"},{"location":"branch/#examples","text":"from hemlock import Branch, Label, Page, push_app_context app = push_app_context() Branch( Page(Label('<p>Hello World</p>')), Page(Label('<p>Hello Moon</p>')), Page(Label('<p>Hello Star</p>')) ).preview() This will open all of the branch's pages in separate tabs.","title":"Examples"},{"location":"branch/#methods","text":"preview ( self, driver=None ) [source] Preview the page queue in the a browser window. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver or None, default=None Driver to preview page debugging. If None , the page will be opened in a web browser. Returns: self : helock.Branch view_nav ( self ) [source] Print this branch's page queue for debugging purposes. Returns: self : hemlock.Branch","title":"Methods"},{"location":"check/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Check hemlock. click_choices def hemlock. click_choices ( driver, question ) [source] Default debug function. See hemlock.functions.debug.click_choices . hemlock. Check class hemlock. Check ( label='', choices=[], template='hemlock/check.html', ** kwargs ) [source] Check questions use radio inputs if only one choice can be selected, or checkbox inputs if multiple choices can be selected. Inherits from hemlock.ChoiceQuestion . By default, choices are positioned vertically. To position them horizontally, set inline to True. Parameters: label : str or bs4.BeautifulSoup, default='' Check question label. choices : list of hemlock.Choice or str, default=[] Choices which participants can check. String inputs are automatically converted to hemlock.Choice objects. template : str, default='hemlock/check.html' Template for the check body. Attributes: align : str, default='left' Choice alignment; 'left' , 'center' , or 'right' . choice_wrapper : bs4.Tag Tag fo the choice html wrapper. inline : bool, default=False Indicates that choices should be inline , as opposed to vertical. multiple : bool, default=False Indicates that the participant may select multiple choices. Examples from hemlock import Check, Page, push_app_context app = push_app_context() Page(Check('<p>Check one.</p>', ['Yes','No','Maybe'])).preview()","title":"Check"},{"location":"check/#check","text":"","title":"Check"},{"location":"check/#hemlockclick_choices","text":"def hemlock. click_choices ( driver, question ) [source] Default debug function. See hemlock.functions.debug.click_choices .","title":"hemlock.click_choices"},{"location":"check/#hemlockcheck","text":"class hemlock. Check ( label='', choices=[], template='hemlock/check.html', ** kwargs ) [source] Check questions use radio inputs if only one choice can be selected, or checkbox inputs if multiple choices can be selected. Inherits from hemlock.ChoiceQuestion . By default, choices are positioned vertically. To position them horizontally, set inline to True. Parameters: label : str or bs4.BeautifulSoup, default='' Check question label. choices : list of hemlock.Choice or str, default=[] Choices which participants can check. String inputs are automatically converted to hemlock.Choice objects. template : str, default='hemlock/check.html' Template for the check body. Attributes: align : str, default='left' Choice alignment; 'left' , 'center' , or 'right' . choice_wrapper : bs4.Tag Tag fo the choice html wrapper. inline : bool, default=False Indicates that choices should be inline , as opposed to vertical. multiple : bool, default=False Indicates that the participant may select multiple choices.","title":"hemlock.Check"},{"location":"check/#examples","text":"from hemlock import Check, Page, push_app_context app = push_app_context() Page(Check('<p>Check one.</p>', ['Yes','No','Maybe'])).preview()","title":"Examples"},{"location":"choice/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Choices and Options The difference between hemlock.Choice and hemlock.Option is the former are for hemlock.Check questions, while latter are for hemlock.Select questions. The use of choice and option models is not due to any deep functional difference between them, but reflects the underlying html. hemlock. Choice class hemlock. Choice ( label='', template='hemlock/choice.html', **kwargs ) [source] Choices are displayed as part of their question in index order. It inherits from hemlock.models.InputBase and hemlock.models.HTMLMixin . Parameters: label : str, default='' Choice label. template : str, default='choice.html' Template for the choice body . Attributes: index : int or None, default=None Order in which this choice appears in its question. label : str, default='' The choice label. name : str or None, default=None Name of the choice column in the dataframe. value : sqlalchemy_mutable.MutableType or None, default=None Value of the data associated with the choice. For a question where only one choice can be selected, this is the value of the question's data if this choice is selected. For a question where multiple choices may be selected, data are one-hot encoded; the value is the suffix of the column name associated with the indicator variable that this choice was selected. Relationships: question : hemlock.Question The question to which this choice belongs. Notes Passing label into the constructor is equivalent to calling self.set_all(label) unless name and value arguments are also passed to the constructor. Methods set_all ( self, val ) [source] Set the choice's label, name, and value. Parameters: val : Value to which the choice's label, name, and value should be set. Returns: self : hemlock.Choice is_default ( self ) [source] Returns: is_default : bool Indicate that this choice is (one of) its question's default choice(s). Notes The question's default choice(s) is the question's response , if not None , or the question's default . hemlock. Option class hemlock. Option ( label='', template='hemlock/option.html', **kwargs ) [source] Options are a choice polymorph for hemlock.Select questions. Inherits from hemlock.Choice . Parameters: label : str, default='' Option label. template : str, default='hemlock/option.html' Template for the option body .","title":"Choice"},{"location":"choice/#choices-and-options","text":"The difference between hemlock.Choice and hemlock.Option is the former are for hemlock.Check questions, while latter are for hemlock.Select questions. The use of choice and option models is not due to any deep functional difference between them, but reflects the underlying html.","title":"Choices and Options"},{"location":"choice/#hemlockchoice","text":"class hemlock. Choice ( label='', template='hemlock/choice.html', **kwargs ) [source] Choices are displayed as part of their question in index order. It inherits from hemlock.models.InputBase and hemlock.models.HTMLMixin . Parameters: label : str, default='' Choice label. template : str, default='choice.html' Template for the choice body . Attributes: index : int or None, default=None Order in which this choice appears in its question. label : str, default='' The choice label. name : str or None, default=None Name of the choice column in the dataframe. value : sqlalchemy_mutable.MutableType or None, default=None Value of the data associated with the choice. For a question where only one choice can be selected, this is the value of the question's data if this choice is selected. For a question where multiple choices may be selected, data are one-hot encoded; the value is the suffix of the column name associated with the indicator variable that this choice was selected. Relationships: question : hemlock.Question The question to which this choice belongs.","title":"hemlock.Choice"},{"location":"choice/#notes","text":"Passing label into the constructor is equivalent to calling self.set_all(label) unless name and value arguments are also passed to the constructor.","title":"Notes"},{"location":"choice/#methods","text":"set_all ( self, val ) [source] Set the choice's label, name, and value. Parameters: val : Value to which the choice's label, name, and value should be set. Returns: self : hemlock.Choice is_default ( self ) [source] Returns: is_default : bool Indicate that this choice is (one of) its question's default choice(s).","title":"Methods"},{"location":"choice/#notes_1","text":"The question's default choice(s) is the question's response , if not None , or the question's default .","title":"Notes"},{"location":"choice/#hemlockoption","text":"class hemlock. Option ( label='', template='hemlock/option.html', **kwargs ) [source] Options are a choice polymorph for hemlock.Select questions. Inherits from hemlock.Choice . Parameters: label : str, default='' Option label. template : str, default='hemlock/option.html' Template for the option body .","title":"hemlock.Option"},{"location":"compile_functions/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Compile functions hemlock.functions.compile. call_method def hemlock.functions.compile. call_method ( obj, method_name, *args, **kwargs ) [source] Calls one of the object's methods. Parameters: obj : Object whose methods will be called. method_name : str Names of the method to call. *args, **kwargs : Arguments and keyword arguments to pass to the method. Examples from hemlock import Compile, Page, push_app_context push_app_context() p = Compile.call_method(Page(error='Error message'), 'clear_error') p.preview()._compile().preview() hemlock.functions.compile. clear_error def hemlock.functions.compile. clear_error ( obj ) [source] Calls the object's clear_error method. Parameters: obj : Object whose clear_error method will be called. Examples from hemlock import Compile, Page, Check, push_app_context push_app_context() p = Compile.clear_error(Page(error='Error message')) p.preview()._compile().preview() hemlock.functions.compile. clear_response def hemlock.functions.compile. clear_response ( obj ) [source] Calls the object's clear_response method. Parameters: obj : Object whose clear_response method will be called. Examples from hemlock import Compile, Input, Page, push_app_context push_app_context() p = Compile.clear_response(Page(Input(response='Hello World'))) p.preview()._compile().preview() hemlock.functions.compile. shuffle def hemlock.functions.compile. shuffle ( obj, *attrs ) [source] Shuffle an object's attributes. Parameters: obj : Objects whose attributes should be shuffled. *attrs : str Names of attributes to shuffle. Notes If the object is a hemlock.Page , the default shuffled attribute is its questions . If the object is a hemlock.ChoiceQuestion , the default shuffled attribute is its choices . Examples from hemlock import Compile, Label, Page, push_app_context push_app_context() p = Compile.shuffle(Page( Label('<p>Label {}</p>'.format(i)) for i in range(4) )) p.preview()._compile().preview()","title":"Compile"},{"location":"compile_functions/#compile-functions","text":"","title":"Compile functions"},{"location":"compile_functions/#hemlockfunctionscompilecall_method","text":"def hemlock.functions.compile. call_method ( obj, method_name, *args, **kwargs ) [source] Calls one of the object's methods. Parameters: obj : Object whose methods will be called. method_name : str Names of the method to call. *args, **kwargs : Arguments and keyword arguments to pass to the method.","title":"hemlock.functions.compile.call_method"},{"location":"compile_functions/#examples","text":"from hemlock import Compile, Page, push_app_context push_app_context() p = Compile.call_method(Page(error='Error message'), 'clear_error') p.preview()._compile().preview()","title":"Examples"},{"location":"compile_functions/#hemlockfunctionscompileclear_error","text":"def hemlock.functions.compile. clear_error ( obj ) [source] Calls the object's clear_error method. Parameters: obj : Object whose clear_error method will be called.","title":"hemlock.functions.compile.clear_error"},{"location":"compile_functions/#examples_1","text":"from hemlock import Compile, Page, Check, push_app_context push_app_context() p = Compile.clear_error(Page(error='Error message')) p.preview()._compile().preview()","title":"Examples"},{"location":"compile_functions/#hemlockfunctionscompileclear_response","text":"def hemlock.functions.compile. clear_response ( obj ) [source] Calls the object's clear_response method. Parameters: obj : Object whose clear_response method will be called.","title":"hemlock.functions.compile.clear_response"},{"location":"compile_functions/#examples_2","text":"from hemlock import Compile, Input, Page, push_app_context push_app_context() p = Compile.clear_response(Page(Input(response='Hello World'))) p.preview()._compile().preview()","title":"Examples"},{"location":"compile_functions/#hemlockfunctionscompileshuffle","text":"def hemlock.functions.compile. shuffle ( obj, *attrs ) [source] Shuffle an object's attributes. Parameters: obj : Objects whose attributes should be shuffled. *attrs : str Names of attributes to shuffle.","title":"hemlock.functions.compile.shuffle"},{"location":"compile_functions/#notes","text":"If the object is a hemlock.Page , the default shuffled attribute is its questions . If the object is a hemlock.ChoiceQuestion , the default shuffled attribute is its choices .","title":"Notes"},{"location":"compile_functions/#examples_3","text":"from hemlock import Compile, Label, Page, push_app_context push_app_context() p = Compile.shuffle(Page( Label('<p>Label {}</p>'.format(i)) for i in range(4) )) p.preview()._compile().preview()","title":"Examples"},{"location":"comprehension/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Comprehension check hemlock.tools. comprehension_check def hemlock.tools. comprehension_check ( branch, instructions, checks, attempts=None ) [source] Add a comprehension check to a branch. A comprehension check consists of 'instruction' pages followed by 'check' pages. The data of all questions in a check page must evaluate to True to pass the check. When a participant fails a check, he is brought back to the first instructions page. Participants only have to pass each check once. For example, suppose there are two checks, A and B. The participant passes check A but fails check B. He is brought back to the first page of the instructions. After rereading the instructions, he is brought directly to check B, skipping check A. Parameters: branch : hemlock.Branch Branch to which the comprehension check is attached. instructions : hemlock.Page or list of hemlock.Page Instruction page(s). checks : hemlock.Page or list of hemlock.Page Check page(s). attempts : int or None, default=None Number of attempts allotted. Participants are allowed to proceed with the survey after exceeding the maximum number of attempts. If None , participants must pass the comprehension check before continuing the survey. Returns: branch : hemlock.Branch The original branch, with added comprehension check. Notes This function adds a hemlock.Submit function to each check page. This must be the last submit function of each check page. Examples We have two files in our root directory. In survey.py : from hemlock import Branch, Page, Label, Input, Submit, route from hemlock.tools import comprehension_check INSTRUCTIONS = '<p>Here are some instructions.</p>' CHECK = '<p>Enter \"hello world\" or you... shall not... PASS!</p>' @route('/survey') def start(): branch = comprehension_check( Branch(), instructions=Page(Label(INSTRUCTIONS)), checks=Page(Submit.match(Input(CHECK), 'hello world')) ) branch.pages.append(Page(Label('<p>You passed the test!</p>'))) return branch In app.py : import survey from hemlock import create_app app = create_app() if __name__ == '__main__': from hemlock.app import socketio socketio.run(app, debug=True) Run the app with: $ python app.py # or python3 app.py Open your browser to http://localhost:5000/ .","title":"Comprehension check"},{"location":"comprehension/#comprehension-check","text":"","title":"Comprehension check"},{"location":"comprehension/#hemlocktoolscomprehension_check","text":"def hemlock.tools. comprehension_check ( branch, instructions, checks, attempts=None ) [source] Add a comprehension check to a branch. A comprehension check consists of 'instruction' pages followed by 'check' pages. The data of all questions in a check page must evaluate to True to pass the check. When a participant fails a check, he is brought back to the first instructions page. Participants only have to pass each check once. For example, suppose there are two checks, A and B. The participant passes check A but fails check B. He is brought back to the first page of the instructions. After rereading the instructions, he is brought directly to check B, skipping check A. Parameters: branch : hemlock.Branch Branch to which the comprehension check is attached. instructions : hemlock.Page or list of hemlock.Page Instruction page(s). checks : hemlock.Page or list of hemlock.Page Check page(s). attempts : int or None, default=None Number of attempts allotted. Participants are allowed to proceed with the survey after exceeding the maximum number of attempts. If None , participants must pass the comprehension check before continuing the survey. Returns: branch : hemlock.Branch The original branch, with added comprehension check.","title":"hemlock.tools.comprehension_check"},{"location":"comprehension/#notes","text":"This function adds a hemlock.Submit function to each check page. This must be the last submit function of each check page.","title":"Notes"},{"location":"comprehension/#examples","text":"We have two files in our root directory. In survey.py : from hemlock import Branch, Page, Label, Input, Submit, route from hemlock.tools import comprehension_check INSTRUCTIONS = '<p>Here are some instructions.</p>' CHECK = '<p>Enter \"hello world\" or you... shall not... PASS!</p>' @route('/survey') def start(): branch = comprehension_check( Branch(), instructions=Page(Label(INSTRUCTIONS)), checks=Page(Submit.match(Input(CHECK), 'hello world')) ) branch.pages.append(Page(Label('<p>You passed the test!</p>'))) return branch In app.py : import survey from hemlock import create_app app = create_app() if __name__ == '__main__': from hemlock.app import socketio socketio.run(app, debug=True) Run the app with: $ python app.py # or python3 app.py Open your browser to http://localhost:5000/ .","title":"Examples"},{"location":"debug/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Debugger The debugger sends 'AI participants' through the survey. The AI participants attempt to break the survey by clicking random objects and entering random responses. Notes If your app is running on a different local host port than 5000, set the url root as an environment variable before opening the python shell in your second terminal: $ export ULR_ROOT=http://localhost:xxxx If your application import is not app.app , set the import as an enviornment variable before opening the python shell in your second terminal: $ export APP_IMPORT=path.to.app AI participants run in batches of specified sizes. For local debugging, I recommend a batch size of 1. For production debugging, you can safely go up to 3. Examples This example debugs an app locally. In survey.py : from hemlock import Branch, Page, Label, route @route('/survey') def start(): x = 1/0 return Branch(Page(Label('<p>Hello World</p>'), terminal=True)) In app.py : import survey from hemlock import create_app app = create_app() if __name__ == '__main__': from hemlock.app import socketio socketio.run(app) Open a terminal and run the app with: $ python app.py $ or python3 app.py Open a second terminal and open the python shell with: $ python # or python3 Run the debugger in the second terminal: >>> from hemlock.debug import AIParticipant, debug >>> debug() The debugger will open a chromedriver and attempt to complete the survey. The first terminal window will display this error: File \"/home/<username>/hemlock/survey.py\", line 9, in start x = 1/0 ZeroDivisionError: division by zero hemlock.debug. debug def hemlock.debug. debug ( num_batches=1, batch_size=1 ) [source] Run the debugger. Parameters: num_batches : int, default=1 Number of batches of AI participants to run. batch_size : int, default=1 Number of AI participants to run per batch. Returns: result : bool True if all AI participants in all batches run sucessfully. Otherwise, the program will crash. Notes When called from the command line tool, num_batches and batch_size are passed as strings. hemlock.debug. run_batch def hemlock.debug. run_batch ( batch_size=1 ) [source] Run a batch of AI participants. Parameters: batch_size : int, default=1 Number of AI participants to run in this batch. Returns: result : bool True if all AI participants in this batch run successfully. Otherwise, the program will crash. hemlock.debug. run_participant def hemlock.debug. run_participant ( ) [source] Run a single AI participant through the survey. Assert that the participant does not encounter failures or errors. Returns: result : bool True if the participant ran successfully.","title":"Debugging"},{"location":"debug/#debugger","text":"The debugger sends 'AI participants' through the survey. The AI participants attempt to break the survey by clicking random objects and entering random responses.","title":"Debugger"},{"location":"debug/#notes","text":"If your app is running on a different local host port than 5000, set the url root as an environment variable before opening the python shell in your second terminal: $ export ULR_ROOT=http://localhost:xxxx If your application import is not app.app , set the import as an enviornment variable before opening the python shell in your second terminal: $ export APP_IMPORT=path.to.app AI participants run in batches of specified sizes. For local debugging, I recommend a batch size of 1. For production debugging, you can safely go up to 3.","title":"Notes"},{"location":"debug/#examples","text":"This example debugs an app locally. In survey.py : from hemlock import Branch, Page, Label, route @route('/survey') def start(): x = 1/0 return Branch(Page(Label('<p>Hello World</p>'), terminal=True)) In app.py : import survey from hemlock import create_app app = create_app() if __name__ == '__main__': from hemlock.app import socketio socketio.run(app) Open a terminal and run the app with: $ python app.py $ or python3 app.py Open a second terminal and open the python shell with: $ python # or python3 Run the debugger in the second terminal: >>> from hemlock.debug import AIParticipant, debug >>> debug() The debugger will open a chromedriver and attempt to complete the survey. The first terminal window will display this error: File \"/home/<username>/hemlock/survey.py\", line 9, in start x = 1/0 ZeroDivisionError: division by zero","title":"Examples"},{"location":"debug/#hemlockdebugdebug","text":"def hemlock.debug. debug ( num_batches=1, batch_size=1 ) [source] Run the debugger. Parameters: num_batches : int, default=1 Number of batches of AI participants to run. batch_size : int, default=1 Number of AI participants to run per batch. Returns: result : bool True if all AI participants in all batches run sucessfully. Otherwise, the program will crash.","title":"hemlock.debug.debug"},{"location":"debug/#notes_1","text":"When called from the command line tool, num_batches and batch_size are passed as strings.","title":"Notes"},{"location":"debug/#hemlockdebugrun_batch","text":"def hemlock.debug. run_batch ( batch_size=1 ) [source] Run a batch of AI participants. Parameters: batch_size : int, default=1 Number of AI participants to run in this batch. Returns: result : bool True if all AI participants in this batch run successfully. Otherwise, the program will crash.","title":"hemlock.debug.run_batch"},{"location":"debug/#hemlockdebugrun_participant","text":"def hemlock.debug. run_participant ( ) [source] Run a single AI participant through the survey. Assert that the participant does not encounter failures or errors. Returns: result : bool True if the participant ran successfully.","title":"hemlock.debug.run_participant"},{"location":"debug_functions/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Debug functions Debug functions tell the AI participant what to do during debugging. They generally take a selenium webdriver as their first argument and a page or question as their second argument. Notes The following examples open a webdriver. After running the examples, close the driver with driver.close() . By default, the last debug function of a page navigates. To remove this, run page.debug_functions.pop() . hemlock.functions.debug. forward def hemlock.functions.debug. forward ( driver, page ) [source] Click the forward button. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page Examples from hemlock import Debug, Page, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() p = Page() # by default, last debug function navigates # so we want to remove this and replace it with forward p.debug_functions.pop() Debug.forward(p) p.preview(driver)._debug(driver) hemlock.functions.debug. back def hemlock.functions.debug. back ( driver, page ) [source] Click the back button. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page Examples from hemlock import Debug, Page, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() p = Page(back=True) # by default, last debug function navigates # so we want to remove this and replace it with forward p.debug_functions.pop() Debug.back(p) p.preview(driver)._debug(driver) hemlock.functions.debug. send_keys def hemlock.functions.debug. send_keys ( driver, question, *keys, p_num=0.5 ) [source] Send the specified keys to the <textarea> or <input> . Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question *keys : Keys to send to the textarea or input. If empty, keys are randomly selected. p_num : float, default=.5 Probability of sending a random number if keys are not specified (as opposed to a random string). Examples from hemlock import Debug, Input, Page, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() p = Page(Debug.send_keys(Input(), 'hello world')) p.preview(driver)._debug(driver) hemlock.functions.debug. random_str def hemlock.functions.debug. random_str ( driver, question, magnitude=2, p_whitespace=0.2 ) [source] Send a random string to the textarea. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question magnitude : int, default=2 Maximum magnitude of the length of the string. e.g. the default magnitude of 2 means that the maximum length is 10^2=100 characters. p_whitespace : float, default=.2 Frequency with which whitespace characters appear in the string. Examples from hemlock import Debug, Input, Page, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() p = Page(Debug.random_str(Input())) p.preview(driver)._debug(driver) hemlock.functions.debug. random_number def hemlock.functions.debug. random_number ( driver, question, *args, **kwargs ) [source] Send a random number to the textarea or input. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question magn_lb : int, default=0 Lower bound for the magnitude of the number. mag_ub : int, default=10 Upper bound for the magnitude of the number. max_decimals : int, default=5 Maximum number of decimals to which the number can be rounded. p_int : float, default=.5 Probability that the number is an integer. p_neg : float, default=.1 Probability that the number is negative. Examples from hemlock import Debug, Input, Page, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() p = Page(Debug.random_number(Input())) p.preview(driver)._debug(driver) hemlock.functions.debug. send_datetime def hemlock.functions.debug. send_datetime ( driver, question, datetime_=None ) [source] Send a datetime.datetime object to an input. Inputs should be of type 'date', 'datetime-local', 'month', 'time', or 'week', Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question datetime_ : datetime.datetime or None, default=None The datetime object to send. If None , a date and time are chosen randomly. Examples from hemlock import Debug, Input, Page, push_app_context from hemlock.tools import chromedriver from datetime import datetime push_app_context() driver = chromedriver() p = Page(Debug.send_datetime(Input(input_type='date'), datetime.utcnow())) p.preview(driver)._debug(driver) hemlock.functions.debug. drag_range def hemlock.functions.debug. drag_range ( driver, range_, target=None, tol=0, max_iter=10 ) [source] Drag a range slider to specified target value. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver range_ : hemlock.Range target : float or None, default=None Target value to which the slider should be dragged. If None , a random target value will be chosen. tol : float, default=0 Tolerance for error if the slider cannot be dragged to the exact target. max_iter : int, default=10 Maximum number of iterations for the slider to reach the target. Examples from hemlock import Debug, Page, Range, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() p = Page(Debug.drag_range(Range(), 80)) p.preview(driver)._debug(driver) hemlock.functions.debug. click_choices def hemlock.functions.debug. click_choices ( driver, question, *choices ) [source] Click on choices or options. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.ChoiceQuestion *choices : hemlock.Choice Choices on which to click. If no choices are specified, the debugger will click on random choices. Examples from hemlock import Check, Debug, Page, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() check = Check('<p>Check label</p>', ['Yes','No']) p = Page(Debug.click_choices(check, check.choices[0])) p.preview(driver)._debug(driver) hemlock.functions.debug. clear_choices def hemlock.functions.debug. clear_choices ( driver, question ) [source] Clear selected choices. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.ChoiceQuestion Notes Intended only for questions in which multiple choices may be selected. Examples from hemlock import Check, Debug, Page, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() check = Check('<p>Check label</p>', ['Yes','No'], multiple=True) check.default = list(check.choices) p = Page(Debug.clear_choices(check)) p.preview(driver)._debug(driver)","title":"Debug"},{"location":"debug_functions/#debug-functions","text":"Debug functions tell the AI participant what to do during debugging. They generally take a selenium webdriver as their first argument and a page or question as their second argument.","title":"Debug functions"},{"location":"debug_functions/#notes","text":"The following examples open a webdriver. After running the examples, close the driver with driver.close() . By default, the last debug function of a page navigates. To remove this, run page.debug_functions.pop() .","title":"Notes"},{"location":"debug_functions/#hemlockfunctionsdebugforward","text":"def hemlock.functions.debug. forward ( driver, page ) [source] Click the forward button. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page","title":"hemlock.functions.debug.forward"},{"location":"debug_functions/#examples","text":"from hemlock import Debug, Page, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() p = Page() # by default, last debug function navigates # so we want to remove this and replace it with forward p.debug_functions.pop() Debug.forward(p) p.preview(driver)._debug(driver)","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugback","text":"def hemlock.functions.debug. back ( driver, page ) [source] Click the back button. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page","title":"hemlock.functions.debug.back"},{"location":"debug_functions/#examples_1","text":"from hemlock import Debug, Page, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() p = Page(back=True) # by default, last debug function navigates # so we want to remove this and replace it with forward p.debug_functions.pop() Debug.back(p) p.preview(driver)._debug(driver)","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugsend_keys","text":"def hemlock.functions.debug. send_keys ( driver, question, *keys, p_num=0.5 ) [source] Send the specified keys to the <textarea> or <input> . Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question *keys : Keys to send to the textarea or input. If empty, keys are randomly selected. p_num : float, default=.5 Probability of sending a random number if keys are not specified (as opposed to a random string).","title":"hemlock.functions.debug.send_keys"},{"location":"debug_functions/#examples_2","text":"from hemlock import Debug, Input, Page, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() p = Page(Debug.send_keys(Input(), 'hello world')) p.preview(driver)._debug(driver)","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugrandom_str","text":"def hemlock.functions.debug. random_str ( driver, question, magnitude=2, p_whitespace=0.2 ) [source] Send a random string to the textarea. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question magnitude : int, default=2 Maximum magnitude of the length of the string. e.g. the default magnitude of 2 means that the maximum length is 10^2=100 characters. p_whitespace : float, default=.2 Frequency with which whitespace characters appear in the string.","title":"hemlock.functions.debug.random_str"},{"location":"debug_functions/#examples_3","text":"from hemlock import Debug, Input, Page, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() p = Page(Debug.random_str(Input())) p.preview(driver)._debug(driver)","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugrandom_number","text":"def hemlock.functions.debug. random_number ( driver, question, *args, **kwargs ) [source] Send a random number to the textarea or input. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question magn_lb : int, default=0 Lower bound for the magnitude of the number. mag_ub : int, default=10 Upper bound for the magnitude of the number. max_decimals : int, default=5 Maximum number of decimals to which the number can be rounded. p_int : float, default=.5 Probability that the number is an integer. p_neg : float, default=.1 Probability that the number is negative.","title":"hemlock.functions.debug.random_number"},{"location":"debug_functions/#examples_4","text":"from hemlock import Debug, Input, Page, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() p = Page(Debug.random_number(Input())) p.preview(driver)._debug(driver)","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugsend_datetime","text":"def hemlock.functions.debug. send_datetime ( driver, question, datetime_=None ) [source] Send a datetime.datetime object to an input. Inputs should be of type 'date', 'datetime-local', 'month', 'time', or 'week', Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question datetime_ : datetime.datetime or None, default=None The datetime object to send. If None , a date and time are chosen randomly.","title":"hemlock.functions.debug.send_datetime"},{"location":"debug_functions/#examples_5","text":"from hemlock import Debug, Input, Page, push_app_context from hemlock.tools import chromedriver from datetime import datetime push_app_context() driver = chromedriver() p = Page(Debug.send_datetime(Input(input_type='date'), datetime.utcnow())) p.preview(driver)._debug(driver)","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugdrag_range","text":"def hemlock.functions.debug. drag_range ( driver, range_, target=None, tol=0, max_iter=10 ) [source] Drag a range slider to specified target value. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver range_ : hemlock.Range target : float or None, default=None Target value to which the slider should be dragged. If None , a random target value will be chosen. tol : float, default=0 Tolerance for error if the slider cannot be dragged to the exact target. max_iter : int, default=10 Maximum number of iterations for the slider to reach the target.","title":"hemlock.functions.debug.drag_range"},{"location":"debug_functions/#examples_6","text":"from hemlock import Debug, Page, Range, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() p = Page(Debug.drag_range(Range(), 80)) p.preview(driver)._debug(driver)","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugclick_choices","text":"def hemlock.functions.debug. click_choices ( driver, question, *choices ) [source] Click on choices or options. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.ChoiceQuestion *choices : hemlock.Choice Choices on which to click. If no choices are specified, the debugger will click on random choices.","title":"hemlock.functions.debug.click_choices"},{"location":"debug_functions/#examples_7","text":"from hemlock import Check, Debug, Page, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() check = Check('<p>Check label</p>', ['Yes','No']) p = Page(Debug.click_choices(check, check.choices[0])) p.preview(driver)._debug(driver)","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugclear_choices","text":"def hemlock.functions.debug. clear_choices ( driver, question ) [source] Clear selected choices. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.ChoiceQuestion","title":"hemlock.functions.debug.clear_choices"},{"location":"debug_functions/#notes_1","text":"Intended only for questions in which multiple choices may be selected.","title":"Notes"},{"location":"debug_functions/#examples_8","text":"from hemlock import Check, Debug, Page, push_app_context from hemlock.tools import chromedriver push_app_context() driver = chromedriver() check = Check('<p>Check label</p>', ['Yes','No'], multiple=True) check.default = list(check.choices) p = Page(Debug.clear_choices(check)) p.preview(driver)._debug(driver)","title":"Examples"},{"location":"download/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Download button See https://dsbowen.github.io/flask-download-btn/ for more details. hemlock. Download class hemlock. Download ( label='', template='hemlock/download.html', **kwargs ) [source] Allows participants to download files. Inherits from flask_download_btn.DownloadBtnMixin and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Download button label. template : str, default='hemlock/download.html' Download button body template. Relationships: create_file_functions : list of hemlock.CreateFile Functions for creating files and executing other operations after form handling and before beginning download. More on [file creation] (https://dsbowen.github.io/flask-download-btn/create/). handle_form_functions : list of hemlock.HandleForm Functions for making the download button responsive to web forms. These functions are executed before file creation functions. More on form handling . Examples from hemlock import Download, Page, push_app_context app = push_app_context() Page(Download( '<p>Click here to download a file.</p>', downloads=[('HELLO_WORLD_URL', 'hello_world.txt')] )).preview() Replace 'HELLO_WORLD_URL' with your file download URL. Note that the download button will not download your file from a preview. hemlock. CreateFile Function models for creating files and executing other operations after form handling and before download. Inherits from hemlock.models.FunctionRegistrar . hemlock. HandleForm Function models for form handling. Inherits from hemlock.models.FunctionRegistrar .","title":"Download"},{"location":"download/#download-button","text":"See https://dsbowen.github.io/flask-download-btn/ for more details.","title":"Download button"},{"location":"download/#hemlockdownload","text":"class hemlock. Download ( label='', template='hemlock/download.html', **kwargs ) [source] Allows participants to download files. Inherits from flask_download_btn.DownloadBtnMixin and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Download button label. template : str, default='hemlock/download.html' Download button body template. Relationships: create_file_functions : list of hemlock.CreateFile Functions for creating files and executing other operations after form handling and before beginning download. More on [file creation] (https://dsbowen.github.io/flask-download-btn/create/). handle_form_functions : list of hemlock.HandleForm Functions for making the download button responsive to web forms. These functions are executed before file creation functions. More on form handling .","title":"hemlock.Download"},{"location":"download/#examples","text":"from hemlock import Download, Page, push_app_context app = push_app_context() Page(Download( '<p>Click here to download a file.</p>', downloads=[('HELLO_WORLD_URL', 'hello_world.txt')] )).preview() Replace 'HELLO_WORLD_URL' with your file download URL. Note that the download button will not download your file from a preview.","title":"Examples"},{"location":"download/#hemlockcreatefile","text":"Function models for creating files and executing other operations after form handling and before download. Inherits from hemlock.models.FunctionRegistrar .","title":"hemlock.CreateFile"},{"location":"download/#hemlockhandleform","text":"Function models for form handling. Inherits from hemlock.models.FunctionRegistrar .","title":"hemlock.HandleForm"},{"location":"embedded/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Embedded data and timers hemlock. Embedded class hemlock. Embedded ( var=None, data=None, data_rows=1, **kwargs ) [source] Embedded data belong to a branch or page. Use embedded data to manually input data to the dataframe; as opposed to recording data from participant responses. Polymorphic with hemlock.models.Data . Parameters: var : str or None, default=None Variable name associated with this data element. If None , the data will not be recorded. data : sqlalchemy_mutable.MutableType Data this element contributes to the dataframe. data_rows : int, default=1 Number of rows this data element contributes to the dataframe for its participant. If negative, this data element will 'fill in' any emtpy rows at the end of the dataframe with its most recent value. Relationships: participant : hemlock.Participant or None The participant to whom this data element belongs. branch : hemlock.Branch or None The branch to which the embedded data element belongs. page : hemlock.Page or None The page to which this embedded data element belongs. Examples from hemlock import Branch, Embedded, Page, Participant, push_app_context def start(): return Branch(Page()) app = push_app_context() part = Participant.gen_test_participant(start) part.embedded = [Embedded('Name', 'Socrates', data_rows=-1)] part.get_data() Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 4, 17, 57, 23, 854272)], 'StartTime': [datetime.datetime(2020, 7, 4, 17, 57, 23, 854272)], 'Status': ['InProgress'], 'Name': ['Socrates'], 'NameOrder': [0], 'NameIndex': [0]} hemlock. Timer class hemlock. Timer ( var=None, data_rows=1, **kwargs ) [source] Tracks how much time a participant spends in various parts of the survey. Inherits from hemlock.Embedded . Attributes: data : float or None Read only. Number of seconds for which the timer has been running. end_time : datetime.datetime or None Read only. If the timer is running, this is the current time. If the timer is paused, this is the time at which the timer was last paused. start_time : datetime.datetime or None The time at which the timer was started. state : str 'not started' , 'running ', or 'paused' . total_time : datetime.timedelta or None Read only. Total time the timer has been running. Examples from hemlock import Timer, push_app_context import time app = push_app_context() timer = Timer() print(timer.state) timer.start() print(timer.state) time.sleep(1) print(timer.data) timer.pause() time.sleep(1) print(timer.data) Out: not started running 1.001034 1.001381 Methods start ( self ) [source] Start the timer. Returns: self : hemlock.Timer pause ( self ) [source] Pause the timer. Returns: self : hemlock.Timer reset ( self ) [source] Reset all attributes to their default values. Returns: self : hemlock.Timer","title":"Embedded data and timers"},{"location":"embedded/#embedded-data-and-timers","text":"","title":"Embedded data and timers"},{"location":"embedded/#hemlockembedded","text":"class hemlock. Embedded ( var=None, data=None, data_rows=1, **kwargs ) [source] Embedded data belong to a branch or page. Use embedded data to manually input data to the dataframe; as opposed to recording data from participant responses. Polymorphic with hemlock.models.Data . Parameters: var : str or None, default=None Variable name associated with this data element. If None , the data will not be recorded. data : sqlalchemy_mutable.MutableType Data this element contributes to the dataframe. data_rows : int, default=1 Number of rows this data element contributes to the dataframe for its participant. If negative, this data element will 'fill in' any emtpy rows at the end of the dataframe with its most recent value. Relationships: participant : hemlock.Participant or None The participant to whom this data element belongs. branch : hemlock.Branch or None The branch to which the embedded data element belongs. page : hemlock.Page or None The page to which this embedded data element belongs.","title":"hemlock.Embedded"},{"location":"embedded/#examples","text":"from hemlock import Branch, Embedded, Page, Participant, push_app_context def start(): return Branch(Page()) app = push_app_context() part = Participant.gen_test_participant(start) part.embedded = [Embedded('Name', 'Socrates', data_rows=-1)] part.get_data() Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 4, 17, 57, 23, 854272)], 'StartTime': [datetime.datetime(2020, 7, 4, 17, 57, 23, 854272)], 'Status': ['InProgress'], 'Name': ['Socrates'], 'NameOrder': [0], 'NameIndex': [0]}","title":"Examples"},{"location":"embedded/#hemlocktimer","text":"class hemlock. Timer ( var=None, data_rows=1, **kwargs ) [source] Tracks how much time a participant spends in various parts of the survey. Inherits from hemlock.Embedded . Attributes: data : float or None Read only. Number of seconds for which the timer has been running. end_time : datetime.datetime or None Read only. If the timer is running, this is the current time. If the timer is paused, this is the time at which the timer was last paused. start_time : datetime.datetime or None The time at which the timer was started. state : str 'not started' , 'running ', or 'paused' . total_time : datetime.timedelta or None Read only. Total time the timer has been running.","title":"hemlock.Timer"},{"location":"embedded/#examples_1","text":"from hemlock import Timer, push_app_context import time app = push_app_context() timer = Timer() print(timer.state) timer.start() print(timer.state) time.sleep(1) print(timer.data) timer.pause() time.sleep(1) print(timer.data) Out: not started running 1.001034 1.001381","title":"Examples"},{"location":"embedded/#methods","text":"start ( self ) [source] Start the timer. Returns: self : hemlock.Timer pause ( self ) [source] Pause the timer. Returns: self : hemlock.Timer reset ( self ) [source] Reset all attributes to their default values. Returns: self : hemlock.Timer","title":"Methods"},{"location":"file/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } File upload hemlock. upload_to_bucket def hemlock. upload_to_bucket ( file_ ) [source] Default hemlock.File submit function. Uploads a participant file to Google bucket. Parameters: file_ : hemlock.File hemlock. File class hemlock. File ( label='', template='hemlock/file.html', **kwargs ) [source] Allows participants to upload files. Inherits from hemlock.qpolymorphs.InputGroup , hemlock.models.InputBase , and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Upload file label. template : str, default='hemlock/file.html' Template for the file upload body. Attributes: allowed_extensions : list Allowed file extensions, e.g. ['.png','.jpeg'] . filename : str Name of the file as stored in the Google bucket. Examples Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket, and GOOGLE_APPLICATION_CREDENTIALS to the name of your Google application credentials JSON file . export BUCKET=<my-bucket> GOOGLE_APPLICATION_CREDENTIALS=<my-credentials.json> In survey.py : from hemlock import Branch, File, Page, Label, route @route('/survey') def start(): return Branch( Page(File( '<p>Upload a .png</p>', filename='upload', allowed_extensions=['.png'] )), Page(Label('<p>The End</p>'), terminal=True) ) In app.py : import survey from hemlock import create_app app = create_app() if __name__ == '__main__': from hemlock.app import socketio socketio.run(app, debug=True) Run the app locally with: $ python app.py # or python3 app.py And open your browser to http://localhost:5000/ . Upload a .png and click to the next page. You'll find your uploaded file in your Google bucket in participant-1/upload.png . Methods generate_signed_url ( self, expiration=timedelta(hours=0.5), **kwargs ) [source] Generate a signed URL for the uploaded file. Parameters: expiration : datetime.timedelta, default=datetime.timedelta(0, 1800) Duration for which this signed URL is valid. **kwargs : Additional keyword arguments are passed to the generate_signed_url method. Notes Read more about signed URLs . get_allowed_types ( self ) [source] Returns: allowed_types : list List of allowed mimetypes. Derived from self.allowed_extensions . get_path ( self ) [source] Returns: path : str Path to the uploaded file in the Google bucket.","title":"File upload"},{"location":"file/#file-upload","text":"","title":"File upload"},{"location":"file/#hemlockupload_to_bucket","text":"def hemlock. upload_to_bucket ( file_ ) [source] Default hemlock.File submit function. Uploads a participant file to Google bucket. Parameters: file_ : hemlock.File","title":"hemlock.upload_to_bucket"},{"location":"file/#hemlockfile","text":"class hemlock. File ( label='', template='hemlock/file.html', **kwargs ) [source] Allows participants to upload files. Inherits from hemlock.qpolymorphs.InputGroup , hemlock.models.InputBase , and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Upload file label. template : str, default='hemlock/file.html' Template for the file upload body. Attributes: allowed_extensions : list Allowed file extensions, e.g. ['.png','.jpeg'] . filename : str Name of the file as stored in the Google bucket.","title":"hemlock.File"},{"location":"file/#examples","text":"Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket, and GOOGLE_APPLICATION_CREDENTIALS to the name of your Google application credentials JSON file . export BUCKET=<my-bucket> GOOGLE_APPLICATION_CREDENTIALS=<my-credentials.json> In survey.py : from hemlock import Branch, File, Page, Label, route @route('/survey') def start(): return Branch( Page(File( '<p>Upload a .png</p>', filename='upload', allowed_extensions=['.png'] )), Page(Label('<p>The End</p>'), terminal=True) ) In app.py : import survey from hemlock import create_app app = create_app() if __name__ == '__main__': from hemlock.app import socketio socketio.run(app, debug=True) Run the app locally with: $ python app.py # or python3 app.py And open your browser to http://localhost:5000/ . Upload a .png and click to the next page. You'll find your uploaded file in your Google bucket in participant-1/upload.png .","title":"Examples"},{"location":"file/#methods","text":"generate_signed_url ( self, expiration=timedelta(hours=0.5), **kwargs ) [source] Generate a signed URL for the uploaded file. Parameters: expiration : datetime.timedelta, default=datetime.timedelta(0, 1800) Duration for which this signed URL is valid. **kwargs : Additional keyword arguments are passed to the generate_signed_url method.","title":"Methods"},{"location":"file/#notes","text":"Read more about signed URLs . get_allowed_types ( self ) [source] Returns: allowed_types : list List of allowed mimetypes. Derived from self.allowed_extensions . get_path ( self ) [source] Returns: path : str Path to the uploaded file in the Google bucket.","title":"Notes"},{"location":"functions/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Function models hemlock. FunctionRegistrar Mixin for Function models which provides a method for function registration. Inherits from sqlalchemy_function.FunctionMixin . Attributes: index : int or None Order in which this Function will be executed, relative to other Functions belonging to the same parent object. Methods register ( cls, func ) [source] This decorator registers a function. Parameters: func : callable The function to register. hemlock. Compile Helps compile a page or question html before it is rendered and displayed to a participant. Inherits from hemlock.FunctionRegistrar . Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs. Examples from hemlock import Compile, Input, Label, Page, push_app_context app = push_app_context() @Compile.register def greet(greet_q, name_q): greet_q.label = '<p>Hello {}!</p>'.format(name_q.response) name_q = Input(\"<p>What's your name?</p>\") p = Page(Compile.greet(Label(), name_q)) name_q.response = 'World' p._compile().preview() hemlock. Debug class hemlock. Debug ( *args, **kwargs ) [source] Run to help debug the survey. Inherits from hemlock.FunctionRegistrar . Attributes: p_exec : float, default=1. Probability that the debug function will execute. You can set this by passing in an p_exec keyword argument to the constructor. Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs. Examples from hemlock import Debug, Input, Page, push_app_context from hemlock.tools import chromedriver app = push_app_context() driver = chromedriver() @Debug.register def greet(driver, greet_q): inpt = greet_q.input_from_driver(driver) inpt.clear() inpt.send_keys('Hello World!') p = Page(Debug.greet(Input('<p>Enter a greeting.</p>'))) p.preview(driver)._debug(driver) Methods __call__ ( self, *args, **kwargs ) [source] Execute the debug function with probability self.p_exec . register ( cls, func ) [source] Similar to the Function Registrar's register function, but does not add functions if the NO_DEBUG_FUNCTIONS environment variable is set. Parameters: func : callable The function to register. hemlock. Validate class hemlock. Validate ( *args, **kwargs ) [source] Validates a participant's response. Inherits from hemlock.FunctionRegistrar . Attributes: error_msg : str or None If the validate function returns an error message, the error_msg attribute is returned instead of the output of the validate function. You can set this by passing in an error_msg keyword argument to the constructor. Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs. Examples from hemlock import Input, Validate, push_app_context push_app_context() @Validate.register def my_validate_func(inpt): if inpt.response != 'hello world': return '<p>You entered \"{}\", not \"hello world\"</p>'.format(inpt.response) inpt = Validate.my_validate_func(Input('<p>Enter \"hello world\"</p>')) inpt.response = 'goodbye moon' inpt._validate() inpt.error Out: You entered \"goodbye moon\", not \"hello world\" Methods __call__ ( self, *args, **kwargs ) [source] Returns: error_msg : str or None Return None if there is no error. If there is an error, return self.error_msg or the output of self.func . hemlock. Submit Runs after a participant has successfully submitted a page. Inherits from hemlock.FunctionRegistrar . Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs. Examples from hemlock import Input, Submit, push_app_context push_app_context() @Submit.register def get_initials(name_q): names = name_q.response.split() name_q.data = '.'.join([name[0] for name in names]) + '.' inpt = Submit.get_initials(Input(\"<p>What's your name?</p>\")) inpt.response = 'Andrew Yang' inpt._submit() inpt.data Out: A.Y. hemlock. Navigate Creates a new branch to which the participant will navigate. Relationships: branch : hemlock.Branch or None Branch to which this model belongs. page : hemlock.Page or None Page to which this model belongs. Examples from hemlock import Branch, Navigate, Page, Participant, push_app_context def start(): return Navigate.end(Branch(Page())) @Navigate.register def end(start_branch): return Branch(Page(terminal=True)) app = push_app_context() part = Participant.gen_test_participant(start) part.view_nav() Out: <Branch 1> <Page 1> C C = current page T = terminal page In: part.forward().view_nav() Out: <Branch 1> <Page 1> <Branch 2> <Page 2> C T C = current page T = terminal page Methods __call__ ( self, *args, **kwargs ) [source] Create a new branch and 'link' it to the tree. Linking in the new branch involves setting the next_branch and origin_branch or origin_page relationships.","title":"Function models"},{"location":"functions/#function-models","text":"","title":"Function models"},{"location":"functions/#hemlockfunctionregistrar","text":"Mixin for Function models which provides a method for function registration. Inherits from sqlalchemy_function.FunctionMixin . Attributes: index : int or None Order in which this Function will be executed, relative to other Functions belonging to the same parent object.","title":"hemlock.FunctionRegistrar"},{"location":"functions/#methods","text":"register ( cls, func ) [source] This decorator registers a function. Parameters: func : callable The function to register.","title":"Methods"},{"location":"functions/#hemlockcompile","text":"Helps compile a page or question html before it is rendered and displayed to a participant. Inherits from hemlock.FunctionRegistrar . Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs.","title":"hemlock.Compile"},{"location":"functions/#examples","text":"from hemlock import Compile, Input, Label, Page, push_app_context app = push_app_context() @Compile.register def greet(greet_q, name_q): greet_q.label = '<p>Hello {}!</p>'.format(name_q.response) name_q = Input(\"<p>What's your name?</p>\") p = Page(Compile.greet(Label(), name_q)) name_q.response = 'World' p._compile().preview()","title":"Examples"},{"location":"functions/#hemlockdebug","text":"class hemlock. Debug ( *args, **kwargs ) [source] Run to help debug the survey. Inherits from hemlock.FunctionRegistrar . Attributes: p_exec : float, default=1. Probability that the debug function will execute. You can set this by passing in an p_exec keyword argument to the constructor. Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs.","title":"hemlock.Debug"},{"location":"functions/#examples_1","text":"from hemlock import Debug, Input, Page, push_app_context from hemlock.tools import chromedriver app = push_app_context() driver = chromedriver() @Debug.register def greet(driver, greet_q): inpt = greet_q.input_from_driver(driver) inpt.clear() inpt.send_keys('Hello World!') p = Page(Debug.greet(Input('<p>Enter a greeting.</p>'))) p.preview(driver)._debug(driver)","title":"Examples"},{"location":"functions/#methods_1","text":"__call__ ( self, *args, **kwargs ) [source] Execute the debug function with probability self.p_exec . register ( cls, func ) [source] Similar to the Function Registrar's register function, but does not add functions if the NO_DEBUG_FUNCTIONS environment variable is set. Parameters: func : callable The function to register.","title":"Methods"},{"location":"functions/#hemlockvalidate","text":"class hemlock. Validate ( *args, **kwargs ) [source] Validates a participant's response. Inherits from hemlock.FunctionRegistrar . Attributes: error_msg : str or None If the validate function returns an error message, the error_msg attribute is returned instead of the output of the validate function. You can set this by passing in an error_msg keyword argument to the constructor. Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs.","title":"hemlock.Validate"},{"location":"functions/#examples_2","text":"from hemlock import Input, Validate, push_app_context push_app_context() @Validate.register def my_validate_func(inpt): if inpt.response != 'hello world': return '<p>You entered \"{}\", not \"hello world\"</p>'.format(inpt.response) inpt = Validate.my_validate_func(Input('<p>Enter \"hello world\"</p>')) inpt.response = 'goodbye moon' inpt._validate() inpt.error Out: You entered \"goodbye moon\", not \"hello world\"","title":"Examples"},{"location":"functions/#methods_2","text":"__call__ ( self, *args, **kwargs ) [source] Returns: error_msg : str or None Return None if there is no error. If there is an error, return self.error_msg or the output of self.func .","title":"Methods"},{"location":"functions/#hemlocksubmit","text":"Runs after a participant has successfully submitted a page. Inherits from hemlock.FunctionRegistrar . Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs.","title":"hemlock.Submit"},{"location":"functions/#examples_3","text":"from hemlock import Input, Submit, push_app_context push_app_context() @Submit.register def get_initials(name_q): names = name_q.response.split() name_q.data = '.'.join([name[0] for name in names]) + '.' inpt = Submit.get_initials(Input(\"<p>What's your name?</p>\")) inpt.response = 'Andrew Yang' inpt._submit() inpt.data Out: A.Y.","title":"Examples"},{"location":"functions/#hemlocknavigate","text":"Creates a new branch to which the participant will navigate. Relationships: branch : hemlock.Branch or None Branch to which this model belongs. page : hemlock.Page or None Page to which this model belongs.","title":"hemlock.Navigate"},{"location":"functions/#examples_4","text":"from hemlock import Branch, Navigate, Page, Participant, push_app_context def start(): return Navigate.end(Branch(Page())) @Navigate.register def end(start_branch): return Branch(Page(terminal=True)) app = push_app_context() part = Participant.gen_test_participant(start) part.view_nav() Out: <Branch 1> <Page 1> C C = current page T = terminal page In: part.forward().view_nav() Out: <Branch 1> <Page 1> <Branch 2> <Page 2> C T C = current page T = terminal page","title":"Examples"},{"location":"functions/#methods_3","text":"__call__ ( self, *args, **kwargs ) [source] Create a new branch and 'link' it to the tree. Linking in the new branch involves setting the next_branch and origin_branch or origin_page relationships.","title":"Methods"},{"location":"input/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Input hemlock. debug_func def hemlock. debug_func ( driver, question ) [source] Default debug function for input questions. This function sends a random string or number if the input takes text, or a random datetime.datetime object if the input takes dates or times. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Input hemlock. Input class hemlock. Input ( label='', template='hemlock/input.html', **kwargs ) [source] Inputs take text input by default, or other types of html inputs. Inherits from hemlock.qpolymorphs.InputGroup , hemlock.models.InputBase and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Input label. template : str, default='hemlock/input.html' Template for the input body. Attributes: input_type : str, default='text' Type of html input. See https://www.w3schools.com/html/html_form_input_types.asp . Examples from hemlock import Input, Page, push_app_context app = push_app_context() Page(Input('<p>Input text here.</p>')).preview()","title":"Input"},{"location":"input/#input","text":"","title":"Input"},{"location":"input/#hemlockdebug_func","text":"def hemlock. debug_func ( driver, question ) [source] Default debug function for input questions. This function sends a random string or number if the input takes text, or a random datetime.datetime object if the input takes dates or times. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Input","title":"hemlock.debug_func"},{"location":"input/#hemlockinput","text":"class hemlock. Input ( label='', template='hemlock/input.html', **kwargs ) [source] Inputs take text input by default, or other types of html inputs. Inherits from hemlock.qpolymorphs.InputGroup , hemlock.models.InputBase and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Input label. template : str, default='hemlock/input.html' Template for the input body. Attributes: input_type : str, default='text' Type of html input. See https://www.w3schools.com/html/html_form_input_types.asp .","title":"hemlock.Input"},{"location":"input/#examples","text":"from hemlock import Input, Page, push_app_context app = push_app_context() Page(Input('<p>Input text here.</p>')).preview()","title":"Examples"},{"location":"input_group/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Input group base hemlock. InputGroup A base class for questions with input groups . Attributes: append : str Text appended to the input field. Specifically, the text of the div.input-group-append tag. prepend : str Text prepended to the input field. Specifically, the text of the div.input-group-prepend tag.","title":"Input group"},{"location":"input_group/#input-group-base","text":"","title":"Input group base"},{"location":"input_group/#hemlockinputgroup","text":"A base class for questions with input groups . Attributes: append : str Text appended to the input field. Specifically, the text of the div.input-group-append tag. prepend : str Text prepended to the input field. Specifically, the text of the div.input-group-prepend tag.","title":"hemlock.InputGroup"},{"location":"label/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Label hemlock. Label class hemlock. Label ( label='', template='hemlock/form-group.html', **kwargs ) [source] This question contains a label and does not receive input from the participant. Parameters: label : str or bs4.BeautifulSoup, default='' Question label. template : str, default='hemlock/form-group.html' Path to the Jinja template for the label body. Examples from hemlock import Label, Page, push_app_context app = push_app_context() Page(Label('<p>Hello World</p>')).preview()","title":"Label"},{"location":"label/#label","text":"","title":"Label"},{"location":"label/#hemlocklabel","text":"class hemlock. Label ( label='', template='hemlock/form-group.html', **kwargs ) [source] This question contains a label and does not receive input from the participant. Parameters: label : str or bs4.BeautifulSoup, default='' Question label. template : str, default='hemlock/form-group.html' Path to the Jinja template for the label body.","title":"hemlock.Label"},{"location":"label/#examples","text":"from hemlock import Label, Page, push_app_context app = push_app_context() Page(Label('<p>Hello World</p>')).preview()","title":"Examples"},{"location":"lang/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Language tools hemlock.tools. indef_article def hemlock.tools. indef_article ( word ) [source] Parameters: word : str Word to which the indefinite article belongs. Returns: article : str 'an' if word starts with a vowel, or 'a' otherwise, followed by the word. Examples from hemlock.tools import indef_article [indef_article(fruit) for fruit in ('apple','banana')] Out: ['an apple', 'a banana'] hemlock.tools. join def hemlock.tools. join ( joiner, *items ) [source] Parameters: joiner : str Joins the first n-1 items with the last item, e.g. 'and' . *items : str Items to join. Returns: joined : str Joined items. Examples from hemlock.tools import join print(join('and', 'world', 'sun')) print(join('or', 'world', 'sun', 'moon')) Out: world and sun world, sun, or moon hemlock.tools. plural def hemlock.tools. plural ( n, singular, plural=None ) [source] Parameters: n : int Number. singular : str The singular form of the word. plural : str or None, default=None The plural form of the word. If None , the plural form is assumed to be the singular + 's'. Returns: word : str The singular form if number is 1, plural form otherwise. Examples from hemlock.tools import plural ['{} {}'.format(n, plural(n, 'cat')) for n in range(0,3)] Out: ['0 cats', '1 cat', '2 cats'] hemlock.tools. pronouns def hemlock.tools. pronouns ( person, singular, gender=None, pfx='' ) [source] Parameters: person : int 1 , 2 , or 3 for first, second, or third person. singular : bool True for singular, False for plural. gender : str or None, default=None 'male' , 'female' , 'neuter' , or 'epicene' . Required for third person singular pronouns. pfx : str, default='' Prefix for dictionary keys. Use this to distinguish between multiple entities in a single string. Returns: pronouns : dict Mapping of pronoun keys to pronouns. Pronoun keys are 'subject' , 'object' , 'dep_poss' (dependent possessive), 'indep_poss' , (indepedent possessive), 'reflex' (reflexive). Examples from hemlock.tools import pronouns string = ''' {A_subject} said hello to {B_object} as {B_subject} was walking {B_dep_poss} neighbor's dog. 'Is that dog {B_indep_poss}?', {A_subject} thought to {A_reflex}. ''' string.format( **pronouns(3, True, 'male', pfx='A_'), **pronouns(3, True, 'female', pfx='B_') ) Out: he said hello to her as she was walking her neighbor's dog. 'Is that dog hers?', he thought to himself. In: string.format( **pronouns(3, True, 'female', pfx='A_'), **pronouns(3, True, 'male', pfx='B_') ) Out: she said hello to him as he was walking his neighbor's dog. 'Is that dog his?', she thought to herself.","title":"Language"},{"location":"lang/#language-tools","text":"","title":"Language tools"},{"location":"lang/#hemlocktoolsindef_article","text":"def hemlock.tools. indef_article ( word ) [source] Parameters: word : str Word to which the indefinite article belongs. Returns: article : str 'an' if word starts with a vowel, or 'a' otherwise, followed by the word.","title":"hemlock.tools.indef_article"},{"location":"lang/#examples","text":"from hemlock.tools import indef_article [indef_article(fruit) for fruit in ('apple','banana')] Out: ['an apple', 'a banana']","title":"Examples"},{"location":"lang/#hemlocktoolsjoin","text":"def hemlock.tools. join ( joiner, *items ) [source] Parameters: joiner : str Joins the first n-1 items with the last item, e.g. 'and' . *items : str Items to join. Returns: joined : str Joined items.","title":"hemlock.tools.join"},{"location":"lang/#examples_1","text":"from hemlock.tools import join print(join('and', 'world', 'sun')) print(join('or', 'world', 'sun', 'moon')) Out: world and sun world, sun, or moon","title":"Examples"},{"location":"lang/#hemlocktoolsplural","text":"def hemlock.tools. plural ( n, singular, plural=None ) [source] Parameters: n : int Number. singular : str The singular form of the word. plural : str or None, default=None The plural form of the word. If None , the plural form is assumed to be the singular + 's'. Returns: word : str The singular form if number is 1, plural form otherwise.","title":"hemlock.tools.plural"},{"location":"lang/#examples_2","text":"from hemlock.tools import plural ['{} {}'.format(n, plural(n, 'cat')) for n in range(0,3)] Out: ['0 cats', '1 cat', '2 cats']","title":"Examples"},{"location":"lang/#hemlocktoolspronouns","text":"def hemlock.tools. pronouns ( person, singular, gender=None, pfx='' ) [source] Parameters: person : int 1 , 2 , or 3 for first, second, or third person. singular : bool True for singular, False for plural. gender : str or None, default=None 'male' , 'female' , 'neuter' , or 'epicene' . Required for third person singular pronouns. pfx : str, default='' Prefix for dictionary keys. Use this to distinguish between multiple entities in a single string. Returns: pronouns : dict Mapping of pronoun keys to pronouns. Pronoun keys are 'subject' , 'object' , 'dep_poss' (dependent possessive), 'indep_poss' , (indepedent possessive), 'reflex' (reflexive).","title":"hemlock.tools.pronouns"},{"location":"lang/#examples_3","text":"from hemlock.tools import pronouns string = ''' {A_subject} said hello to {B_object} as {B_subject} was walking {B_dep_poss} neighbor's dog. 'Is that dog {B_indep_poss}?', {A_subject} thought to {A_reflex}. ''' string.format( **pronouns(3, True, 'male', pfx='A_'), **pronouns(3, True, 'female', pfx='B_') ) Out: he said hello to her as she was walking her neighbor's dog. 'Is that dog hers?', he thought to himself. In: string.format( **pronouns(3, True, 'female', pfx='A_'), **pronouns(3, True, 'male', pfx='B_') ) Out: she said hello to him as he was walking his neighbor's dog. 'Is that dog his?', she thought to herself.","title":"Examples"},{"location":"navbar/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Navigation bar Examples from hemlock import Page, push_app_context from hemlock.tools import Navbar, Navitem, Navitemdd, Dropdownitem app = push_app_context() url_root = 'https://dsbowen.github.io/' navbar = Navbar( 'Hemlock', [ Navitem('Application', href=url_root+'app'), Navitemdd( 'Tools', [ Dropdownitem('Language', href=url_root+'lang'), Dropdownitem('Navbar', href=url_root+'navbar') ] ) ], href=url_root+'hemlock' ) Page(navbar=navbar.render()).preview() hemlock.tools. NavBase class hemlock.tools. NavBase ( template, **kwargs ) [source] All navigation models inherit from this base. Parameters: template : str Path to template file. This is not a Jinja template, as you may wish to generate html for statics outside the application context. **kwargs : Any attribute of navigation objects can be set by passing it as a keyword argument. Attributes: a : bs4.Tag <a> tag. body : bs4.BeautifulSoup (sqlalchemy_mutablesoup.MutableSoup) Html container. label : str Navigation object label. href : str Hyperref associated with the object. Methods is_active ( self ) [source] Returns: is_active : bool Indicates that the object's href is active. hemlock.tools. Navbar class hemlock.tools. Navbar ( label='', navitems=[], template=os.path.join(DIR, 'navbar.html'), **kwargs ) [source] Parameters: label : str, default='' Navbar brand. navitems : list of hemlock.tools.Navitem and hemlock.tools.Navitemdd Navigation items associated with the navbar. template : str, default='directory/navbar.html' By default, this is a file stored in the directory of the current file. Methods render ( self ) [source] Returns: redered : bs4.BeautifulSoup A copy of self.body with rendered navitems. hemlock.tools. Navitem class hemlock.tools. Navitem ( label='', template=os.path.join(DIR, 'navitem.html'), ** kwargs ) [source] Navigation item without dropdown items. Parameters: label : str, default='' template : str, default='directory/navitem.html' By default, this is a file stored in the directory of the current file. Methods render ( self ) [source] Returns: rendered : bs4.BeautifulSoup Copy of self.body . hemlock.tools. Navitemdd class hemlock.tools. Navitemdd ( label='', dropdownitems=[], template=os.path.join(DIR, 'navitemdd.html'), **kwargs ) [source] Navigation item with dropdown items. Parameters: label : str, default='' dropdownitems : list of hemlock.tools.Dropdownitem template : str, default='directory/navitemdd.html' By default, this is a file stored in the directory of the current file. Methods render ( self ) [source] Returns: rendered : bs4.BeautifulSoup A copy of self.body with rendered dropdown items. hemlock.tools. Dropdownitem class hemlock.tools. Dropdownitem ( label='', template=os.path.join(DIR, 'dropdownitem.html' ), **kwargs ) [source] Parameters: label : str, default='' template : str, default='directory/dropdownitem.html' By default, this is a file stored in the directory of the current file. Methods render ( self ) [source] Returns: rendered : bs4.BeautifulSoup Copy of self.body .","title":"Navbar"},{"location":"navbar/#navigation-bar","text":"","title":"Navigation bar"},{"location":"navbar/#examples","text":"from hemlock import Page, push_app_context from hemlock.tools import Navbar, Navitem, Navitemdd, Dropdownitem app = push_app_context() url_root = 'https://dsbowen.github.io/' navbar = Navbar( 'Hemlock', [ Navitem('Application', href=url_root+'app'), Navitemdd( 'Tools', [ Dropdownitem('Language', href=url_root+'lang'), Dropdownitem('Navbar', href=url_root+'navbar') ] ) ], href=url_root+'hemlock' ) Page(navbar=navbar.render()).preview()","title":"Examples"},{"location":"navbar/#hemlocktoolsnavbase","text":"class hemlock.tools. NavBase ( template, **kwargs ) [source] All navigation models inherit from this base. Parameters: template : str Path to template file. This is not a Jinja template, as you may wish to generate html for statics outside the application context. **kwargs : Any attribute of navigation objects can be set by passing it as a keyword argument. Attributes: a : bs4.Tag <a> tag. body : bs4.BeautifulSoup (sqlalchemy_mutablesoup.MutableSoup) Html container. label : str Navigation object label. href : str Hyperref associated with the object.","title":"hemlock.tools.NavBase"},{"location":"navbar/#methods","text":"is_active ( self ) [source] Returns: is_active : bool Indicates that the object's href is active.","title":"Methods"},{"location":"navbar/#hemlocktoolsnavbar","text":"class hemlock.tools. Navbar ( label='', navitems=[], template=os.path.join(DIR, 'navbar.html'), **kwargs ) [source] Parameters: label : str, default='' Navbar brand. navitems : list of hemlock.tools.Navitem and hemlock.tools.Navitemdd Navigation items associated with the navbar. template : str, default='directory/navbar.html' By default, this is a file stored in the directory of the current file.","title":"hemlock.tools.Navbar"},{"location":"navbar/#methods_1","text":"render ( self ) [source] Returns: redered : bs4.BeautifulSoup A copy of self.body with rendered navitems.","title":"Methods"},{"location":"navbar/#hemlocktoolsnavitem","text":"class hemlock.tools. Navitem ( label='', template=os.path.join(DIR, 'navitem.html'), ** kwargs ) [source] Navigation item without dropdown items. Parameters: label : str, default='' template : str, default='directory/navitem.html' By default, this is a file stored in the directory of the current file.","title":"hemlock.tools.Navitem"},{"location":"navbar/#methods_2","text":"render ( self ) [source] Returns: rendered : bs4.BeautifulSoup Copy of self.body .","title":"Methods"},{"location":"navbar/#hemlocktoolsnavitemdd","text":"class hemlock.tools. Navitemdd ( label='', dropdownitems=[], template=os.path.join(DIR, 'navitemdd.html'), **kwargs ) [source] Navigation item with dropdown items. Parameters: label : str, default='' dropdownitems : list of hemlock.tools.Dropdownitem template : str, default='directory/navitemdd.html' By default, this is a file stored in the directory of the current file.","title":"hemlock.tools.Navitemdd"},{"location":"navbar/#methods_3","text":"render ( self ) [source] Returns: rendered : bs4.BeautifulSoup A copy of self.body with rendered dropdown items.","title":"Methods"},{"location":"navbar/#hemlocktoolsdropdownitem","text":"class hemlock.tools. Dropdownitem ( label='', template=os.path.join(DIR, 'dropdownitem.html' ), **kwargs ) [source] Parameters: label : str, default='' template : str, default='directory/dropdownitem.html' By default, this is a file stored in the directory of the current file.","title":"hemlock.tools.Dropdownitem"},{"location":"navbar/#methods_4","text":"render ( self ) [source] Returns: rendered : bs4.BeautifulSoup Copy of self.body .","title":"Methods"},{"location":"page/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Page The survey 'flow' is: Compile. Execute a page's compile functions. By default, a page's first compile function runs its questions' compile methods in index order. Render. Render the page for the participant and wait for them to respond. Record response. Record the participant's response to every question on the page. This sets the response attribute of the questions. Validate. When the participant attempts to submit the page, validate the responses. As with the compile method, the validate method executes a page's validate functions in index order. By default, a page's first validate function runs its questions' validate methods in index order. Record data. Record the data associated with the participant's responses to every question on the page. This sets the data attribute of the questions. Submit. Execute the page's submit functions. By default, a page's first submit function runs its questions' submit methods in index order. Navigate. If the page has a navigate function, create a new branch originating from this page. hemlock. compile_func def hemlock. compile_func ( page ) [source] Default page compile function; executes its questions' compile methods in index order. Parameters: page : hemlock.Page hemlock. validate_func def hemlock. validate_func ( page ) [source] Default page validate function; executes its questions' validate methods in index order. Parameters: page : hemlock.Page hemlock. submit_func def hemlock. submit_func ( page ) [source] Default page submit function; executes its questions' submit methods in index order. Parameters: page : hemlock.Page hemlock. debug_func def hemlock. debug_func ( driver, page ) [source] Default page debug function; execute its questions' debug methods in random order. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page hemlock. navigate def hemlock. navigate ( driver, page, p_forward=0.8, p_back=0.1, sleep_time=3 ) [source] This method randomly navigates forward or backward, or refreshes the page. By default it is executed after the default page debug function. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page p_forward : float, default=.8 Probability of clicking the forward button. p_back : float, default=.1 Probability of clicking the back button. sleep_time : float, default=3 Number of seconds to sleep if there is no forward or back button on the page. Notes The probability of refreshing the page is 1-p_forward-p_back . hemlock. Page class hemlock. Page ( *questions, template='hemlock/page-body.html', timer_var =None, **kwargs ) [source] Pages are queued in a branch. A page contains a list of questions which it displays to the participant in index order. It inherits from hemlock.model.HTMLMixin . Parameters: *questions : list of hemlock.Question, default=[] Questions to be displayed on this page. template : str, default='hemlock/page-body.html' Template for the page body . timer_var : str or None, default=None Variable name of self.Timer . Attributes: back : str or None, default=None Text of the back button. If None , no back button will appear on the page. You may also set back to True , which will set the text to '<<' . banner : str or bs4.Tag, default=hemlock banner Banner at the bottom of the page. cache_compile : bool, default=False Indicates that this page should cache the result of its compile functions. Specifically, it removes all compile functions and the compile worker from the page self self._compile is called. direction_from : str or None, default=None Direction in which the participant navigated from this page. Possible values are 'back' , 'invalid' , or 'forward' . direction_to : str or None, default=None Direction in which the participant navigated to this page. Possible values are 'back' , 'invalid' , and 'forward' . error : str or None, default=None Text of the page error message. forward : str or None, default='>>' Text of the forward button. If None , no forward button will appear on the page. You may also set forward to True , which will set the text to '>>' . g : dict, default={} Dictionary of miscellaneous objects. index : int or None, default=None Order in which this page appears in its branch's page queue. navbar : sqlalchemy_mutablesoup.MutableSoupType Navigation bar. terminal : bool, default=False Indicates that the survey terminates on this page. viewed : bool, default=False Indicates that the participant has viewed this page. Relationships: part : hemlock.Participant or None, default=None Participant to which this page belongs. Read only; derived from self. branch . branch : hemlock.Branch or None, default=None Branch to which this page belongs. next_branch : hemlock.Branch or None, default=None Branch which originated from this page. This is automatically set when this page runs its navigate function. back_to : hemlock.Page or None Page to which this page navigates when going back. If None , this page navigates back to the previous page. forward_to : hemlock.Page or None Page to which this page navigates when going forward. If None , this page navigates to the next page. embedded : list of hemlock.Embedded, default=[] List of embedded data elements. timer : hemlock.Timer or None, default=hemlock.Timer Tracks timing data for this page. questions : list of hemlock.Question, default=[] List of questions which this page displays to its participant. data_elements : list of hemlock.DataElement List of data elements which belong to this page; in order, self. timer , self.embedded , self.questions . compile_functions : list of hemlock.Compile List of compile functions; run before the page is rendered. The default page compile function runs its questions' compile functions in index order. compile_worker : hemlock.CompileWorker or None, default=None Worker which sends the compile functions to a Redis queue. validate_functions : list of hemlock.Validate List of validate functions; run to validate participant responses. The default page validate function runs its questions' validate functions in index order. validate_worker : hemlock.ValidateWorker or None, default=None Worker which sends the validate functions to a Redis queue. submit_functions : list of hemlock.Submit List of submit functions; run after participant responses have been validated. The default submit function runs its questions' submit functions in index order. submit_worker : hemlock.SubmitWorker or None, default=None Worker which sends the submit functions to a Redis queue. navigate_function : hemlock.Navigate or None, default=None Navigate function which returns a new branch originating from this page. navigate_worker : hemlock.NavigateWorker Worker which sends the navigate function to a Redis queue. debug_functions : list of hemlock.Debug List of debug functions; run during debugging. The default debug function runs its questions' debug functions in random order. Examples from hemlock import Page, push_app_context app = push_app_context() Page(Label('<p>Hello World</p>')).preview() Methods clear_error ( self ) [source] Clear the error message from this page and all of its questions. Returns: self : hemlock.Page clear_response ( self ) [source] Clear the response from all of this page's questions. Returns: self : hemlock.Page first_page ( self ) [source] Returns: is_first_page : bool Indicator that this is the first page in its participant's survey. is_valid ( self ) [source] Returns: valid : bool Indicator that all of the participant's responses are valid. That is, that there are no error messages on the page or any of its questions. preview ( self, driver=None ) [source] Preview the page in a browser window. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver or None, default=None Driver to preview page debugging. If None , the page will be opened in a web browser. Returns: self : hemlock.Page Notes If running in WSL, first specify the distribution as an environment variable. For example, if running in Ubuntu: $ export WSL_DISTRIBUTION=Ubuntu This method does not run the compile functions. view_nav ( self, indent=0 ) [source] Print the navigation starting at this page for debugging purposes. Parameters: indent : int, default=0 Starting indentation. Returns: self : hemlock.Page","title":"Page"},{"location":"page/#page","text":"The survey 'flow' is: Compile. Execute a page's compile functions. By default, a page's first compile function runs its questions' compile methods in index order. Render. Render the page for the participant and wait for them to respond. Record response. Record the participant's response to every question on the page. This sets the response attribute of the questions. Validate. When the participant attempts to submit the page, validate the responses. As with the compile method, the validate method executes a page's validate functions in index order. By default, a page's first validate function runs its questions' validate methods in index order. Record data. Record the data associated with the participant's responses to every question on the page. This sets the data attribute of the questions. Submit. Execute the page's submit functions. By default, a page's first submit function runs its questions' submit methods in index order. Navigate. If the page has a navigate function, create a new branch originating from this page.","title":"Page"},{"location":"page/#hemlockcompile_func","text":"def hemlock. compile_func ( page ) [source] Default page compile function; executes its questions' compile methods in index order. Parameters: page : hemlock.Page","title":"hemlock.compile_func"},{"location":"page/#hemlockvalidate_func","text":"def hemlock. validate_func ( page ) [source] Default page validate function; executes its questions' validate methods in index order. Parameters: page : hemlock.Page","title":"hemlock.validate_func"},{"location":"page/#hemlocksubmit_func","text":"def hemlock. submit_func ( page ) [source] Default page submit function; executes its questions' submit methods in index order. Parameters: page : hemlock.Page","title":"hemlock.submit_func"},{"location":"page/#hemlockdebug_func","text":"def hemlock. debug_func ( driver, page ) [source] Default page debug function; execute its questions' debug methods in random order. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page","title":"hemlock.debug_func"},{"location":"page/#hemlocknavigate","text":"def hemlock. navigate ( driver, page, p_forward=0.8, p_back=0.1, sleep_time=3 ) [source] This method randomly navigates forward or backward, or refreshes the page. By default it is executed after the default page debug function. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page p_forward : float, default=.8 Probability of clicking the forward button. p_back : float, default=.1 Probability of clicking the back button. sleep_time : float, default=3 Number of seconds to sleep if there is no forward or back button on the page.","title":"hemlock.navigate"},{"location":"page/#notes","text":"The probability of refreshing the page is 1-p_forward-p_back .","title":"Notes"},{"location":"page/#hemlockpage","text":"class hemlock. Page ( *questions, template='hemlock/page-body.html', timer_var =None, **kwargs ) [source] Pages are queued in a branch. A page contains a list of questions which it displays to the participant in index order. It inherits from hemlock.model.HTMLMixin . Parameters: *questions : list of hemlock.Question, default=[] Questions to be displayed on this page. template : str, default='hemlock/page-body.html' Template for the page body . timer_var : str or None, default=None Variable name of self.Timer . Attributes: back : str or None, default=None Text of the back button. If None , no back button will appear on the page. You may also set back to True , which will set the text to '<<' . banner : str or bs4.Tag, default=hemlock banner Banner at the bottom of the page. cache_compile : bool, default=False Indicates that this page should cache the result of its compile functions. Specifically, it removes all compile functions and the compile worker from the page self self._compile is called. direction_from : str or None, default=None Direction in which the participant navigated from this page. Possible values are 'back' , 'invalid' , or 'forward' . direction_to : str or None, default=None Direction in which the participant navigated to this page. Possible values are 'back' , 'invalid' , and 'forward' . error : str or None, default=None Text of the page error message. forward : str or None, default='>>' Text of the forward button. If None , no forward button will appear on the page. You may also set forward to True , which will set the text to '>>' . g : dict, default={} Dictionary of miscellaneous objects. index : int or None, default=None Order in which this page appears in its branch's page queue. navbar : sqlalchemy_mutablesoup.MutableSoupType Navigation bar. terminal : bool, default=False Indicates that the survey terminates on this page. viewed : bool, default=False Indicates that the participant has viewed this page. Relationships: part : hemlock.Participant or None, default=None Participant to which this page belongs. Read only; derived from self. branch . branch : hemlock.Branch or None, default=None Branch to which this page belongs. next_branch : hemlock.Branch or None, default=None Branch which originated from this page. This is automatically set when this page runs its navigate function. back_to : hemlock.Page or None Page to which this page navigates when going back. If None , this page navigates back to the previous page. forward_to : hemlock.Page or None Page to which this page navigates when going forward. If None , this page navigates to the next page. embedded : list of hemlock.Embedded, default=[] List of embedded data elements. timer : hemlock.Timer or None, default=hemlock.Timer Tracks timing data for this page. questions : list of hemlock.Question, default=[] List of questions which this page displays to its participant. data_elements : list of hemlock.DataElement List of data elements which belong to this page; in order, self. timer , self.embedded , self.questions . compile_functions : list of hemlock.Compile List of compile functions; run before the page is rendered. The default page compile function runs its questions' compile functions in index order. compile_worker : hemlock.CompileWorker or None, default=None Worker which sends the compile functions to a Redis queue. validate_functions : list of hemlock.Validate List of validate functions; run to validate participant responses. The default page validate function runs its questions' validate functions in index order. validate_worker : hemlock.ValidateWorker or None, default=None Worker which sends the validate functions to a Redis queue. submit_functions : list of hemlock.Submit List of submit functions; run after participant responses have been validated. The default submit function runs its questions' submit functions in index order. submit_worker : hemlock.SubmitWorker or None, default=None Worker which sends the submit functions to a Redis queue. navigate_function : hemlock.Navigate or None, default=None Navigate function which returns a new branch originating from this page. navigate_worker : hemlock.NavigateWorker Worker which sends the navigate function to a Redis queue. debug_functions : list of hemlock.Debug List of debug functions; run during debugging. The default debug function runs its questions' debug functions in random order.","title":"hemlock.Page"},{"location":"page/#examples","text":"from hemlock import Page, push_app_context app = push_app_context() Page(Label('<p>Hello World</p>')).preview()","title":"Examples"},{"location":"page/#methods","text":"clear_error ( self ) [source] Clear the error message from this page and all of its questions. Returns: self : hemlock.Page clear_response ( self ) [source] Clear the response from all of this page's questions. Returns: self : hemlock.Page first_page ( self ) [source] Returns: is_first_page : bool Indicator that this is the first page in its participant's survey. is_valid ( self ) [source] Returns: valid : bool Indicator that all of the participant's responses are valid. That is, that there are no error messages on the page or any of its questions. preview ( self, driver=None ) [source] Preview the page in a browser window. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver or None, default=None Driver to preview page debugging. If None , the page will be opened in a web browser. Returns: self : hemlock.Page","title":"Methods"},{"location":"page/#notes_1","text":"If running in WSL, first specify the distribution as an environment variable. For example, if running in Ubuntu: $ export WSL_DISTRIBUTION=Ubuntu This method does not run the compile functions. view_nav ( self, indent=0 ) [source] Print the navigation starting at this page for debugging purposes. Parameters: indent : int, default=0 Starting indentation. Returns: self : hemlock.Page","title":"Notes"},{"location":"participant/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Participant hemlock. Participant class hemlock. Participant ( **kwargs ) [source] The Participant class stores data for an individual survey participant and handles navigation for that participant. Inherits from hemlock.models.Base . Attributes: completed : bool, default=False Indicates that the participant has completed the survey. end_time : datetime.datetime Last time the participant submitted a page. g : dict, default={} Dictionary of miscellaneous objects. meta : dict, default={} Participant metadata, such as IP address. start_time : datetime.datetime Time at which the participant started he survey. status : str, default='InProgress' Participant's current status; 'InProgress' , 'TimedOut' , or 'Completed' . Read only; derived from self.completed and self.time_expired . time_expired : bool, default=False Indicates that the participant has exceeded their allotted time for the survey. updated : bool, default=True Indicates that the participant's data was updated after the last time their data was stored; if True , the participant's data will be re-stored when data are downloaded. Relationships: branch_stack : list of hemlock.Branch The participant's stack of branches. current_branch : hemlock.Branch Participant's current branch (head of self.branch_stack ). current_page : hemlock.Page Participant's current page (head of self.current_branch ). pages : list of hemlock.Page Pages belonging to the participant. embedded : list of hemlock.Embedded Embedded data elements belonging to the participant. data_elements : list of hemlock.DataElement List of all data elements belonging to the participant, ordered by id . Examples from hemlock import Branch, Label, Page, Participant, push_app_context def start(): return Branch(Page(Label('<p>Hello World</p>'))) app = push_app_context() part = Participant.gen_test_participant(start) part.current_page.preview() Methods back ( self, back_to=None ) [source] Navigate back for debugging purposes. Parameters: back_to : hemlock.Page or None, default=None Navigate back to this page; if None , navigate back one page. Returns: self : hemlock.Participant forward ( self, forward_to=None ) [source] Navigate forward for debugging purposes. Parameters: forward_to : hemlock.Page or None, default=None Navigate forward to this page; if None , navigate forward one page. Returns: self : hemlock.Participant gen_test_participant ( gen_root=None ) [source] Generate a test participant for debugging purposes. Parameters: gen_root : callable or None, default=None Function to generate the root branch of the participant's tree. This should return a hemlock.Branch . Returns: part : hemlock.Participant get_data ( self ) [source] Returns: df : hemlock.models.private.DataFrame Data associated with the participant. Notes Data elements are added to the dataframe in the order in which they were created (i.e. by id). This is not necessarily the order in which they appeared to the Participant. Examples get_meta ( self ) [source] This is where it gets meta. Returns: meta : dict Participant's metadata, including the ID, end time, start time, and current status. view_nav ( self ) [source] View participant's branch stack. Returns: self : hemlock.Participant","title":"Participant"},{"location":"participant/#participant","text":"","title":"Participant"},{"location":"participant/#hemlockparticipant","text":"class hemlock. Participant ( **kwargs ) [source] The Participant class stores data for an individual survey participant and handles navigation for that participant. Inherits from hemlock.models.Base . Attributes: completed : bool, default=False Indicates that the participant has completed the survey. end_time : datetime.datetime Last time the participant submitted a page. g : dict, default={} Dictionary of miscellaneous objects. meta : dict, default={} Participant metadata, such as IP address. start_time : datetime.datetime Time at which the participant started he survey. status : str, default='InProgress' Participant's current status; 'InProgress' , 'TimedOut' , or 'Completed' . Read only; derived from self.completed and self.time_expired . time_expired : bool, default=False Indicates that the participant has exceeded their allotted time for the survey. updated : bool, default=True Indicates that the participant's data was updated after the last time their data was stored; if True , the participant's data will be re-stored when data are downloaded. Relationships: branch_stack : list of hemlock.Branch The participant's stack of branches. current_branch : hemlock.Branch Participant's current branch (head of self.branch_stack ). current_page : hemlock.Page Participant's current page (head of self.current_branch ). pages : list of hemlock.Page Pages belonging to the participant. embedded : list of hemlock.Embedded Embedded data elements belonging to the participant. data_elements : list of hemlock.DataElement List of all data elements belonging to the participant, ordered by id .","title":"hemlock.Participant"},{"location":"participant/#examples","text":"from hemlock import Branch, Label, Page, Participant, push_app_context def start(): return Branch(Page(Label('<p>Hello World</p>'))) app = push_app_context() part = Participant.gen_test_participant(start) part.current_page.preview()","title":"Examples"},{"location":"participant/#methods","text":"back ( self, back_to=None ) [source] Navigate back for debugging purposes. Parameters: back_to : hemlock.Page or None, default=None Navigate back to this page; if None , navigate back one page. Returns: self : hemlock.Participant forward ( self, forward_to=None ) [source] Navigate forward for debugging purposes. Parameters: forward_to : hemlock.Page or None, default=None Navigate forward to this page; if None , navigate forward one page. Returns: self : hemlock.Participant gen_test_participant ( gen_root=None ) [source] Generate a test participant for debugging purposes. Parameters: gen_root : callable or None, default=None Function to generate the root branch of the participant's tree. This should return a hemlock.Branch . Returns: part : hemlock.Participant get_data ( self ) [source] Returns: df : hemlock.models.private.DataFrame Data associated with the participant.","title":"Methods"},{"location":"participant/#notes","text":"Data elements are added to the dataframe in the order in which they were created (i.e. by id). This is not necessarily the order in which they appeared to the Participant.","title":"Notes"},{"location":"participant/#examples_1","text":"get_meta ( self ) [source] This is where it gets meta. Returns: meta : dict Participant's metadata, including the ID, end time, start time, and current status. view_nav ( self ) [source] View participant's branch stack. Returns: self : hemlock.Participant","title":"Examples"},{"location":"question/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Questions hemlock.Question and hemlock.ChoiceQuestion are 'question skeletons'; most useful when fleshed out. See section on question polymorphs. hemlock. Question class hemlock. Question ( label='', template=None, **kwargs ) [source] Base object for questions. Questions are displayed on their page in index order. It inherits from hemlock.models.Data and hemlock.models.HTMLMixin . Parameters: label : str or bs4.BeautifulSoup, default='' Question label. template : str, default='form-group.html' Template for the question body . Attributes: default : sqlalchemy_mutable.MutableType Default question response. error : str or None, default=None Text of the question error message. label : str or None, default=None Question label. response : sqlalchemy_mutable.MutableType Participant's response. Relationships: part : hemlock.Participant or None The participant to which this question belongs. Derived from self.page . branch : hemlock.Branch or None The branch to which this question belongs. Derived from self.page . page : hemlock.Page or None The page to which this question belongs. compile_functions : list of hemlock.Compile, default=[] List of compile functions; run before the question is rendered. validate_functions : list of hemlock.Validate, default=[] List of validate functions; run to validate the participant's response. submit_functions : list of hemlock.Submit, default=[] List of submit functions; run after the participant's responses have been validated for all questions on a page. debug_functions : list of hemlock.Debug, default=[] List of debug functions; run during debugging. The default debug function is unique to the question type. Methods clear_error ( self ) [source] Clear the error message. Returns: self : hemlock.Question clear_response ( self ) [source] Clear the response. Returns: self : hemlock.Question hemlock. ChoiceQuestion class hemlock. ChoiceQuestion ( label='', choices=[], template=None, **kwargs ) [source] A question which contains choices. Inherits from hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Question label. choices : list of hemlock.Choice, default=[] Choices which belong to this question. template : str or None, default=None Template for the question body. Attributes: multiple : bool, default=False Indicates that the participant can select multiple choices. Relationships: choices : list of hemlock.Choice, default=[] Possible choices from which a participant can select.","title":"Question"},{"location":"question/#questions","text":"hemlock.Question and hemlock.ChoiceQuestion are 'question skeletons'; most useful when fleshed out. See section on question polymorphs.","title":"Questions"},{"location":"question/#hemlockquestion","text":"class hemlock. Question ( label='', template=None, **kwargs ) [source] Base object for questions. Questions are displayed on their page in index order. It inherits from hemlock.models.Data and hemlock.models.HTMLMixin . Parameters: label : str or bs4.BeautifulSoup, default='' Question label. template : str, default='form-group.html' Template for the question body . Attributes: default : sqlalchemy_mutable.MutableType Default question response. error : str or None, default=None Text of the question error message. label : str or None, default=None Question label. response : sqlalchemy_mutable.MutableType Participant's response. Relationships: part : hemlock.Participant or None The participant to which this question belongs. Derived from self.page . branch : hemlock.Branch or None The branch to which this question belongs. Derived from self.page . page : hemlock.Page or None The page to which this question belongs. compile_functions : list of hemlock.Compile, default=[] List of compile functions; run before the question is rendered. validate_functions : list of hemlock.Validate, default=[] List of validate functions; run to validate the participant's response. submit_functions : list of hemlock.Submit, default=[] List of submit functions; run after the participant's responses have been validated for all questions on a page. debug_functions : list of hemlock.Debug, default=[] List of debug functions; run during debugging. The default debug function is unique to the question type.","title":"hemlock.Question"},{"location":"question/#methods","text":"clear_error ( self ) [source] Clear the error message. Returns: self : hemlock.Question clear_response ( self ) [source] Clear the response. Returns: self : hemlock.Question","title":"Methods"},{"location":"question/#hemlockchoicequestion","text":"class hemlock. ChoiceQuestion ( label='', choices=[], template=None, **kwargs ) [source] A question which contains choices. Inherits from hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Question label. choices : list of hemlock.Choice, default=[] Choices which belong to this question. template : str or None, default=None Template for the question body. Attributes: multiple : bool, default=False Indicates that the participant can select multiple choices. Relationships: choices : list of hemlock.Choice, default=[] Possible choices from which a participant can select.","title":"hemlock.ChoiceQuestion"},{"location":"random/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Randomization tools hemlock.tools. key def hemlock.tools. key ( len_=90 ) [source] Parameters: len_ : int, default=90 Length of the key to generate. Returns: key : str Randomly generated key of ascii letters and digits of specificed length. Examples from hemlock import tools tools.key(10) Out: gpGmZuRfF7 hemlock.tools. Randomizer class hemlock.tools. Randomizer ( elements, r=1, combination=True ) [source] Evenly randomizes over a set of elements. Parameters: elements : iterable Set of elements over which to randomize. r : int, default=1 Size of the subset of elements to select. combination : bool, default=True Indicates randomization over combinations of the elements, as opposed to permutations. Attributes: elements : iterable Set from the elements parameter. Examples from hemlock.tools import Randomizer elements = ('world','moon','star') randomizer = Randomizer(elements, r=2, combination=False) randomizer.next() Out: ('moon', 'world') Methods next ( self ) [source] Returns: subset : Selected subset of elements. hemlock.tools. Assigner class hemlock.tools. Assigner ( conditions ) [source] Evenly assigns participants to conditions. Inherits from hemlock.tools.Randomizer . Parameters: conditions : dict Maps condition variable name to iterable of possible assignments. Attributes: keys : iterable Condition variable names. elements : iterable All possible combinations of condition values to which a participant may be assigned. Examples from hemlock import Participant, push_app_context from hemlock.tools import Assigner push_app_context() part = Participant.gen_test_participant() conditions = {'Treatment': (0,1), 'Level': ('low','med','high')} assigner = Assigner(conditions) assigner.next() Out: {'Treatment': 1, 'Level': 'low'} In: [(e.var, e.data) for e in part.embedded] Out: [('Treatment', 0), ('Level', 'low')] Methods next ( self ) [source] Assigns the participant to a condition. The condition assigment updates the participant's metadata. Returns: assignment : dict Maps condition variable names to assigned conditions.","title":"Randomization"},{"location":"random/#randomization-tools","text":"","title":"Randomization tools"},{"location":"random/#hemlocktoolskey","text":"def hemlock.tools. key ( len_=90 ) [source] Parameters: len_ : int, default=90 Length of the key to generate. Returns: key : str Randomly generated key of ascii letters and digits of specificed length.","title":"hemlock.tools.key"},{"location":"random/#examples","text":"from hemlock import tools tools.key(10) Out: gpGmZuRfF7","title":"Examples"},{"location":"random/#hemlocktoolsrandomizer","text":"class hemlock.tools. Randomizer ( elements, r=1, combination=True ) [source] Evenly randomizes over a set of elements. Parameters: elements : iterable Set of elements over which to randomize. r : int, default=1 Size of the subset of elements to select. combination : bool, default=True Indicates randomization over combinations of the elements, as opposed to permutations. Attributes: elements : iterable Set from the elements parameter.","title":"hemlock.tools.Randomizer"},{"location":"random/#examples_1","text":"from hemlock.tools import Randomizer elements = ('world','moon','star') randomizer = Randomizer(elements, r=2, combination=False) randomizer.next() Out: ('moon', 'world')","title":"Examples"},{"location":"random/#methods","text":"next ( self ) [source] Returns: subset : Selected subset of elements.","title":"Methods"},{"location":"random/#hemlocktoolsassigner","text":"class hemlock.tools. Assigner ( conditions ) [source] Evenly assigns participants to conditions. Inherits from hemlock.tools.Randomizer . Parameters: conditions : dict Maps condition variable name to iterable of possible assignments. Attributes: keys : iterable Condition variable names. elements : iterable All possible combinations of condition values to which a participant may be assigned.","title":"hemlock.tools.Assigner"},{"location":"random/#examples_2","text":"from hemlock import Participant, push_app_context from hemlock.tools import Assigner push_app_context() part = Participant.gen_test_participant() conditions = {'Treatment': (0,1), 'Level': ('low','med','high')} assigner = Assigner(conditions) assigner.next() Out: {'Treatment': 1, 'Level': 'low'} In: [(e.var, e.data) for e in part.embedded] Out: [('Treatment', 0), ('Level', 'low')]","title":"Examples"},{"location":"random/#methods_1","text":"next ( self ) [source] Assigns the participant to a condition. The condition assigment updates the participant's metadata. Returns: assignment : dict Maps condition variable names to assigned conditions.","title":"Methods"},{"location":"range/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Range slider hemlock. debug_func def hemlock. debug_func ( driver, question ) [source] Default debug function for range inputs. See drag_range . Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Range hemlock. Range class hemlock. Range ( label='', template='hemlock/range.html', **kwargs ) [source] Range sliders can be dragged between minimum and maximum values in step increments. Inherits from hemlock.InputBase and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Range label. template : str, default='hemlock/range.html' Template for the range body. Attributes: max : float, default=100 Maximum value of the range slider. min : float, default=0 Minimum value of the range slider. step : float, default=1 Increments in which the range slider steps. Notes Ranges have a default javascript which displays the value of the range slider to participants. This cannot be overridden by passing a js argument to the constructor, although javascript can be modified after the constructor has finished. Examples from hemlock import Range, Page, push_app_context app = push_app_context() Page(Range('<p>This is a range slider.</p>')).preview()","title":"Range"},{"location":"range/#range-slider","text":"","title":"Range slider"},{"location":"range/#hemlockdebug_func","text":"def hemlock. debug_func ( driver, question ) [source] Default debug function for range inputs. See drag_range . Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Range","title":"hemlock.debug_func"},{"location":"range/#hemlockrange","text":"class hemlock. Range ( label='', template='hemlock/range.html', **kwargs ) [source] Range sliders can be dragged between minimum and maximum values in step increments. Inherits from hemlock.InputBase and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Range label. template : str, default='hemlock/range.html' Template for the range body. Attributes: max : float, default=100 Maximum value of the range slider. min : float, default=0 Minimum value of the range slider. step : float, default=1 Increments in which the range slider steps.","title":"hemlock.Range"},{"location":"range/#notes","text":"Ranges have a default javascript which displays the value of the range slider to participants. This cannot be overridden by passing a js argument to the constructor, although javascript can be modified after the constructor has finished.","title":"Notes"},{"location":"range/#examples","text":"from hemlock import Range, Page, push_app_context app = push_app_context() Page(Range('<p>This is a range slider.</p>')).preview()","title":"Examples"},{"location":"select/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Select (dropdown) hemlock. click_choices def hemlock. click_choices ( driver, question ) [source] Default select debug function. See click choices . hemlock. Select class hemlock. Select ( label='', choices=[], template='hemlock/select.html', ** kwargs ) [source] Select questions allow participants to select one or more options from a dropdown menu. Inherits from hemlock.InputGroup and hemlock.ChoiceQuestion . Parameters: label : str or bs4.BeautifulSoup, default='' Select question label. choices : list of str or hemlock.Option, default=[] Options which participants can select. String inputs are automatically converted to hemlock.Option objects. template : str, default='hemlock/select.html' Template for the select body. Attributes: align : str, default='left' Choice alignment; 'left' , 'center' , or 'right' . multiple : bool, default=False Indicates that the participant may select multiple choices. select : bs4.Tag <select> tag. size : int or None, default=None Number of rows of choices to display. Examples from hemlock import Page, Select, Option, push_app_context app = push_app_context() Page(Select('<p>Select one.</p>', ['World','Moon','Star'])).preview()","title":"Select"},{"location":"select/#select-dropdown","text":"","title":"Select (dropdown)"},{"location":"select/#hemlockclick_choices","text":"def hemlock. click_choices ( driver, question ) [source] Default select debug function. See click choices .","title":"hemlock.click_choices"},{"location":"select/#hemlockselect","text":"class hemlock. Select ( label='', choices=[], template='hemlock/select.html', ** kwargs ) [source] Select questions allow participants to select one or more options from a dropdown menu. Inherits from hemlock.InputGroup and hemlock.ChoiceQuestion . Parameters: label : str or bs4.BeautifulSoup, default='' Select question label. choices : list of str or hemlock.Option, default=[] Options which participants can select. String inputs are automatically converted to hemlock.Option objects. template : str, default='hemlock/select.html' Template for the select body. Attributes: align : str, default='left' Choice alignment; 'left' , 'center' , or 'right' . multiple : bool, default=False Indicates that the participant may select multiple choices. select : bs4.Tag <select> tag. size : int or None, default=None Number of rows of choices to display.","title":"hemlock.Select"},{"location":"select/#examples","text":"from hemlock import Page, Select, Option, push_app_context app = push_app_context() Page(Select('<p>Select one.</p>', ['World','Moon','Star'])).preview()","title":"Examples"},{"location":"software/","text":"Software Find installations instructions for: Windows Mac and Linux in progress Here are the prerequisites I recommend to take advantage of the full range of tools Hemlock offers. Unless otherwise specified, I recommend you download the latest stable version of the following: Essential Python3 and pip3 . Python is Hemlock's primary language. pip allows you to install Python packages, including Hemlock itself. I recommend Python3.6 , the version you will use for Heroku deployment (see below). Additionally, you should be able to create virtual environments . Code editor . I work in Visual Studio (VS) Code with the Remote-WSL extension, but any code editor will do. Strongly recommended Heroku and Heroku-CLI . Heroku is an inexpensive and accessible service for deploying web applications. The Hemlock command line interface builds on the Heroku command line interface (CLI) . Git . Git is a version control system which I use to 'push' applications to Heroku. Relatedly, I recommend Github for backing up Hemlock projects and sharing them with collaborators. With the above software, you are ready to create, share, and deploy Hemlock projects. The software below is encouraged for debugging, file storage, and Redis testing. They are not essential. If you're eager to get started with Hemlock, you can come back to these if and when you need them. Encouraged Google Chrome and Chromedriver . Hemlock's custom debugging tool requires Google Chrome and Chromedriver to run locally. Google Cloud and Cloud SDK . Hemlock easily integrates with Google Cloud for storing statics (such as images to display during a survey) and user uploaded files. The Hemlock command line interface builds on Cloud Software Development Kit (SDK) . Advanced Redis . Hemlock seamlessly interfaces with Redis to run complex background processes during surveys. Redis runs natively on Mac and Linux. For Windows users, I recommend Ubuntu on Windows Subsystem for Linux (WSL) .","title":"Software"},{"location":"software/#software","text":"Find installations instructions for: Windows Mac and Linux in progress Here are the prerequisites I recommend to take advantage of the full range of tools Hemlock offers. Unless otherwise specified, I recommend you download the latest stable version of the following: Essential Python3 and pip3 . Python is Hemlock's primary language. pip allows you to install Python packages, including Hemlock itself. I recommend Python3.6 , the version you will use for Heroku deployment (see below). Additionally, you should be able to create virtual environments . Code editor . I work in Visual Studio (VS) Code with the Remote-WSL extension, but any code editor will do. Strongly recommended Heroku and Heroku-CLI . Heroku is an inexpensive and accessible service for deploying web applications. The Hemlock command line interface builds on the Heroku command line interface (CLI) . Git . Git is a version control system which I use to 'push' applications to Heroku. Relatedly, I recommend Github for backing up Hemlock projects and sharing them with collaborators. With the above software, you are ready to create, share, and deploy Hemlock projects. The software below is encouraged for debugging, file storage, and Redis testing. They are not essential. If you're eager to get started with Hemlock, you can come back to these if and when you need them. Encouraged Google Chrome and Chromedriver . Hemlock's custom debugging tool requires Google Chrome and Chromedriver to run locally. Google Cloud and Cloud SDK . Hemlock easily integrates with Google Cloud for storing statics (such as images to display during a survey) and user uploaded files. The Hemlock command line interface builds on Cloud Software Development Kit (SDK) . Advanced Redis . Hemlock seamlessly interfaces with Redis to run complex background processes during surveys. Redis runs natively on Mac and Linux. For Windows users, I recommend Ubuntu on Windows Subsystem for Linux (WSL) .","title":"Software"},{"location":"statics/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Statics Tool for generating statics (embedded images and videos). hemlock.tools. src_from_bucket def hemlock.tools. src_from_bucket ( filename ) [source] Parameters: filename : str Name of the file in the Google bucket. Returns: src : str src html attribute which references the specified file in the Google bucket. Examples Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket. $ export BUCKET=<my-bucket> Upload a file to the bucket, e.g. https://xkcd.com/2138/ and name it wanna_see_the_code.png . from hemlock import Branch, Page, Label, push_app_context from hemlock.tools import Img, src_from_bucket app = push_app_context() img = Img( src=src_from_bucket('wanna_see_the_code.png'), align='center' ).render() Page(Label(img)).preview() hemlock.tools. url_from_bucket def hemlock.tools. url_from_bucket ( filename, expiration=1800, **kwargs ) [source] Parameters: filename : str Name of the file in the Google bucket. expiration : float, default=1800 Number of seconds until the url expires. **kwargs : Keyword arguments are passed to the [ generate_signed_url method] (https://cloud.google.com/storage/docs/access-control/signed-urls). Returns: signed_url : str Signed url for the file in the app's bucket. Examples Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket, and GOOGLE_APPLICATION_CREDENTIALS to the name of your Google application credentials JSON file . $ export BUCKET=<my-bucket> GOOGLE_APPLICATION_CREDENTIALS=<my-credentials.json> In survey.py : from hemlock import Branch, Page, Download, route from hemlock.tools import url_from_bucket @route('/survey') def start(): filename = 'wanna_see_the_code.png' url = url_from_bucket(filename) return Branch(Page(Download(downloads=[(url, filename)]))) In app.py : import survey from hemlock import create_app app = create_app() if __name__ == '__main__': from hemlock.app import socketio socketio.run(app, debug=True) Run the app locally with: $ python app.py # or python3 app.py And open your browser to http://localhost:5000/ . Click on the download button to download the file from your Google bucket. hemlock.tools. Static class hemlock.tools. Static ( template, **kwargs ) [source] Base for static objects (images and videos). Parameters: template : str Path to template file. This is not a Jinja template, as you may wish to generate html for statics outside the application context. **kwargs : Any attribute of the static object can be set by passing it as a keyword argument. Attributes: body : sqlalchemy_mutablesoup.MutableSoup Html of the static object. src_params : dict Maps url parameter names to values. These will be attached to the src html attribute when the static is rendered. Methods render ( self, tag_selector=None ) [source] Parameters: tag_selector : str CSS selector for the html tag containing the src attribute. Returns: html : str Rendered html. hemlock.tools. Img class hemlock.tools. Img ( template=os.path.join(DIR, 'img.html'), **kwargs ) [source] Static image. Parameters: template : str, default='directory/img.html' Image template. By default, this is a file stored in the directory of the current file. Attributes: align : str Image alignment; 'left' , 'center' , or 'right '. caption : str Image caption. figure : bs4.Tag <figure> tag. img : bs4.Tag <img> tag. src : str src attribute of the <img> tag. Examples from hemlock import Page, Label, push_app_context from hemlock.tools import Img app = push_app_context() img = Img( src='https://imgs.xkcd.com/comics/wanna_see_the_code.png', align='center' ).render() Page(Label(img)).preview() Methods render ( self ) [source] Returns: html : str Rendered image html. hemlock.tools. Vid class hemlock.tools. Vid ( template=os.path.join(DIR, 'vid.html'), **kwargs ) [source] Static video. Parameters: template : str, default='directory/vid.html' Video template. By default, this is a file stored in the directory of the current file. Attributes: iframe : bs4.Tag <iframe> tag. src : str src attribute of the <iframe> tag. Examples from hemlock import Page, Label, push_app_context from hemlock.tools import Vid app = push_app_context() vid = Vid.from_youtube('https://www.youtube.com/watch?v=UbQgXeY_zi4') Page(Label(vid.render())).preview() Methods from_youtube ( src ) [source] Capture the YouTube video id and create an embedded src. Parameters: src : str Link to the YouTube video. Returns: vid : hemlock.tools.Vid Video object. render ( self ) [source] Returns: html : str Rendered video html.","title":"Statics"},{"location":"statics/#statics","text":"Tool for generating statics (embedded images and videos).","title":"Statics"},{"location":"statics/#hemlocktoolssrc_from_bucket","text":"def hemlock.tools. src_from_bucket ( filename ) [source] Parameters: filename : str Name of the file in the Google bucket. Returns: src : str src html attribute which references the specified file in the Google bucket.","title":"hemlock.tools.src_from_bucket"},{"location":"statics/#examples","text":"Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket. $ export BUCKET=<my-bucket> Upload a file to the bucket, e.g. https://xkcd.com/2138/ and name it wanna_see_the_code.png . from hemlock import Branch, Page, Label, push_app_context from hemlock.tools import Img, src_from_bucket app = push_app_context() img = Img( src=src_from_bucket('wanna_see_the_code.png'), align='center' ).render() Page(Label(img)).preview()","title":"Examples"},{"location":"statics/#hemlocktoolsurl_from_bucket","text":"def hemlock.tools. url_from_bucket ( filename, expiration=1800, **kwargs ) [source] Parameters: filename : str Name of the file in the Google bucket. expiration : float, default=1800 Number of seconds until the url expires. **kwargs : Keyword arguments are passed to the [ generate_signed_url method] (https://cloud.google.com/storage/docs/access-control/signed-urls). Returns: signed_url : str Signed url for the file in the app's bucket.","title":"hemlock.tools.url_from_bucket"},{"location":"statics/#examples_1","text":"Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket, and GOOGLE_APPLICATION_CREDENTIALS to the name of your Google application credentials JSON file . $ export BUCKET=<my-bucket> GOOGLE_APPLICATION_CREDENTIALS=<my-credentials.json> In survey.py : from hemlock import Branch, Page, Download, route from hemlock.tools import url_from_bucket @route('/survey') def start(): filename = 'wanna_see_the_code.png' url = url_from_bucket(filename) return Branch(Page(Download(downloads=[(url, filename)]))) In app.py : import survey from hemlock import create_app app = create_app() if __name__ == '__main__': from hemlock.app import socketio socketio.run(app, debug=True) Run the app locally with: $ python app.py # or python3 app.py And open your browser to http://localhost:5000/ . Click on the download button to download the file from your Google bucket.","title":"Examples"},{"location":"statics/#hemlocktoolsstatic","text":"class hemlock.tools. Static ( template, **kwargs ) [source] Base for static objects (images and videos). Parameters: template : str Path to template file. This is not a Jinja template, as you may wish to generate html for statics outside the application context. **kwargs : Any attribute of the static object can be set by passing it as a keyword argument. Attributes: body : sqlalchemy_mutablesoup.MutableSoup Html of the static object. src_params : dict Maps url parameter names to values. These will be attached to the src html attribute when the static is rendered.","title":"hemlock.tools.Static"},{"location":"statics/#methods","text":"render ( self, tag_selector=None ) [source] Parameters: tag_selector : str CSS selector for the html tag containing the src attribute. Returns: html : str Rendered html.","title":"Methods"},{"location":"statics/#hemlocktoolsimg","text":"class hemlock.tools. Img ( template=os.path.join(DIR, 'img.html'), **kwargs ) [source] Static image. Parameters: template : str, default='directory/img.html' Image template. By default, this is a file stored in the directory of the current file. Attributes: align : str Image alignment; 'left' , 'center' , or 'right '. caption : str Image caption. figure : bs4.Tag <figure> tag. img : bs4.Tag <img> tag. src : str src attribute of the <img> tag.","title":"hemlock.tools.Img"},{"location":"statics/#examples_2","text":"from hemlock import Page, Label, push_app_context from hemlock.tools import Img app = push_app_context() img = Img( src='https://imgs.xkcd.com/comics/wanna_see_the_code.png', align='center' ).render() Page(Label(img)).preview()","title":"Examples"},{"location":"statics/#methods_1","text":"render ( self ) [source] Returns: html : str Rendered image html.","title":"Methods"},{"location":"statics/#hemlocktoolsvid","text":"class hemlock.tools. Vid ( template=os.path.join(DIR, 'vid.html'), **kwargs ) [source] Static video. Parameters: template : str, default='directory/vid.html' Video template. By default, this is a file stored in the directory of the current file. Attributes: iframe : bs4.Tag <iframe> tag. src : str src attribute of the <iframe> tag.","title":"hemlock.tools.Vid"},{"location":"statics/#examples_3","text":"from hemlock import Page, Label, push_app_context from hemlock.tools import Vid app = push_app_context() vid = Vid.from_youtube('https://www.youtube.com/watch?v=UbQgXeY_zi4') Page(Label(vid.render())).preview()","title":"Examples"},{"location":"statics/#methods_2","text":"from_youtube ( src ) [source] Capture the YouTube video id and create an embedded src. Parameters: src : str Link to the YouTube video. Returns: vid : hemlock.tools.Vid Video object. render ( self ) [source] Returns: html : str Rendered video html.","title":"Methods"},{"location":"submit_functions/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Submit functions hemlock.functions.submit. correct_choices def hemlock.functions.submit. correct_choices ( question, correct ) [source] Convert the question's data to a 0-1 indicator that the participant selected the correct choice(s). Parameters: question : hemlock.ChoiceQuestion correct : list of hemlock.Choice Correct choices. Notes If the participant can only select one choice, indicate whether the participant selected one of the correct choices. Examples from hemlock import Check, Submit, push_app_context push_app_context() check = Check( '<p>Select one</p>', ['correct', 'incorrect', 'also incorrect'] ) correct_choice = check.choices[0] Submit.correct_choices(check, [correct_choice]) check.response = correct_choice check._submit() check.data Out: 1 hemlock.functions.submit. data_type def hemlock.functions.submit. data_type ( question, new_type, *args, **kwargs ) [source] Convert the quesiton's data to a new type. If the question's data cannot be converted, it is changed to None . Parameters: question : hemlock.Question new_type : class *args, **kwargs : Arguments and keyword arguments to pass to the new_type constructor. Examples from hemlock import Input, Submit, push_app_context push_app_context() inpt = Submit.data_type(Input(data='1'), int) inpt._submit() inpt.data, isinstance(inpt.data, int) Out: (1, True) hemlock.functions.submit. match def hemlock.functions.submit. match ( question, pattern ) [source] Convert the question's data to a 0-1 indicator that the data matches the pattern. Parameters: question : hemlock.Question pattern : str Regex pattern to match. Examples from hemlock import Input, Submit, push_app_context push_app_context() inpt = Submit.match(Input(data='hello world'), 'hello world') inpt._submit() inpt.data Out: 1","title":"Submit"},{"location":"submit_functions/#submit-functions","text":"","title":"Submit functions"},{"location":"submit_functions/#hemlockfunctionssubmitcorrect_choices","text":"def hemlock.functions.submit. correct_choices ( question, correct ) [source] Convert the question's data to a 0-1 indicator that the participant selected the correct choice(s). Parameters: question : hemlock.ChoiceQuestion correct : list of hemlock.Choice Correct choices.","title":"hemlock.functions.submit.correct_choices"},{"location":"submit_functions/#notes","text":"If the participant can only select one choice, indicate whether the participant selected one of the correct choices.","title":"Notes"},{"location":"submit_functions/#examples","text":"from hemlock import Check, Submit, push_app_context push_app_context() check = Check( '<p>Select one</p>', ['correct', 'incorrect', 'also incorrect'] ) correct_choice = check.choices[0] Submit.correct_choices(check, [correct_choice]) check.response = correct_choice check._submit() check.data Out: 1","title":"Examples"},{"location":"submit_functions/#hemlockfunctionssubmitdata_type","text":"def hemlock.functions.submit. data_type ( question, new_type, *args, **kwargs ) [source] Convert the quesiton's data to a new type. If the question's data cannot be converted, it is changed to None . Parameters: question : hemlock.Question new_type : class *args, **kwargs : Arguments and keyword arguments to pass to the new_type constructor.","title":"hemlock.functions.submit.data_type"},{"location":"submit_functions/#examples_1","text":"from hemlock import Input, Submit, push_app_context push_app_context() inpt = Submit.data_type(Input(data='1'), int) inpt._submit() inpt.data, isinstance(inpt.data, int) Out: (1, True)","title":"Examples"},{"location":"submit_functions/#hemlockfunctionssubmitmatch","text":"def hemlock.functions.submit. match ( question, pattern ) [source] Convert the question's data to a 0-1 indicator that the data matches the pattern. Parameters: question : hemlock.Question pattern : str Regex pattern to match.","title":"hemlock.functions.submit.match"},{"location":"submit_functions/#examples_2","text":"from hemlock import Input, Submit, push_app_context push_app_context() inpt = Submit.match(Input(data='hello world'), 'hello world') inpt._submit() inpt.data Out: 1","title":"Examples"},{"location":"textarea/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Textarea hemlock. debug_func def hemlock. debug_func ( driver, question ) [source] Default debug function for textarea questions. See hemlock.functions.debug.random_keys . Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Textarea hemlock. Textarea class hemlock. Textarea ( page=None, template='hemlock/textarea.html', **kwargs ) [source] Textareas provide large text boxes for free responses. Inherits from hemlock.qpolymorphs.InputGroup and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Textarea label. template : str, default='hemlock/textarea.html' Template for the textarea body. Attributes: rows : int, default=3 Number of rows of text to display. textarea : bs4.Tag The <textarea> tag. Notes Textareas have a default javascript which displays the number of words and characters entered. This cannot be overridden by passing a js argument to the constructor, although javascript can be modified after the constructor has finished. Examples from hemlock import Page, Textarea, push_app_context app = push_app_context() Page(Textarea('<p>This is a textarea.</p>')).preview() Methods textarea_from_driver ( self, driver ) [source] Get textarea from the webdriver for debugging. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver Selenium webdriver (does not need to be Chrome ). Returns: textarea : selenium.webdriver.remote.webelement.WebElement Web element of the <textarea> tag associated with this model.","title":"Textarea"},{"location":"textarea/#textarea","text":"","title":"Textarea"},{"location":"textarea/#hemlockdebug_func","text":"def hemlock. debug_func ( driver, question ) [source] Default debug function for textarea questions. See hemlock.functions.debug.random_keys . Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Textarea","title":"hemlock.debug_func"},{"location":"textarea/#hemlocktextarea","text":"class hemlock. Textarea ( page=None, template='hemlock/textarea.html', **kwargs ) [source] Textareas provide large text boxes for free responses. Inherits from hemlock.qpolymorphs.InputGroup and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Textarea label. template : str, default='hemlock/textarea.html' Template for the textarea body. Attributes: rows : int, default=3 Number of rows of text to display. textarea : bs4.Tag The <textarea> tag.","title":"hemlock.Textarea"},{"location":"textarea/#notes","text":"Textareas have a default javascript which displays the number of words and characters entered. This cannot be overridden by passing a js argument to the constructor, although javascript can be modified after the constructor has finished.","title":"Notes"},{"location":"textarea/#examples","text":"from hemlock import Page, Textarea, push_app_context app = push_app_context() Page(Textarea('<p>This is a textarea.</p>')).preview()","title":"Examples"},{"location":"textarea/#methods","text":"textarea_from_driver ( self, driver ) [source] Get textarea from the webdriver for debugging. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver Selenium webdriver (does not need to be Chrome ). Returns: textarea : selenium.webdriver.remote.webelement.WebElement Web element of the <textarea> tag associated with this model.","title":"Methods"},{"location":"utils/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Utilities hemlock.tools. chromedriver def hemlock.tools. chromedriver ( headless=False ) [source] Parameters: headless : bool, default=False Indicates whether to run Chrome in headless mode. Returns: driver : selenium.webdriver.chrome.webdriver.WebDriver Notes Chromedriver must be headless in production. When the application is in production, this method sets headless to True regardless of the parameter you pass. Examples from hemlock.tools import chromedriver driver = chromedriver() hemlock.tools. get_data def hemlock.tools. get_data ( dataframe='data' ) [source] Parameters: dataframe : str, default='data' Name of the dataframe to get; 'data' or 'meta' . Returns: data : dict Maps variable names to list of entries. May not include data from participants who are in progress. Examples from hemlock import Branch, Page, Participant, push_app_context from hemlock.tools import get_data def start(): return Branch(Page()) push_app_context() Participant.gen_test_participant(start).completed = True get_data() Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 6, 17, 11, 0, 245032)], 'StartTime': [datetime.datetime(2020, 7, 6, 17, 11, 0, 245032)], 'Status': ['Completed']} hemlock.tools. url_for def hemlock.tools. url_for ( *args, **kwargs ) [source] Attempt to return flask.url_for(*args, **kwargs) . However, this method does not exit the program when getting a url outside a request context; e.g. when debugging in a shell or notebook. Parameters: *args, **kwargs : Arguments and keyword arguments will be passed to flask.url_for . Returns: url : str Output of flask.url_for if possible; otherwise 'URL_UNAVAILABLE' .","title":"Utilities"},{"location":"utils/#utilities","text":"","title":"Utilities"},{"location":"utils/#hemlocktoolschromedriver","text":"def hemlock.tools. chromedriver ( headless=False ) [source] Parameters: headless : bool, default=False Indicates whether to run Chrome in headless mode. Returns: driver : selenium.webdriver.chrome.webdriver.WebDriver","title":"hemlock.tools.chromedriver"},{"location":"utils/#notes","text":"Chromedriver must be headless in production. When the application is in production, this method sets headless to True regardless of the parameter you pass.","title":"Notes"},{"location":"utils/#examples","text":"from hemlock.tools import chromedriver driver = chromedriver()","title":"Examples"},{"location":"utils/#hemlocktoolsget_data","text":"def hemlock.tools. get_data ( dataframe='data' ) [source] Parameters: dataframe : str, default='data' Name of the dataframe to get; 'data' or 'meta' . Returns: data : dict Maps variable names to list of entries. May not include data from participants who are in progress.","title":"hemlock.tools.get_data"},{"location":"utils/#examples_1","text":"from hemlock import Branch, Page, Participant, push_app_context from hemlock.tools import get_data def start(): return Branch(Page()) push_app_context() Participant.gen_test_participant(start).completed = True get_data() Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 6, 17, 11, 0, 245032)], 'StartTime': [datetime.datetime(2020, 7, 6, 17, 11, 0, 245032)], 'Status': ['Completed']}","title":"Examples"},{"location":"utils/#hemlocktoolsurl_for","text":"def hemlock.tools. url_for ( *args, **kwargs ) [source] Attempt to return flask.url_for(*args, **kwargs) . However, this method does not exit the program when getting a url outside a request context; e.g. when debugging in a shell or notebook. Parameters: *args, **kwargs : Arguments and keyword arguments will be passed to flask.url_for . Returns: url : str Output of flask.url_for if possible; otherwise 'URL_UNAVAILABLE' .","title":"hemlock.tools.url_for"},{"location":"validate_functions/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Validation functions These are built-in functions to validate a participant's response to a question. They return None if the response is valid, and an error message if the repsonse is invalid. hemlock.functions.validate. response_type def hemlock.functions.validate. response_type ( question, resp_type ) [source] Validate that the response can be converted to a given type. Parameters: question : hemlock.Question resp_type : class The required type of response. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.response_type(Input(response='hello world'), float) inpt._validate() inpt.error Out: Please enter a number. hemlock.functions.validate. require def hemlock.functions.validate. require ( question ) [source] Require a response to this question. Parameters: question : hemlock.Question Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.require(Input(response=None)) inpt._validate() inpt.error Out: Please respond to this question. hemlock.functions.validate. is_in def hemlock.functions.validate. is_in ( question, valid_set, resp_type=None ) [source] Validate that the question response is in a set of valid responses. Parameters: question : hemlock.Question valid_set : iterable Set of valid responses. resp_type : class or None, default=None Type of response expected; should match the type of elements in valid_set . Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.is_in(Input(response='earth'), ('wind', 'fire')) inpt._validate() inpt.error Out: Please enter wind or fire. hemlock.functions.validate. is_not_in def hemlock.functions.validate. is_not_in ( question, invalid_set, resp_type=None ) [source] Validate that the question response is not in a set of invalid responses. Parameters: question : hemlock.Question invalid_set : iterable Set of invalid responses. resp_type : class or None, default=None Type of response expected; should match the type of elements in invalid_set . Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.is_not_in( Input(response='earth'), ('earth','wind','fire') ) inpt._validate() inpt.error Out: Please do not enter earth, wind, or fire. hemlock.functions.validate. max_val def hemlock.functions.validate. max_val ( question, max_, resp_type=None ) [source] Validate that the response does not exceed a maximum value. Parameters: question : hemlock.Question max_ : Maximum value. resp_type : class or None, default=None Expected type of response. If None , the type of max will be used. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.max_val(Input(response='101'), 100) inpt._validate() inpt.error Out: Please enter a response less than 100. hemlock.functions.validate. min_val def hemlock.functions.validate. min_val ( question, min_, resp_type=None ) [source] Validate that the response does not deceed a minumum value. Parameters: question : hemlock.Question min_ : Minimum value. resp_type : class or None, default=None Expected type of response. If None , the type of min will be used. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.min_val(Input(response='-1'), 0) inpt._validate() inpt.error Out: Please enter a response greater than 0. hemlock.functions.validate. range_val def hemlock.functions.validate. range_val ( question, min_, max_, resp_type=None ) [source] Validate that the response is in a given range. Parameters: question : hemlock.Question min_ : Minimum value for the question response. max_ : Maximum value for the question response. resp_type : class or None, default=None Expected type of response. If None , the expected response type is the type of min and max , which must be of the same type. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.range_val(Input(response='101'), 0, 100) inpt._validate() inpt.error Out: Please enter a response between 0 and 100. hemlock.functions.validate. exact_len def hemlock.functions.validate. exact_len ( question, len_ ) [source] Validates the exact length of the repsonse. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question len_ : int Required length of the response. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.exact_len(Input(response='hello world'), 5) inpt._validate() inpt.error Out: Please enter exactly 5 characters. hemlock.functions.validate. max_len def hemlock.functions.validate. max_len ( question, max_ ) [source] Validates the maximum length of the response. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question max_ : int Maximum length of the response. Notes A response of None is assumed to satisfy the max length validation. Use Validate.require to require a response that is not None . Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.max_val(Input(response='hello world'), 5) inpt._validate() inpt.error Out: Please enter at most 5 characters. hemlock.functions.validate. min_len def hemlock.functions.validate. min_len ( question, min_ ) [source] Valiadates the minimum length of the response. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question min_ : int Minimum length of the response. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.min_len(Input(response='hello world'), 15) inpt._validate() inpt.error Out: Please enter at least 15 characters. hemlock.functions.validate. range_len def hemlock.functions.validate. range_len ( question, min_, max_ ) [source] Validates the range of the response length. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question min_ : int Minimum response length. max_ : int Maximum response length. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.range_len(Input(response='hello world'), 5, 10) inpt._validate() inpt.error Out: Please enter 5 to 10 characters. hemlock.functions.validate. exact_words def hemlock.functions.validate. exact_words ( question, nwords ) [source] Validate the exact number of words in the response. Parameters: question : hemlock.Question nwords : int Required number of words. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.exact_words(Input(response='hello world'), 1) inpt._validate() inpt.error Out: Please enter exactly 1 word. hemlock.functions.validate. max_words def hemlock.functions.validate. max_words ( question, max_ ) [source] Validates the maximum number of words in the response. Parameters: question : hemlock.Question max_ : int Maximum number of words. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.max_words(Input(response='hello world'), 1) inpt._validate() inpt.error Out: Please enter at most 1 word. hemlock.functions.validate. min_words def hemlock.functions.validate. min_words ( question, min_ ) [source] Validates the minimum number of words in the repsonse. Parameters: question : hemlock.Question min_ : int Minimum number of words. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.min_words(Input(response='hello world'), 3) inpt._validate() inpt.error Out: Please enter at least 3 words. hemlock.functions.validate. range_words def hemlock.functions.validate. range_words ( question, min_, max_ ) [source] Validates the number of words falls in a given range. Parameters: question : hemlock.Question min_ : int Minumum number of words. max_ : int Maximum number of words. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.range_words(Input(response='hello world'), 3, 5) inpt._validate() inpt.error Out: Please enter between 3 and 5 words. hemlock.functions.validate. exact_decimals def hemlock.functions.validate. exact_decimals ( question, ndec ) [source] Validates the exact number of decimals. Parameters: question : hemlock.Question ndec : int Required number of decimals. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.exact_decimals(Input(response='1'), 2) inpt._validate() inpt.error Out: Please enter a number with exactly 2 decimals. hemlock.functions.validate. max_decimals def hemlock.functions.validate. max_decimals ( question, max_ ) [source] Validates the maximum number of decimals. Parameters: question : hemlock.Question max_ : int Maximum number of decimals. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.max_decimals(Input(response='1.123'), 2) inpt._validate() inpt.error Out: Please enter a number with at most 2 decimals. hemlock.functions.validate. min_decimals def hemlock.functions.validate. min_decimals ( question, min_ ) [source] Validates the minumum number of decimals. Parameters: question : hemlock.Question min_ : int Minumum number of decimals. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.min_decimals(Input(response='1'), 2) inpt._validate() inpt.error Out: Please enter a number with at least 2 decimals. hemlock.functions.validate. range_decimals def hemlock.functions.validate. range_decimals ( question, min_, max_ ) [source] Validates the number of decimals are in a given range. Parameters: question : hemlock.Question min_ : int Minimum number of decimals. max_ : int Maximum number of decimals. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.range_decimals(Input(response='1.123'), 0, 2) inpt._validate() inpt.error Out: Please enter a number with 0 to 2 decimals. hemlock.functions.validate. match def hemlock.functions.validate. match ( question, pattern ) [source] Validate that the response matches the regex pattern. Parameters: question : hemlock.Question pattern : str Regex pattern to match. Examples from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.match(Input(response='hello world'), 'goodbye *') inpt._validate() inpt.error Out: Please enter a response with the correct pattern. hemlock.functions.validate. correct_choices def hemlock.functions.validate. correct_choices ( question, correct ) [source] Validate that selected choice(s) is correct. Parameters: question : hemlock.Question correct : list of hemlock.Choice Correct choices. Examples from hemlock import Check, Validate, push_app_context push_app_context() check = Check(choices=['correct','incorrect','also incorrect']) Validate.correct_choices(check, [check.choices[0]]) check.response = check.choices[1] check._validate() check.error Out: Please select the correct choice.","title":"Validate"},{"location":"validate_functions/#validation-functions","text":"These are built-in functions to validate a participant's response to a question. They return None if the response is valid, and an error message if the repsonse is invalid.","title":"Validation functions"},{"location":"validate_functions/#hemlockfunctionsvalidateresponse_type","text":"def hemlock.functions.validate. response_type ( question, resp_type ) [source] Validate that the response can be converted to a given type. Parameters: question : hemlock.Question resp_type : class The required type of response.","title":"hemlock.functions.validate.response_type"},{"location":"validate_functions/#examples","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.response_type(Input(response='hello world'), float) inpt._validate() inpt.error Out: Please enter a number.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidaterequire","text":"def hemlock.functions.validate. require ( question ) [source] Require a response to this question. Parameters: question : hemlock.Question","title":"hemlock.functions.validate.require"},{"location":"validate_functions/#examples_1","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.require(Input(response=None)) inpt._validate() inpt.error Out: Please respond to this question.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidateis_in","text":"def hemlock.functions.validate. is_in ( question, valid_set, resp_type=None ) [source] Validate that the question response is in a set of valid responses. Parameters: question : hemlock.Question valid_set : iterable Set of valid responses. resp_type : class or None, default=None Type of response expected; should match the type of elements in valid_set .","title":"hemlock.functions.validate.is_in"},{"location":"validate_functions/#examples_2","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.is_in(Input(response='earth'), ('wind', 'fire')) inpt._validate() inpt.error Out: Please enter wind or fire.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidateis_not_in","text":"def hemlock.functions.validate. is_not_in ( question, invalid_set, resp_type=None ) [source] Validate that the question response is not in a set of invalid responses. Parameters: question : hemlock.Question invalid_set : iterable Set of invalid responses. resp_type : class or None, default=None Type of response expected; should match the type of elements in invalid_set .","title":"hemlock.functions.validate.is_not_in"},{"location":"validate_functions/#examples_3","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.is_not_in( Input(response='earth'), ('earth','wind','fire') ) inpt._validate() inpt.error Out: Please do not enter earth, wind, or fire.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemax_val","text":"def hemlock.functions.validate. max_val ( question, max_, resp_type=None ) [source] Validate that the response does not exceed a maximum value. Parameters: question : hemlock.Question max_ : Maximum value. resp_type : class or None, default=None Expected type of response. If None , the type of max will be used.","title":"hemlock.functions.validate.max_val"},{"location":"validate_functions/#examples_4","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.max_val(Input(response='101'), 100) inpt._validate() inpt.error Out: Please enter a response less than 100.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemin_val","text":"def hemlock.functions.validate. min_val ( question, min_, resp_type=None ) [source] Validate that the response does not deceed a minumum value. Parameters: question : hemlock.Question min_ : Minimum value. resp_type : class or None, default=None Expected type of response. If None , the type of min will be used.","title":"hemlock.functions.validate.min_val"},{"location":"validate_functions/#examples_5","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.min_val(Input(response='-1'), 0) inpt._validate() inpt.error Out: Please enter a response greater than 0.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidaterange_val","text":"def hemlock.functions.validate. range_val ( question, min_, max_, resp_type=None ) [source] Validate that the response is in a given range. Parameters: question : hemlock.Question min_ : Minimum value for the question response. max_ : Maximum value for the question response. resp_type : class or None, default=None Expected type of response. If None , the expected response type is the type of min and max , which must be of the same type.","title":"hemlock.functions.validate.range_val"},{"location":"validate_functions/#examples_6","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.range_val(Input(response='101'), 0, 100) inpt._validate() inpt.error Out: Please enter a response between 0 and 100.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidateexact_len","text":"def hemlock.functions.validate. exact_len ( question, len_ ) [source] Validates the exact length of the repsonse. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question len_ : int Required length of the response.","title":"hemlock.functions.validate.exact_len"},{"location":"validate_functions/#examples_7","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.exact_len(Input(response='hello world'), 5) inpt._validate() inpt.error Out: Please enter exactly 5 characters.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemax_len","text":"def hemlock.functions.validate. max_len ( question, max_ ) [source] Validates the maximum length of the response. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question max_ : int Maximum length of the response.","title":"hemlock.functions.validate.max_len"},{"location":"validate_functions/#notes","text":"A response of None is assumed to satisfy the max length validation. Use Validate.require to require a response that is not None .","title":"Notes"},{"location":"validate_functions/#examples_8","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.max_val(Input(response='hello world'), 5) inpt._validate() inpt.error Out: Please enter at most 5 characters.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemin_len","text":"def hemlock.functions.validate. min_len ( question, min_ ) [source] Valiadates the minimum length of the response. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question min_ : int Minimum length of the response.","title":"hemlock.functions.validate.min_len"},{"location":"validate_functions/#examples_9","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.min_len(Input(response='hello world'), 15) inpt._validate() inpt.error Out: Please enter at least 15 characters.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidaterange_len","text":"def hemlock.functions.validate. range_len ( question, min_, max_ ) [source] Validates the range of the response length. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question min_ : int Minimum response length. max_ : int Maximum response length.","title":"hemlock.functions.validate.range_len"},{"location":"validate_functions/#examples_10","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.range_len(Input(response='hello world'), 5, 10) inpt._validate() inpt.error Out: Please enter 5 to 10 characters.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidateexact_words","text":"def hemlock.functions.validate. exact_words ( question, nwords ) [source] Validate the exact number of words in the response. Parameters: question : hemlock.Question nwords : int Required number of words.","title":"hemlock.functions.validate.exact_words"},{"location":"validate_functions/#examples_11","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.exact_words(Input(response='hello world'), 1) inpt._validate() inpt.error Out: Please enter exactly 1 word.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemax_words","text":"def hemlock.functions.validate. max_words ( question, max_ ) [source] Validates the maximum number of words in the response. Parameters: question : hemlock.Question max_ : int Maximum number of words.","title":"hemlock.functions.validate.max_words"},{"location":"validate_functions/#examples_12","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.max_words(Input(response='hello world'), 1) inpt._validate() inpt.error Out: Please enter at most 1 word.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemin_words","text":"def hemlock.functions.validate. min_words ( question, min_ ) [source] Validates the minimum number of words in the repsonse. Parameters: question : hemlock.Question min_ : int Minimum number of words.","title":"hemlock.functions.validate.min_words"},{"location":"validate_functions/#examples_13","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.min_words(Input(response='hello world'), 3) inpt._validate() inpt.error Out: Please enter at least 3 words.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidaterange_words","text":"def hemlock.functions.validate. range_words ( question, min_, max_ ) [source] Validates the number of words falls in a given range. Parameters: question : hemlock.Question min_ : int Minumum number of words. max_ : int Maximum number of words.","title":"hemlock.functions.validate.range_words"},{"location":"validate_functions/#examples_14","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.range_words(Input(response='hello world'), 3, 5) inpt._validate() inpt.error Out: Please enter between 3 and 5 words.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidateexact_decimals","text":"def hemlock.functions.validate. exact_decimals ( question, ndec ) [source] Validates the exact number of decimals. Parameters: question : hemlock.Question ndec : int Required number of decimals.","title":"hemlock.functions.validate.exact_decimals"},{"location":"validate_functions/#examples_15","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.exact_decimals(Input(response='1'), 2) inpt._validate() inpt.error Out: Please enter a number with exactly 2 decimals.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemax_decimals","text":"def hemlock.functions.validate. max_decimals ( question, max_ ) [source] Validates the maximum number of decimals. Parameters: question : hemlock.Question max_ : int Maximum number of decimals.","title":"hemlock.functions.validate.max_decimals"},{"location":"validate_functions/#examples_16","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.max_decimals(Input(response='1.123'), 2) inpt._validate() inpt.error Out: Please enter a number with at most 2 decimals.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemin_decimals","text":"def hemlock.functions.validate. min_decimals ( question, min_ ) [source] Validates the minumum number of decimals. Parameters: question : hemlock.Question min_ : int Minumum number of decimals.","title":"hemlock.functions.validate.min_decimals"},{"location":"validate_functions/#examples_17","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.min_decimals(Input(response='1'), 2) inpt._validate() inpt.error Out: Please enter a number with at least 2 decimals.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidaterange_decimals","text":"def hemlock.functions.validate. range_decimals ( question, min_, max_ ) [source] Validates the number of decimals are in a given range. Parameters: question : hemlock.Question min_ : int Minimum number of decimals. max_ : int Maximum number of decimals.","title":"hemlock.functions.validate.range_decimals"},{"location":"validate_functions/#examples_18","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.range_decimals(Input(response='1.123'), 0, 2) inpt._validate() inpt.error Out: Please enter a number with 0 to 2 decimals.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatematch","text":"def hemlock.functions.validate. match ( question, pattern ) [source] Validate that the response matches the regex pattern. Parameters: question : hemlock.Question pattern : str Regex pattern to match.","title":"hemlock.functions.validate.match"},{"location":"validate_functions/#examples_19","text":"from hemlock import Input, Validate, push_app_context push_app_context() inpt = Validate.match(Input(response='hello world'), 'goodbye *') inpt._validate() inpt.error Out: Please enter a response with the correct pattern.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatecorrect_choices","text":"def hemlock.functions.validate. correct_choices ( question, correct ) [source] Validate that selected choice(s) is correct. Parameters: question : hemlock.Question correct : list of hemlock.Choice Correct choices.","title":"hemlock.functions.validate.correct_choices"},{"location":"validate_functions/#examples_20","text":"from hemlock import Check, Validate, push_app_context push_app_context() check = Check(choices=['correct','incorrect','also incorrect']) Validate.correct_choices(check, [check.choices[0]]) check.response = check.choices[1] check._validate() check.error Out: Please select the correct choice.","title":"Examples"},{"location":"workers/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Worker models A worker may be attached to a branch or page. Each type of worker is responsible for one of its branch's of page's methods, which is expected to a be a long-running function. When called, the worker sends the method for which it is responsible to a Redis queue. While the Redis queue is processing the method, participants are shown a loading page. When the worker has finished its job, it returns the loaded page to the participant. All workers inherit from flask_worker.WorkerMixin .. hemlock. Worker Convenience methods for adding workers to branches and pages. Examples We have two files in our root directory. In survey.py : from hemlock import Branch, Page, Label, Navigate, Worker, route @route('/survey') def start(): return Worker.navigate(Navigate.end(Branch( Page(Label('<p>Hello World</p>')) ))) @Navigate.register def end(origin): return Branch(Page(Label('<p>Goodbye World</p>'), terminal=True)) In app.py : import survey from hemlock import create_app app = create_app() if __name__ == '__main__': from hemlock.app import socketio socketio.run(app, debug=True) We'll open two terminal windows. In the first, run: $ rq worker hemlock-task-queue In the second, run: $ python app.py # or python3 app.py Open your browser to http://localhost:5000 . Click the forward button and notice that the Redis queue handles the navigate function. Methods compile ( page ) [source] Parameters: page : hemlock.Page Page to which the worker is added. Returns: page : validate ( page ) [source] Parameters: page : hemlock.Page Page to which the worker is added. Returns: page : submit ( page ) [source] Parameters: page : hemlock.Page Page to which the worker is added. Returns: page : navigate ( parent ) [source] Parameters: parent : hemlock.Branch or hemlock.Page Branch or page to which the worker is added. Returns: parent : hemlock. CompileWorker Handles a page's compile method. Attributes: func : callable or None The page's _compile method. Relationships: page : hemlock.Page or None Set from the page parameter. hemlock. ValidateWorker Handles a page's validate method. Attributes: func : callable or None The page's _validate method. Relationships: page : hemlock.Page or None Set from the page parameter. hemlock. SubmitWorker Handles a page's submit method. Attributes: func : callable or None The page's _submit method. Relationships: page : hemlock.Page or None Set from the page parameter. hemlock. NavigateWorker class hemlock. NavigateWorker ( parent=None, *args, **kwargs ) [source] Handles a branch's or page's navigate method. Attributes: func : callable or None The branch's or page's navigate_function . Relationships: branch : hemlock.Branch or None Set from the parent parameter. page : hemlock.Page or None Set from the page parameter. Notes The navigate worker expects to be associated with a branch or page but not both.","title":"Workers"},{"location":"workers/#worker-models","text":"A worker may be attached to a branch or page. Each type of worker is responsible for one of its branch's of page's methods, which is expected to a be a long-running function. When called, the worker sends the method for which it is responsible to a Redis queue. While the Redis queue is processing the method, participants are shown a loading page. When the worker has finished its job, it returns the loaded page to the participant. All workers inherit from flask_worker.WorkerMixin ..","title":"Worker models"},{"location":"workers/#hemlockworker","text":"Convenience methods for adding workers to branches and pages.","title":"hemlock.Worker"},{"location":"workers/#examples","text":"We have two files in our root directory. In survey.py : from hemlock import Branch, Page, Label, Navigate, Worker, route @route('/survey') def start(): return Worker.navigate(Navigate.end(Branch( Page(Label('<p>Hello World</p>')) ))) @Navigate.register def end(origin): return Branch(Page(Label('<p>Goodbye World</p>'), terminal=True)) In app.py : import survey from hemlock import create_app app = create_app() if __name__ == '__main__': from hemlock.app import socketio socketio.run(app, debug=True) We'll open two terminal windows. In the first, run: $ rq worker hemlock-task-queue In the second, run: $ python app.py # or python3 app.py Open your browser to http://localhost:5000 . Click the forward button and notice that the Redis queue handles the navigate function.","title":"Examples"},{"location":"workers/#methods","text":"compile ( page ) [source] Parameters: page : hemlock.Page Page to which the worker is added. Returns: page : validate ( page ) [source] Parameters: page : hemlock.Page Page to which the worker is added. Returns: page : submit ( page ) [source] Parameters: page : hemlock.Page Page to which the worker is added. Returns: page : navigate ( parent ) [source] Parameters: parent : hemlock.Branch or hemlock.Page Branch or page to which the worker is added. Returns: parent :","title":"Methods"},{"location":"workers/#hemlockcompileworker","text":"Handles a page's compile method. Attributes: func : callable or None The page's _compile method. Relationships: page : hemlock.Page or None Set from the page parameter.","title":"hemlock.CompileWorker"},{"location":"workers/#hemlockvalidateworker","text":"Handles a page's validate method. Attributes: func : callable or None The page's _validate method. Relationships: page : hemlock.Page or None Set from the page parameter.","title":"hemlock.ValidateWorker"},{"location":"workers/#hemlocksubmitworker","text":"Handles a page's submit method. Attributes: func : callable or None The page's _submit method. Relationships: page : hemlock.Page or None Set from the page parameter.","title":"hemlock.SubmitWorker"},{"location":"workers/#hemlocknavigateworker","text":"class hemlock. NavigateWorker ( parent=None, *args, **kwargs ) [source] Handles a branch's or page's navigate method. Attributes: func : callable or None The branch's or page's navigate_function . Relationships: branch : hemlock.Branch or None Set from the parent parameter. page : hemlock.Page or None Set from the page parameter.","title":"hemlock.NavigateWorker"},{"location":"workers/#notes","text":"The navigate worker expects to be associated with a branch or page but not both.","title":"Notes"},{"location":"tutorial/comp_check/","text":"Comprehension check In the previous part of the tutorial, you reviewed page logic. By the end of this part of the tutorial, you'll be able to set up comprehension checks. Why comprehension checks? We often give our participants instructions. To make sure they understand the instructions, we give them comprehension checks. Hemlock has a built-in tool for easy comprehension checks. The structure of a comprehension check is: One or more pages of instructions. One or more pages of 'checks'. If the participant fails a check, they return to the first instructions page. Participants do not have to repeat checks that they pass. We set a limit on the number of attempts participants have to pass each check. For example, suppose there are two checks, A and B. The participant passes check A but fails check B. He is brought back to the first page of the instructions. After rereading the instructions, he is brought directly to check B, skipping check A. (Think about what it would take to do this in Qualtrics). Basic syntax Although we usually start with jupyter, the logic of comprehension checks is best illustrated by running an app. Open app.py and replace import survey with import tmp_survey . Now make a new file, tmp_survey.py , and enter the following: from hemlock import Branch, Check, Choice, Compile, Page, Input, Label, Submit, route from hemlock.tools import comprehension_check @route('/survey') def start(): correct = Choice('correct') branch = comprehension_check( Branch(), instructions=Page(Label('<p>Here are some instructions.</p>')), checks=Compile.clear_response(Page( Compile.shuffle(Submit.correct_choices( Check( '<p>Click the correct choice.</p>', [correct, 'incorrect', 'also incorrect'] ), correct=[correct] )) )), attempts=3 ) branch.pages.append( Page(Label('<p>The End!</p>'), terminal=True) ) return branch Run the app and play with the comprehension check. Notice that when you don't click the correct choice, the survey brings you back to the instructions page. Code explanation First, we import our standard hemlock objects and the comprehension_check tool. At the top of our start function, we create a Choice object, which is the answer to the check question. Choice objects belong to Check questions. We then create a branch using the comprehension check tool. comprehension_check takes a branch as its first argument, followed by an instructions page (or a list of instructions pages), followed by a check page (or a list or check pages). The comprehension_check method returns the branch to which it added the comprehension check. The check page contains a Check question. Note that 'check' has different meanings here. A 'check page' in a comprehension check means a page where you test the participant's understanding of the instructions . A 'check question' means a question where you can check one or more choices . By default, the check page will record the participant's responses, and the check question will display the choices in their original order. These are both problems for testing comprehension. We don't want participants to simply click choices one after another until the hit the right one. To fix this, we add one compile function to the page to clear the responses, and another to the check question to re-shuffle the choices. A participant passes a check page when all of its questions' data evaluate to True . So, we'll add a submit function to the check question which converts its data to 1 if the participant selected the correct choice and 0 otherwise ( 1 and 0 evaluate to True and False in most programming languages). Finally, we set attempts=3 to give the participant 3 attempts to pass the check. If a participant fails the check 3 times, they'll simply continue the survey. We can require participants to pass the check by not passing an attempts parameter. Ultimatum game comprehension check We're going to use a comprehension check to explain the ultimatum game to our participants and test their understanding of it. First, open app.py and change import tmp_survey back to import survey . Instructions Open jupyter and let's preview the instructions page: from hemlock import Page, Label # the number of rounds participants play N_ROUNDS = 5 # the amount of money split POT = 20 Page(Label(''' <p>You are about to play an ultimatum game. The game involves two players: a <b>proposer</b> and a <b>responder</b>. The proposer has ${} to split between him/herself and the responder. The responder names an amount of money such that he/she accepts any proposed split which gives him/her at least this amount, and rejects any proposed split which gives him/her less than this amount.</p> <p><b>If the split is accepted, the proposer and responder split the money according to the proposal. If the split is rejected, both players receive $0.</b></p> <p>You will play {} rounds of this game. Each round, you will be paired with another randomly selected participant. <b>You will rarely, if ever, play two rounds with the same player.</b> <p>We will test your understanding of these instructions on the next page.</p> '''.format(POT, N_ROUNDS))).preview() Checks For the check pages, we're going to give participants a hypothetical proposal and response and ask them how much money the proposer and responder receive. We'll do this twice; once where the proposal is accepted, the other where it is rejected. Additionally, we want to avoid biasing participants' responses by giving them all the same hypothetical proposal-response pairs. So, we'll write a function to randomly generate proposals. Enter the following in your notebook: from hemlock import Compile, Input def gen_check_page(accept): return Compile.clear_response(Compile.random_proposal( Page( Label(), Input( '<p>How much money does the proposer receive?</p>', prepend='$', append='.00' ), Input( '<p>How much money does the responder receive?</p>', prepend='$', append='.00' ) ), accept=accept )) @Compile.register def random_proposal(check_page, accept): # WE'LL WRITE THIS FUNCTION IN A MOMENT pass path = gen_check_page(accept=True).preview() The gen_check_page function generates a check page. The Label with which the page starts is going to be populated by a randomly generated proposal-response pair which we'll create with the compile function random_proposal . Both gen_check_page and random_proposal take an accept argument which indicates whether the proposal will be accepted or rejected. Now, fill in the random_proposal function: from hemlock import Compile, Input, Submit from random import randint ... @Compile.register def random_proposal(check_page, accept): # randomly generate a proposed split and response n = randint(1, POT-1) proposal = POT-n, n # proposer receives POT-n, responder receives n response = randint(0, n) if accept else randint(n+1, POT) # compute the payoff payoff = proposal if response<=proposal[1] else (0, 0) # describe the proposal and response in the label check_page.questions[0].label = ''' <p>Imagine the proposer proposes the following split:</p> <ul> <li>Proposer: ${}</li> <li>Responder: ${}</li> </ul> <p>The responder says, \"I will accept any proposal which gives me at least ${}.\"</p> '''.format(*proposal, response) # add submit functions to verify that the response was correct check_page.questions[1].submit_functions.clear() Submit.match(check_page.questions[1], str(payoff[0])) check_page.questions[2].submit_functions.clear() Submit.match(check_page.questions[2], str(payoff[1])) check_page = gen_check_page(accept=True) path = check_page._compile().preview() random_proposal begins by generating a random proposal. We then generate a random response which will accept the proposal if accept is True and reject the proposal if accept is False . The payoff is the proposal if the proposal is accepted and (0,0) if the proposal is rejected. We then fill in the check page's label with the proposal and response. Finally, we add submit functions to the check page's input questions to verify that the participant's responses match the payoffs. Adding a comprehension check to our app Let's put this all together in survey.py : from hemlock import Branch, Check, Compile, Embedded, Input, Label, Navigate, Page, Range, Select, Submit, Validate, route from hemlock.tools import comprehension_check, join from datetime import datetime from random import randint N_ROUNDS = 5 POT = 20 ... @Navigate.register def ultimatum_game(start_branch): branch = comprehension_check( Branch(), Page( # CONTENT OF INSTRUCTIONS PAGE HERE ), [gen_check_page(accept=True), gen_check_page(accept=False)], ) branch.pages.append(Page( Label('<p>You passed the check!</p>'), terminal=True) ) return branch def gen_check_page(accept): # GEN_CHECK_PAGE FUNCTION HERE @Compile.register def random_proposal(check_page, accept): # RANDOM PROPOSSAL FUNCTION HERE Run your app and see your comprehension check at work! Summary In this part of the tutorial, you learned how to add comprehension checks to your studies. In the next part of the tutorial, you'll learn how to assign participants to conditions.","title":"Comprehension check"},{"location":"tutorial/comp_check/#comprehension-check","text":"In the previous part of the tutorial, you reviewed page logic. By the end of this part of the tutorial, you'll be able to set up comprehension checks.","title":"Comprehension check"},{"location":"tutorial/comp_check/#why-comprehension-checks","text":"We often give our participants instructions. To make sure they understand the instructions, we give them comprehension checks. Hemlock has a built-in tool for easy comprehension checks. The structure of a comprehension check is: One or more pages of instructions. One or more pages of 'checks'. If the participant fails a check, they return to the first instructions page. Participants do not have to repeat checks that they pass. We set a limit on the number of attempts participants have to pass each check. For example, suppose there are two checks, A and B. The participant passes check A but fails check B. He is brought back to the first page of the instructions. After rereading the instructions, he is brought directly to check B, skipping check A. (Think about what it would take to do this in Qualtrics).","title":"Why comprehension checks?"},{"location":"tutorial/comp_check/#basic-syntax","text":"Although we usually start with jupyter, the logic of comprehension checks is best illustrated by running an app. Open app.py and replace import survey with import tmp_survey . Now make a new file, tmp_survey.py , and enter the following: from hemlock import Branch, Check, Choice, Compile, Page, Input, Label, Submit, route from hemlock.tools import comprehension_check @route('/survey') def start(): correct = Choice('correct') branch = comprehension_check( Branch(), instructions=Page(Label('<p>Here are some instructions.</p>')), checks=Compile.clear_response(Page( Compile.shuffle(Submit.correct_choices( Check( '<p>Click the correct choice.</p>', [correct, 'incorrect', 'also incorrect'] ), correct=[correct] )) )), attempts=3 ) branch.pages.append( Page(Label('<p>The End!</p>'), terminal=True) ) return branch Run the app and play with the comprehension check. Notice that when you don't click the correct choice, the survey brings you back to the instructions page.","title":"Basic syntax"},{"location":"tutorial/comp_check/#code-explanation","text":"First, we import our standard hemlock objects and the comprehension_check tool. At the top of our start function, we create a Choice object, which is the answer to the check question. Choice objects belong to Check questions. We then create a branch using the comprehension check tool. comprehension_check takes a branch as its first argument, followed by an instructions page (or a list of instructions pages), followed by a check page (or a list or check pages). The comprehension_check method returns the branch to which it added the comprehension check. The check page contains a Check question. Note that 'check' has different meanings here. A 'check page' in a comprehension check means a page where you test the participant's understanding of the instructions . A 'check question' means a question where you can check one or more choices . By default, the check page will record the participant's responses, and the check question will display the choices in their original order. These are both problems for testing comprehension. We don't want participants to simply click choices one after another until the hit the right one. To fix this, we add one compile function to the page to clear the responses, and another to the check question to re-shuffle the choices. A participant passes a check page when all of its questions' data evaluate to True . So, we'll add a submit function to the check question which converts its data to 1 if the participant selected the correct choice and 0 otherwise ( 1 and 0 evaluate to True and False in most programming languages). Finally, we set attempts=3 to give the participant 3 attempts to pass the check. If a participant fails the check 3 times, they'll simply continue the survey. We can require participants to pass the check by not passing an attempts parameter.","title":"Code explanation"},{"location":"tutorial/comp_check/#ultimatum-game-comprehension-check","text":"We're going to use a comprehension check to explain the ultimatum game to our participants and test their understanding of it. First, open app.py and change import tmp_survey back to import survey .","title":"Ultimatum game comprehension check"},{"location":"tutorial/comp_check/#instructions","text":"Open jupyter and let's preview the instructions page: from hemlock import Page, Label # the number of rounds participants play N_ROUNDS = 5 # the amount of money split POT = 20 Page(Label(''' <p>You are about to play an ultimatum game. The game involves two players: a <b>proposer</b> and a <b>responder</b>. The proposer has ${} to split between him/herself and the responder. The responder names an amount of money such that he/she accepts any proposed split which gives him/her at least this amount, and rejects any proposed split which gives him/her less than this amount.</p> <p><b>If the split is accepted, the proposer and responder split the money according to the proposal. If the split is rejected, both players receive $0.</b></p> <p>You will play {} rounds of this game. Each round, you will be paired with another randomly selected participant. <b>You will rarely, if ever, play two rounds with the same player.</b> <p>We will test your understanding of these instructions on the next page.</p> '''.format(POT, N_ROUNDS))).preview()","title":"Instructions"},{"location":"tutorial/comp_check/#checks","text":"For the check pages, we're going to give participants a hypothetical proposal and response and ask them how much money the proposer and responder receive. We'll do this twice; once where the proposal is accepted, the other where it is rejected. Additionally, we want to avoid biasing participants' responses by giving them all the same hypothetical proposal-response pairs. So, we'll write a function to randomly generate proposals. Enter the following in your notebook: from hemlock import Compile, Input def gen_check_page(accept): return Compile.clear_response(Compile.random_proposal( Page( Label(), Input( '<p>How much money does the proposer receive?</p>', prepend='$', append='.00' ), Input( '<p>How much money does the responder receive?</p>', prepend='$', append='.00' ) ), accept=accept )) @Compile.register def random_proposal(check_page, accept): # WE'LL WRITE THIS FUNCTION IN A MOMENT pass path = gen_check_page(accept=True).preview() The gen_check_page function generates a check page. The Label with which the page starts is going to be populated by a randomly generated proposal-response pair which we'll create with the compile function random_proposal . Both gen_check_page and random_proposal take an accept argument which indicates whether the proposal will be accepted or rejected. Now, fill in the random_proposal function: from hemlock import Compile, Input, Submit from random import randint ... @Compile.register def random_proposal(check_page, accept): # randomly generate a proposed split and response n = randint(1, POT-1) proposal = POT-n, n # proposer receives POT-n, responder receives n response = randint(0, n) if accept else randint(n+1, POT) # compute the payoff payoff = proposal if response<=proposal[1] else (0, 0) # describe the proposal and response in the label check_page.questions[0].label = ''' <p>Imagine the proposer proposes the following split:</p> <ul> <li>Proposer: ${}</li> <li>Responder: ${}</li> </ul> <p>The responder says, \"I will accept any proposal which gives me at least ${}.\"</p> '''.format(*proposal, response) # add submit functions to verify that the response was correct check_page.questions[1].submit_functions.clear() Submit.match(check_page.questions[1], str(payoff[0])) check_page.questions[2].submit_functions.clear() Submit.match(check_page.questions[2], str(payoff[1])) check_page = gen_check_page(accept=True) path = check_page._compile().preview() random_proposal begins by generating a random proposal. We then generate a random response which will accept the proposal if accept is True and reject the proposal if accept is False . The payoff is the proposal if the proposal is accepted and (0,0) if the proposal is rejected. We then fill in the check page's label with the proposal and response. Finally, we add submit functions to the check page's input questions to verify that the participant's responses match the payoffs.","title":"Checks"},{"location":"tutorial/comp_check/#adding-a-comprehension-check-to-our-app","text":"Let's put this all together in survey.py : from hemlock import Branch, Check, Compile, Embedded, Input, Label, Navigate, Page, Range, Select, Submit, Validate, route from hemlock.tools import comprehension_check, join from datetime import datetime from random import randint N_ROUNDS = 5 POT = 20 ... @Navigate.register def ultimatum_game(start_branch): branch = comprehension_check( Branch(), Page( # CONTENT OF INSTRUCTIONS PAGE HERE ), [gen_check_page(accept=True), gen_check_page(accept=False)], ) branch.pages.append(Page( Label('<p>You passed the check!</p>'), terminal=True) ) return branch def gen_check_page(accept): # GEN_CHECK_PAGE FUNCTION HERE @Compile.register def random_proposal(check_page, accept): # RANDOM PROPOSSAL FUNCTION HERE Run your app and see your comprehension check at work!","title":"Adding a comprehension check to our app"},{"location":"tutorial/comp_check/#summary","text":"In this part of the tutorial, you learned how to add comprehension checks to your studies. In the next part of the tutorial, you'll learn how to assign participants to conditions.","title":"Summary"},{"location":"tutorial/compile/","text":"Compile In the previous part of the tutorial, you learned how to run functions to handle form submission. In this part of the tutorial, you'll implement a confirmation page using compile functions. Why compile functions? Compile functions run just before a page's html is compiled. This allows us to make our survey responsive to participants. In our case, we're going to make a confirmation page for the participant's demographic information. Basic syntax Open your jupyter notebook and run the following: from hemlock import Check, Compile check = Compile.shuffle(Check( '<p>Select the correct answer.</p>', ['correct', 'incorrect', 'also incorrect'] )) check._compile() [choice.label for choice in check.choices] Out: ['also incorrect', 'incorrect', 'correct'] Run this a few times and notice how the order of the choices changes. This particular behavior is useful for comprehension checks, as we'll see later. Compile.shuffle adds a compile function to a page or question, then returns the page or question. In this case, we shuffle the choices of a check question every time the participant reloads the page. Compile functions are available in the question's compile_functions attribute: check.compile_functions Out: [<Compile 1>] Custom compilation We want to take the participant's responses to the demographics page and display them on a new page. We'll ask the participant to correct any errors by going back to the demographics page. Let's see how to do this in our notebook: from hemlock import Input, Label, Page from hemlock.tools import join @Compile.register def confirm(label, demographics_page): # get the participant's data from the demographics page demographics = [q.data for q in demographics_page.questions] # re-format the race demographic data race = demographics_page.questions[2] race = join('and', *(key for key in race.data if race.data[key])) demographics[2] = race # set the label based on the participant's demographics data label.label = ''' <p>Confirm the following information:</p> <ul> <li>Date of birth: {}</li> <li>Gender: {}</li> <li>Race/Ethnicity: {}</li> <li>Marital status: {}</li> <li>Subjective socio-economic status: {}</li> </ul> <p>To correct this information, click '<<'.</p> '''.format(*demographics) demographics_page = Page( Input(data='10/26/1992'), Check(data='Male'), Check(data={'White': 1, 'Black': 1}), Select(data='Never married'), Range(data='5') ) p = Page(Compile.confirm(Label(), demographics_page), back=True) p._compile().preview() Code explanation First, we register a new compile function with the @Compile.register decorator. The compile function takes a page or question as its argument. We also pass in the demographics page as the compile function's second argument. Next, we add a back button to the page with back=True . Then, we compile and preview the page. Note that you won't need to run _compile in your survey files; hemlock does this automatically for you. Our confirm function begins by gathering the demographics data from the demographics page. The data are well formatted to insert into our confirmation page except for race. For Check and Select questions, if the participant can select multiple choices, the data are stored as a dictionary mapping choice values ( 'White' , 'Black' , etc.) to a 0-1 indicator that the participant selected that choice. We fix this with the following: from hemlock.tools import join race_data = demographics_page.questions[2].data race = join('and', *(key for key in race_data if race_data[key])) demographics[2] = race Note that race_data[key] evaluates to True if the key ( 'White' , 'Black' , etc.) was selected. So the expression (key for key in race_data if race_data[key]) means 'get all the keys (races) the participant selected'. The expression join('and', *(key for key in race_data if race_data[key])) means 'join all of the selected keys with \"and\", e.g. \"White and Black\"'. Finally, our compile function adds the demographics to the confirmation page. Compilation in our app Now that we've seen how to add compile functions in our notebook, let's add it to our app. In survey.py : from hemlock import Branch, Check, Compile, Embedded, Input, Label, Page, Range, Select, Submit, Validate, route from hemlock.tools import join from datetime import datetime @route('/survey') def start(): demographics_page = Page( Submit.record_age(Validate.validate_date_format(Input( '<p>Enter your date of birth.</p>', placeholder='mm/dd/yyyy', var='DoB', data_rows=-1 ))), # REST OF THE DEMOGRAPHICS PAGE HERE ) return Branch( demographics_page, Page( Compile.confirm(Label(), demographics_page), back=True, terminal=True ) ) ... @Compile.register def confirm(label, demographics_page): # get the participant's data from the demographics page demographics = [q.data for q in demographics_page.questions] # re-format the race demographic data race_data = demographics_page.questions[2].data race = join('and', *(key for key in race_data if race_data[key])) demographics[2] = race # set the label based on the participant's demographics data label.label = ''' <p>Confirm the following information:</p> <ul> <li>Date of birth: {}</li> <li>Gender: {}</li> <li>Race/Ethnicity: {}</li> <li>Marital status: {}</li> <li>Subjective socio-economic status: {}</li> </ul> <p>To correct this information, click '<<'.</p> '''.format(*demographics) Run the app again to see your confirmation page. Summary In this part of the tutorial, you implemented a confirmation page using compile functions. In the next part of the tutorial, you'll learn how to set up navigation between branches.","title":"Compile"},{"location":"tutorial/compile/#compile","text":"In the previous part of the tutorial, you learned how to run functions to handle form submission. In this part of the tutorial, you'll implement a confirmation page using compile functions.","title":"Compile"},{"location":"tutorial/compile/#why-compile-functions","text":"Compile functions run just before a page's html is compiled. This allows us to make our survey responsive to participants. In our case, we're going to make a confirmation page for the participant's demographic information.","title":"Why compile functions?"},{"location":"tutorial/compile/#basic-syntax","text":"Open your jupyter notebook and run the following: from hemlock import Check, Compile check = Compile.shuffle(Check( '<p>Select the correct answer.</p>', ['correct', 'incorrect', 'also incorrect'] )) check._compile() [choice.label for choice in check.choices] Out: ['also incorrect', 'incorrect', 'correct'] Run this a few times and notice how the order of the choices changes. This particular behavior is useful for comprehension checks, as we'll see later. Compile.shuffle adds a compile function to a page or question, then returns the page or question. In this case, we shuffle the choices of a check question every time the participant reloads the page. Compile functions are available in the question's compile_functions attribute: check.compile_functions Out: [<Compile 1>]","title":"Basic syntax"},{"location":"tutorial/compile/#custom-compilation","text":"We want to take the participant's responses to the demographics page and display them on a new page. We'll ask the participant to correct any errors by going back to the demographics page. Let's see how to do this in our notebook: from hemlock import Input, Label, Page from hemlock.tools import join @Compile.register def confirm(label, demographics_page): # get the participant's data from the demographics page demographics = [q.data for q in demographics_page.questions] # re-format the race demographic data race = demographics_page.questions[2] race = join('and', *(key for key in race.data if race.data[key])) demographics[2] = race # set the label based on the participant's demographics data label.label = ''' <p>Confirm the following information:</p> <ul> <li>Date of birth: {}</li> <li>Gender: {}</li> <li>Race/Ethnicity: {}</li> <li>Marital status: {}</li> <li>Subjective socio-economic status: {}</li> </ul> <p>To correct this information, click '<<'.</p> '''.format(*demographics) demographics_page = Page( Input(data='10/26/1992'), Check(data='Male'), Check(data={'White': 1, 'Black': 1}), Select(data='Never married'), Range(data='5') ) p = Page(Compile.confirm(Label(), demographics_page), back=True) p._compile().preview()","title":"Custom compilation"},{"location":"tutorial/compile/#code-explanation","text":"First, we register a new compile function with the @Compile.register decorator. The compile function takes a page or question as its argument. We also pass in the demographics page as the compile function's second argument. Next, we add a back button to the page with back=True . Then, we compile and preview the page. Note that you won't need to run _compile in your survey files; hemlock does this automatically for you. Our confirm function begins by gathering the demographics data from the demographics page. The data are well formatted to insert into our confirmation page except for race. For Check and Select questions, if the participant can select multiple choices, the data are stored as a dictionary mapping choice values ( 'White' , 'Black' , etc.) to a 0-1 indicator that the participant selected that choice. We fix this with the following: from hemlock.tools import join race_data = demographics_page.questions[2].data race = join('and', *(key for key in race_data if race_data[key])) demographics[2] = race Note that race_data[key] evaluates to True if the key ( 'White' , 'Black' , etc.) was selected. So the expression (key for key in race_data if race_data[key]) means 'get all the keys (races) the participant selected'. The expression join('and', *(key for key in race_data if race_data[key])) means 'join all of the selected keys with \"and\", e.g. \"White and Black\"'. Finally, our compile function adds the demographics to the confirmation page.","title":"Code explanation"},{"location":"tutorial/compile/#compilation-in-our-app","text":"Now that we've seen how to add compile functions in our notebook, let's add it to our app. In survey.py : from hemlock import Branch, Check, Compile, Embedded, Input, Label, Page, Range, Select, Submit, Validate, route from hemlock.tools import join from datetime import datetime @route('/survey') def start(): demographics_page = Page( Submit.record_age(Validate.validate_date_format(Input( '<p>Enter your date of birth.</p>', placeholder='mm/dd/yyyy', var='DoB', data_rows=-1 ))), # REST OF THE DEMOGRAPHICS PAGE HERE ) return Branch( demographics_page, Page( Compile.confirm(Label(), demographics_page), back=True, terminal=True ) ) ... @Compile.register def confirm(label, demographics_page): # get the participant's data from the demographics page demographics = [q.data for q in demographics_page.questions] # re-format the race demographic data race_data = demographics_page.questions[2].data race = join('and', *(key for key in race_data if race_data[key])) demographics[2] = race # set the label based on the participant's demographics data label.label = ''' <p>Confirm the following information:</p> <ul> <li>Date of birth: {}</li> <li>Gender: {}</li> <li>Race/Ethnicity: {}</li> <li>Marital status: {}</li> <li>Subjective socio-economic status: {}</li> </ul> <p>To correct this information, click '<<'.</p> '''.format(*demographics) Run the app again to see your confirmation page.","title":"Compilation in our app"},{"location":"tutorial/compile/#summary","text":"In this part of the tutorial, you implemented a confirmation page using compile functions. In the next part of the tutorial, you'll learn how to set up navigation between branches.","title":"Summary"},{"location":"tutorial/data/","text":"Data In the previous part of the tutorial, you learned how to create a demographics questionnaire using several question polymorphs. By the end of this part of the tutorial, you'll be able to store and download data. Previewing data from a single participant Each participant contributes data to a data frame which you can download. We'll start by looking at the data belonging to a 'test participant'. Run the following in your jupyter notebook: from hemlock import Participant part = Participant.gen_test_participant() dict(part.get_data()) Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress']} This shows the data our test participant contributes to the data frame. The keys are variable names, and values are list of entries for that variable. An easy way to add data is with 'embedded data': from hemlock import Embedded part.embedded = [Embedded(var='MyVariable', data='MyData')] dict(part.get_data()) Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress'], 'MyVariable': ['MyData'], 'MyVariableOrder': [0], 'MyVariableIndex': [0]} This adds an Embedded data object to our participant. Embedded data are a type of data element, like questions, but unlike questions, are not displayed to participants. We can add embedded data to a participant, branch, or page. When we examine the data, we see that the participant has a new variable named 'MyVariable' with data ['MyData'] . We also see two additional variables named 'MyVariableOrder' and 'MyVariableIndex' . Hemlock automatically adds order and index data for every data element. Order is the order in which this data element appeared in the survey, relative to other data elements belonging to the same variable. Index is the order in which this data element appeared in its parent's list of children; for example, the order in which a question appeared on its page. Ordering The order in which data elements appear in the data frame is the order in which they were created; not necessarily the order in which they appear to the participant. For example: embedded1 = Embedded('MyVariable', 1) embedded0 = Embedded('MyVariable', 0) part.embedded = [embedded0, embedded1] dict(part.get_data()) Out: {'ID': [1, 1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress', 'InProgress'], 'MyVariable': [1, 0], 'MyVariableOrder': [1, 0], 'MyVariableIndex': [1, 0]} Note that the data for 'MyVariable' are [1, 0] because we created embedded1 before embedded0 . Data rows By default, data elements (embedded data and questions) contribute 1 row to the data frame. But we often want the same data to be repeated on multiple rows. We do this by setting the data_rows attribute: part.embedded = [Embedded('MyVariable', 'MyData', data_rows=3)] dict(part.get_data()) Out: {'ID': [1, 1, 1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress', 'InProgress', 'InProgress'], 'MyVariable': ['MyData', 'MyData', 'MyData'], 'MyVariableOrder': [0, 0, 0], 'MyVariableIndex': [0, 0, 0]} Additionally, we often want to 'fill in' rows of a variable to match the length of a data frame. For example, we may not know in advance how many rows a participant will contribute to the data frame, but we know that we want the participant's demographic information to appear on all rows. To do this, we set data_rows to a negative number. For example, data_rows=-2 means 'fill in two rows with this data entry and, when you download the data, fill in any blank rows after this with the same data': part.embedded = [ # these data will fill in empty rows at the bottom of the data frame Embedded('MyFilledVariable', 'MyFilledData', data_rows=-1), # these data will appear on three rows of the data frame Embedded('MyVariable', 'MyData', data_rows=3) ] dict(part.get_data())['MyFilledVariable'] Out: ['MyFilledData', 'MyFilledData', 'MyFilledData'] Adding data to our survey We can add data to our existing survey in much the same way: by setting a question's var and (when necessary) data_rows attribute. We generally want demographics information to appear in all rows of the data frame, so we'll set data_rows=-1 . In survey.py : ... @route('/survey') def start(): return Branch( Page( Input( '<p>Enter your date of birth.</p>', placeholder='mm/dd/yyyy', var='DoB', data_rows=-1 ), Check( '<p>Indicate your gender.</p>', ['Male', 'Female', 'Other'], var='Gender', data_rows=-1 ), # SET THE `var` AND `data_rows` ATTRIBUTES FOR THE REST OF THE QUESTIONS ... Downloading data Run your survey locally, fill in the demographics page, and continue to the end of the survey. Your data will be recorded in the database. To download your data, navigate to http://localhost5000/download in your browser. Select 'Data frame', then click the download button. This will download a zip file containing your data in .csv format. Take a look at the data. In addition to what we've already covered, there are a few things to notice: Variables like GenderMaleIndex and GenderFemaleIndex record the order in which a question displayed its choices. The data of questions for which you can select multiple choices are automatically one-hot encoded. For example, if RaceWhite and RaceAsian are both 1, and the rest of the race variables are 0, this means means the participant is part White and part Asian. Note. You'll often want to wipe your database as you add and remove varaibles from your survey. To remove your database, open your terminal and enter: $ rm data.db Summary In this part of the tutorial, you learned how to store and download data. In the next part of the tutorial, you'll implement validation for participant responses.","title":"Data"},{"location":"tutorial/data/#data","text":"In the previous part of the tutorial, you learned how to create a demographics questionnaire using several question polymorphs. By the end of this part of the tutorial, you'll be able to store and download data.","title":"Data"},{"location":"tutorial/data/#previewing-data-from-a-single-participant","text":"Each participant contributes data to a data frame which you can download. We'll start by looking at the data belonging to a 'test participant'. Run the following in your jupyter notebook: from hemlock import Participant part = Participant.gen_test_participant() dict(part.get_data()) Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress']} This shows the data our test participant contributes to the data frame. The keys are variable names, and values are list of entries for that variable. An easy way to add data is with 'embedded data': from hemlock import Embedded part.embedded = [Embedded(var='MyVariable', data='MyData')] dict(part.get_data()) Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress'], 'MyVariable': ['MyData'], 'MyVariableOrder': [0], 'MyVariableIndex': [0]} This adds an Embedded data object to our participant. Embedded data are a type of data element, like questions, but unlike questions, are not displayed to participants. We can add embedded data to a participant, branch, or page. When we examine the data, we see that the participant has a new variable named 'MyVariable' with data ['MyData'] . We also see two additional variables named 'MyVariableOrder' and 'MyVariableIndex' . Hemlock automatically adds order and index data for every data element. Order is the order in which this data element appeared in the survey, relative to other data elements belonging to the same variable. Index is the order in which this data element appeared in its parent's list of children; for example, the order in which a question appeared on its page.","title":"Previewing data from a single participant"},{"location":"tutorial/data/#ordering","text":"The order in which data elements appear in the data frame is the order in which they were created; not necessarily the order in which they appear to the participant. For example: embedded1 = Embedded('MyVariable', 1) embedded0 = Embedded('MyVariable', 0) part.embedded = [embedded0, embedded1] dict(part.get_data()) Out: {'ID': [1, 1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress', 'InProgress'], 'MyVariable': [1, 0], 'MyVariableOrder': [1, 0], 'MyVariableIndex': [1, 0]} Note that the data for 'MyVariable' are [1, 0] because we created embedded1 before embedded0 .","title":"Ordering"},{"location":"tutorial/data/#data-rows","text":"By default, data elements (embedded data and questions) contribute 1 row to the data frame. But we often want the same data to be repeated on multiple rows. We do this by setting the data_rows attribute: part.embedded = [Embedded('MyVariable', 'MyData', data_rows=3)] dict(part.get_data()) Out: {'ID': [1, 1, 1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress', 'InProgress', 'InProgress'], 'MyVariable': ['MyData', 'MyData', 'MyData'], 'MyVariableOrder': [0, 0, 0], 'MyVariableIndex': [0, 0, 0]} Additionally, we often want to 'fill in' rows of a variable to match the length of a data frame. For example, we may not know in advance how many rows a participant will contribute to the data frame, but we know that we want the participant's demographic information to appear on all rows. To do this, we set data_rows to a negative number. For example, data_rows=-2 means 'fill in two rows with this data entry and, when you download the data, fill in any blank rows after this with the same data': part.embedded = [ # these data will fill in empty rows at the bottom of the data frame Embedded('MyFilledVariable', 'MyFilledData', data_rows=-1), # these data will appear on three rows of the data frame Embedded('MyVariable', 'MyData', data_rows=3) ] dict(part.get_data())['MyFilledVariable'] Out: ['MyFilledData', 'MyFilledData', 'MyFilledData']","title":"Data rows"},{"location":"tutorial/data/#adding-data-to-our-survey","text":"We can add data to our existing survey in much the same way: by setting a question's var and (when necessary) data_rows attribute. We generally want demographics information to appear in all rows of the data frame, so we'll set data_rows=-1 . In survey.py : ... @route('/survey') def start(): return Branch( Page( Input( '<p>Enter your date of birth.</p>', placeholder='mm/dd/yyyy', var='DoB', data_rows=-1 ), Check( '<p>Indicate your gender.</p>', ['Male', 'Female', 'Other'], var='Gender', data_rows=-1 ), # SET THE `var` AND `data_rows` ATTRIBUTES FOR THE REST OF THE QUESTIONS ...","title":"Adding data to our survey"},{"location":"tutorial/data/#downloading-data","text":"Run your survey locally, fill in the demographics page, and continue to the end of the survey. Your data will be recorded in the database. To download your data, navigate to http://localhost5000/download in your browser. Select 'Data frame', then click the download button. This will download a zip file containing your data in .csv format. Take a look at the data. In addition to what we've already covered, there are a few things to notice: Variables like GenderMaleIndex and GenderFemaleIndex record the order in which a question displayed its choices. The data of questions for which you can select multiple choices are automatically one-hot encoded. For example, if RaceWhite and RaceAsian are both 1, and the rest of the race variables are 0, this means means the participant is part White and part Asian. Note. You'll often want to wipe your database as you add and remove varaibles from your survey. To remove your database, open your terminal and enter: $ rm data.db","title":"Downloading data"},{"location":"tutorial/data/#summary","text":"In this part of the tutorial, you learned how to store and download data. In the next part of the tutorial, you'll implement validation for participant responses.","title":"Summary"},{"location":"tutorial/debug/","text":"Debugging In the previous part of the tutorial, you implemented the responder branch. By the end of this part of the tutorial, you'll be able to use hemlock's debugging tool to make sure your app is running smoothly. Why a custom debugging tool? In the early days of hemlock, I coded a study in which I asked participants to estimate the ages of people in photographs. I used a submit function to change their data from strings to integers. Everything was running smoothly until one mischievous participant entered 'twenty-seven', breaking my survey and sending me home in a fit of rage. Since then, I've rewritten my submit functions to be more fault tolerant. If you run from hemlock import Input, Submit Submit.data_type(Input(data='twenty-seven'), int)._submit().data it doesn't break; it simply converts the data to None . But that wasn't good enough. We often underestimate just how strangely participants will respond to our studies in ways that we can't foresee. To mitigate this problem, I wrote a custom debugging tool for hemlock. The tool sends an AI participant through your survey to check things out. 'AI participant' is a bit of a misnomer; if anything, it's an artificially stupid participant. It clicks random buttons, enters random things into inputs and text boxes, drags range sliders to random values; basically stress testing your code. Setup To run hemlock's custom debugging tool locally, you'll need Google Chrome and Chromedriver . With hemlock-CLI on WSL To install chromedriver, run: $ hlk setup --chromedriver This downloads a version of Chromdriver compatible with Chrome 83 and adds puts it here: C:\\Users\\<my-windows-username>\\webdrivers\\chromedriver . It also adds an environment variable for easy access in python. To verify your installation, close and re-open your terminal and run: $ which chromedriver /mnt/c/users/<my-windows-username>/chromedriver Note. The Chromedriver version downloaded by the Hemlock CLI is compatible with Chrome 83. While Chrome upgrades automatically, Chromedriver does not. When Chrome updates, you will experience errors due to Chrome-Chromedriver incompatibility. To fix this, you will need to manually upgrade Chromedriver: Download the appropriate Chromedriver version from https://chromedriver.chromium.org/downloads/ . Store the Chromedriver executable in C:/users/<my-windows-username>/webdrivers/ . Rename the Chromedriver executable from chromedriver.exe to chromedriver . Without hemlock-CLI Download the appropriate version of Chromedriver from https://chromedriver.chromium.org/downloads/ . Add the Chromedriver executable to your PATH (it's easy to find a guide for this online). If working in WSL, rename the Chromedriver executable from chromedriver.exe to chromedriver . (It took me hours of Googling + trial end error to figure this out). Verify your installation, close and re-open your terminal and run: $ which chromedriver /path/to/my/chromedriver Basic syntax Open your jupyter notebook and run the following: from hemlock import Debug, Input, Page from hemlock.tools import chromedriver driver = chromedriver() p = Page(Debug.send_keys(Input(), 'hello world')) p.debug_functions.pop() p.preview(driver)._debug(driver) First, we use chromedriver to open Chromedriver with selenium python . Next, we create a page, attaching a debug function to an input question on the page. Like the other functions you've seen, Debug.send_keys(Input(), 'hello world') attaches a send_keys debug function to the Input() with an argument 'hello world' and returns the input question to which it is attached. We then pop the last debug function from the page we created. Why? By default, pages have two debug functions. The first executes its questions' debug methods in random order; as if the participant were randomly jumping between questions on a page. The second debug function randomly clicks a forward or back button (if it exists), or refreshes the page. Popping the debug function prevents the debugger from navigating, which is often a good idea in preview mode. Finally, we run the debug function. You'll notice it enters 'hello world' in the input. Default debug functions We can attach debug functions to pages or questions. Most questions have a default debug function. For example, input questions have a default debug function which sends random ASCII characters to the input. However, sometimes we need to attach additional debug functions. For example, our study begins by asking participants to enter their date of birth in mm/dd/yyyy format. If you wait for the default debug function to randomly enter a string which matches that pattern, you might not end up running your study before Trump releases his tax returns. Instead, we'll use something like: Page(Debug.send_keys( Input('<p>Enter your date of birth.</p>'), '10/26/1992', p_exec=.8 )) You can pass p_exec as a keyword argument to any debug function. This is the probablity that the debug function will execute. This is useful because we want the debugger to occasionally enter something random into the date of birth input to see if anything breaks. send_keys is just one of many pre-built debug functions . Custom debug functions We won't need custom debug functions for our survey, but you may need them elsewhere. Creating custom debug function is similar to creating custom compile, validate, etc. functions, with one important difference: while the functions you've seen take their parent as their first argument, debug functions take a selenium webdriver as their first argument and their parent as their second argument: @Debug.register def f(driver, parent): # debug something Debugging our app Our app can be debugged largely with default debug functions. The exceptions are, 1) the date of birth input, 2) the comprehension check, 3) proposals and responses. Date of birth Modify survey.py as follows: ... @route('/survey') def start(): demographics_page = Page( Debug.send_keys( Submit.record_age(Validate.validate_date_format(Input( '<p>Enter your date of birth.</p>', placeholder='mm/dd/yyyy', var='DoB', data_rows=-1 ))), '10/26/1992', p_exec=.8 ), ... Comprehension checks Because there is no attempt limit for our comprehension check, unless we tell the debugger to enter the correct answers, it's going to keep looping back to the instructions page. ... @Compile.register def random_proposal(check_page, accept): ... # add submit functions to verify that the response was correct check_page.questions[1].submit_functions.clear() Debug.send_keys( Submit.match(check_page.questions[1], str(payoff[0])), str(payoff[0]), p_exec=.8 ) check_page.questions[2].submit_functions.clear() Debug.send_keys( Submit.match(check_page.questions[2], str(payoff[1])), str(payoff[1]), p_exec=.8 ) ... Proposals and responses It's unlikely the debugger will enter an integer between 0 and the size of the pot, so we'll give our debugger some help: ... def gen_proposal_input(round_): return Debug.send_keys( Submit.data_type( # REST OF THE FUNCTION HERE ), str(randint(0, POT)), p_exec=.8 ) ... ... def gen_response_input(round_): return Debug.send_keys( Submit.data_type( # REST OF THE FUNCTION HERE ), str(randint(0, POT)), p_exec=.8 ) ... Running the debugger Now that our debugger won't get stuck in any infinite loops, it's time to run it. Open two terminal windows. In one, run the hemlock app as usual. In the other, you can run the debugger with hemlock-CLI as follows: $ hlk debug To run several AI participants through the survey, e.g. 3, use: $ hlk debug -b 3 If you don't want to use hemlock-CLI, you can run the debugger with the python interpreter: $ python3 >>> from hemlock.debug import AIParticipant, debug >>> debug() # or debug(<x>) to run x AI participants Summary In this part of the tutorial, you learned how to debug your app with hemlock's custom debugging tool. In the next part of the tutorial, you'll learn how to deploy your application (i.e. put it on the web).","title":"Debugging"},{"location":"tutorial/debug/#debugging","text":"In the previous part of the tutorial, you implemented the responder branch. By the end of this part of the tutorial, you'll be able to use hemlock's debugging tool to make sure your app is running smoothly.","title":"Debugging"},{"location":"tutorial/debug/#why-a-custom-debugging-tool","text":"In the early days of hemlock, I coded a study in which I asked participants to estimate the ages of people in photographs. I used a submit function to change their data from strings to integers. Everything was running smoothly until one mischievous participant entered 'twenty-seven', breaking my survey and sending me home in a fit of rage. Since then, I've rewritten my submit functions to be more fault tolerant. If you run from hemlock import Input, Submit Submit.data_type(Input(data='twenty-seven'), int)._submit().data it doesn't break; it simply converts the data to None . But that wasn't good enough. We often underestimate just how strangely participants will respond to our studies in ways that we can't foresee. To mitigate this problem, I wrote a custom debugging tool for hemlock. The tool sends an AI participant through your survey to check things out. 'AI participant' is a bit of a misnomer; if anything, it's an artificially stupid participant. It clicks random buttons, enters random things into inputs and text boxes, drags range sliders to random values; basically stress testing your code.","title":"Why a custom debugging tool?"},{"location":"tutorial/debug/#setup","text":"To run hemlock's custom debugging tool locally, you'll need Google Chrome and Chromedriver .","title":"Setup"},{"location":"tutorial/debug/#with-hemlock-cli-on-wsl","text":"To install chromedriver, run: $ hlk setup --chromedriver This downloads a version of Chromdriver compatible with Chrome 83 and adds puts it here: C:\\Users\\<my-windows-username>\\webdrivers\\chromedriver . It also adds an environment variable for easy access in python. To verify your installation, close and re-open your terminal and run: $ which chromedriver /mnt/c/users/<my-windows-username>/chromedriver Note. The Chromedriver version downloaded by the Hemlock CLI is compatible with Chrome 83. While Chrome upgrades automatically, Chromedriver does not. When Chrome updates, you will experience errors due to Chrome-Chromedriver incompatibility. To fix this, you will need to manually upgrade Chromedriver: Download the appropriate Chromedriver version from https://chromedriver.chromium.org/downloads/ . Store the Chromedriver executable in C:/users/<my-windows-username>/webdrivers/ . Rename the Chromedriver executable from chromedriver.exe to chromedriver .","title":"With hemlock-CLI on WSL"},{"location":"tutorial/debug/#without-hemlock-cli","text":"Download the appropriate version of Chromedriver from https://chromedriver.chromium.org/downloads/ . Add the Chromedriver executable to your PATH (it's easy to find a guide for this online). If working in WSL, rename the Chromedriver executable from chromedriver.exe to chromedriver . (It took me hours of Googling + trial end error to figure this out). Verify your installation, close and re-open your terminal and run: $ which chromedriver /path/to/my/chromedriver","title":"Without hemlock-CLI"},{"location":"tutorial/debug/#basic-syntax","text":"Open your jupyter notebook and run the following: from hemlock import Debug, Input, Page from hemlock.tools import chromedriver driver = chromedriver() p = Page(Debug.send_keys(Input(), 'hello world')) p.debug_functions.pop() p.preview(driver)._debug(driver) First, we use chromedriver to open Chromedriver with selenium python . Next, we create a page, attaching a debug function to an input question on the page. Like the other functions you've seen, Debug.send_keys(Input(), 'hello world') attaches a send_keys debug function to the Input() with an argument 'hello world' and returns the input question to which it is attached. We then pop the last debug function from the page we created. Why? By default, pages have two debug functions. The first executes its questions' debug methods in random order; as if the participant were randomly jumping between questions on a page. The second debug function randomly clicks a forward or back button (if it exists), or refreshes the page. Popping the debug function prevents the debugger from navigating, which is often a good idea in preview mode. Finally, we run the debug function. You'll notice it enters 'hello world' in the input.","title":"Basic syntax"},{"location":"tutorial/debug/#default-debug-functions","text":"We can attach debug functions to pages or questions. Most questions have a default debug function. For example, input questions have a default debug function which sends random ASCII characters to the input. However, sometimes we need to attach additional debug functions. For example, our study begins by asking participants to enter their date of birth in mm/dd/yyyy format. If you wait for the default debug function to randomly enter a string which matches that pattern, you might not end up running your study before Trump releases his tax returns. Instead, we'll use something like: Page(Debug.send_keys( Input('<p>Enter your date of birth.</p>'), '10/26/1992', p_exec=.8 )) You can pass p_exec as a keyword argument to any debug function. This is the probablity that the debug function will execute. This is useful because we want the debugger to occasionally enter something random into the date of birth input to see if anything breaks. send_keys is just one of many pre-built debug functions .","title":"Default debug functions"},{"location":"tutorial/debug/#custom-debug-functions","text":"We won't need custom debug functions for our survey, but you may need them elsewhere. Creating custom debug function is similar to creating custom compile, validate, etc. functions, with one important difference: while the functions you've seen take their parent as their first argument, debug functions take a selenium webdriver as their first argument and their parent as their second argument: @Debug.register def f(driver, parent): # debug something","title":"Custom debug functions"},{"location":"tutorial/debug/#debugging-our-app","text":"Our app can be debugged largely with default debug functions. The exceptions are, 1) the date of birth input, 2) the comprehension check, 3) proposals and responses.","title":"Debugging our app"},{"location":"tutorial/debug/#date-of-birth","text":"Modify survey.py as follows: ... @route('/survey') def start(): demographics_page = Page( Debug.send_keys( Submit.record_age(Validate.validate_date_format(Input( '<p>Enter your date of birth.</p>', placeholder='mm/dd/yyyy', var='DoB', data_rows=-1 ))), '10/26/1992', p_exec=.8 ), ...","title":"Date of birth"},{"location":"tutorial/debug/#comprehension-checks","text":"Because there is no attempt limit for our comprehension check, unless we tell the debugger to enter the correct answers, it's going to keep looping back to the instructions page. ... @Compile.register def random_proposal(check_page, accept): ... # add submit functions to verify that the response was correct check_page.questions[1].submit_functions.clear() Debug.send_keys( Submit.match(check_page.questions[1], str(payoff[0])), str(payoff[0]), p_exec=.8 ) check_page.questions[2].submit_functions.clear() Debug.send_keys( Submit.match(check_page.questions[2], str(payoff[1])), str(payoff[1]), p_exec=.8 ) ...","title":"Comprehension checks"},{"location":"tutorial/debug/#proposals-and-responses","text":"It's unlikely the debugger will enter an integer between 0 and the size of the pot, so we'll give our debugger some help: ... def gen_proposal_input(round_): return Debug.send_keys( Submit.data_type( # REST OF THE FUNCTION HERE ), str(randint(0, POT)), p_exec=.8 ) ... ... def gen_response_input(round_): return Debug.send_keys( Submit.data_type( # REST OF THE FUNCTION HERE ), str(randint(0, POT)), p_exec=.8 ) ...","title":"Proposals and responses"},{"location":"tutorial/debug/#running-the-debugger","text":"Now that our debugger won't get stuck in any infinite loops, it's time to run it. Open two terminal windows. In one, run the hemlock app as usual. In the other, you can run the debugger with hemlock-CLI as follows: $ hlk debug To run several AI participants through the survey, e.g. 3, use: $ hlk debug -b 3 If you don't want to use hemlock-CLI, you can run the debugger with the python interpreter: $ python3 >>> from hemlock.debug import AIParticipant, debug >>> debug() # or debug(<x>) to run x AI participants","title":"Running the debugger"},{"location":"tutorial/debug/#summary","text":"In this part of the tutorial, you learned how to debug your app with hemlock's custom debugging tool. In the next part of the tutorial, you'll learn how to deploy your application (i.e. put it on the web).","title":"Summary"},{"location":"tutorial/deploy/","text":"Deployment In the previous part of the tutorial, you learned how to debug your app with hemlock's custom debugging tool. In this part of the tutorial, you'll learn how to deploy your application (i.e. put it on the web). Setting a password If we were to deploy our study as is, anyone would be able to go to our app and download our study data. Setting a password is easy. Add this to the top of survey.py : from hemlock import settings settings.update({'password': 'my-password'}) Run your app and go to http://localhost:5000/download/ . You'll be redirected to a login page where you have to enter a password to access the download page. Deployment options Hemlock uses a Flask backend, which means you can deploy it just as you would any other Flask app. The Flask Mega-Tutorial is, imho, the best resource for learning Flask, including deployment. I remember deployment was the scariest part of this whole process when I was starting out. So, if you're using the hemlock template and hemlock-CLI, I've built in some tools to make this as easy as possible for you. Setup with heroku The easiest way to deploy web apps is with heroku . The hemlock-CLI builds on the heroku-CLI for deployment. You can install these with hemlock-CLI: $ hlk setup win --heroku You will be prompted to login and create an account. All deployment options, including heroku, costs money, but not much, and hemlock studies aren't usually resource intensive. For reference, most hemlock studies I've run cost less than $10. Heroku also offers free resources so you can preview your app online without paying anything. Close and re-open your terminal, then verify your installation with: $ heroku --version Production-lite Before scaling up your app, I recommend previewing it in what I call a 'production-lite' environment using free heroku resources: $ hlk deploy <my-app-name> Make sure your app name is unique. I do this by adding a few random digits to the end of the app name. Once this process finishes (~5 minutes), you'll be able to see your app at http://my-app-name.herokuapp.com/ . Go through your app and check for bugs before you start purchasing time on heroku servers. In addition to going through it manually, you can run the debugger in the production environment with: $ hlk debug --prod Where's the webdriver? In production, Chromedriver needs to run in 'headless' mode, meaning you won't be able to see the debugger going through the survey in your browser. You will, however, see it going through pages in the terminal window. If you later discover a bug, you can update your app with: $ hlk update Production When you're satisfied that your app isn't going to crash, scale it up with: $ hlk production This will destroy your existing free database (and redis server, if you have one), and you'll be prompted to enter the name of your app to confirm. It then replaces your database with a more powerful one. You're now renting a heroku database and 10 web processes. If you don't know what this means, don't worry. As of 07/09/2020, these resources cost just more than half a cent per minute. If you play with your hemlock app for the next 10 minutes, it'll cost $0.07. If you run an MTurk study and leave it up for the next 12 hours, it'll cost $5. Importantly, when you're done with your app, destroy it with: $ hlk destroy Modifying your resource use You can modify the resources you use in production by editing the env/production-scale.yml file. See https://heroku.com/ for details on resource use. Summary Congratulations! You've made it through the hemlock tutorial. You can now initialize, modify, and deploy hemlock projects. On the next page, I talk about some extra bells and whistles you'll likely find helpful.","title":"Deployment"},{"location":"tutorial/deploy/#deployment","text":"In the previous part of the tutorial, you learned how to debug your app with hemlock's custom debugging tool. In this part of the tutorial, you'll learn how to deploy your application (i.e. put it on the web).","title":"Deployment"},{"location":"tutorial/deploy/#setting-a-password","text":"If we were to deploy our study as is, anyone would be able to go to our app and download our study data. Setting a password is easy. Add this to the top of survey.py : from hemlock import settings settings.update({'password': 'my-password'}) Run your app and go to http://localhost:5000/download/ . You'll be redirected to a login page where you have to enter a password to access the download page.","title":"Setting a password"},{"location":"tutorial/deploy/#deployment-options","text":"Hemlock uses a Flask backend, which means you can deploy it just as you would any other Flask app. The Flask Mega-Tutorial is, imho, the best resource for learning Flask, including deployment. I remember deployment was the scariest part of this whole process when I was starting out. So, if you're using the hemlock template and hemlock-CLI, I've built in some tools to make this as easy as possible for you.","title":"Deployment options"},{"location":"tutorial/deploy/#setup-with-heroku","text":"The easiest way to deploy web apps is with heroku . The hemlock-CLI builds on the heroku-CLI for deployment. You can install these with hemlock-CLI: $ hlk setup win --heroku You will be prompted to login and create an account. All deployment options, including heroku, costs money, but not much, and hemlock studies aren't usually resource intensive. For reference, most hemlock studies I've run cost less than $10. Heroku also offers free resources so you can preview your app online without paying anything. Close and re-open your terminal, then verify your installation with: $ heroku --version","title":"Setup with heroku"},{"location":"tutorial/deploy/#production-lite","text":"Before scaling up your app, I recommend previewing it in what I call a 'production-lite' environment using free heroku resources: $ hlk deploy <my-app-name> Make sure your app name is unique. I do this by adding a few random digits to the end of the app name. Once this process finishes (~5 minutes), you'll be able to see your app at http://my-app-name.herokuapp.com/ . Go through your app and check for bugs before you start purchasing time on heroku servers. In addition to going through it manually, you can run the debugger in the production environment with: $ hlk debug --prod Where's the webdriver? In production, Chromedriver needs to run in 'headless' mode, meaning you won't be able to see the debugger going through the survey in your browser. You will, however, see it going through pages in the terminal window. If you later discover a bug, you can update your app with: $ hlk update","title":"Production-lite"},{"location":"tutorial/deploy/#production","text":"When you're satisfied that your app isn't going to crash, scale it up with: $ hlk production This will destroy your existing free database (and redis server, if you have one), and you'll be prompted to enter the name of your app to confirm. It then replaces your database with a more powerful one. You're now renting a heroku database and 10 web processes. If you don't know what this means, don't worry. As of 07/09/2020, these resources cost just more than half a cent per minute. If you play with your hemlock app for the next 10 minutes, it'll cost $0.07. If you run an MTurk study and leave it up for the next 12 hours, it'll cost $5. Importantly, when you're done with your app, destroy it with: $ hlk destroy","title":"Production"},{"location":"tutorial/deploy/#modifying-your-resource-use","text":"You can modify the resources you use in production by editing the env/production-scale.yml file. See https://heroku.com/ for details on resource use.","title":"Modifying your resource use"},{"location":"tutorial/deploy/#summary","text":"Congratulations! You've made it through the hemlock tutorial. You can now initialize, modify, and deploy hemlock projects. On the next page, I talk about some extra bells and whistles you'll likely find helpful.","title":"Summary"},{"location":"tutorial/extra/","text":"Bells and whistles You already know most of the important stuff. Here are some tips and tricks to make your life easier. Settings We've already used settings to set the password for the researcher dashboard. We can also use settings to change the default values of most attributes of most hemlock objects (see the API documentation for precise details). For example, let's add a back button to every page by default: from hemlock import Page, settings settings['Page'].update({'back': True}) path = Page().preview() Duplicates We often want to block the same participant from going through our survey multiple times. We do this with the duplicate_keys setting. This blocks visitors who match participants who've already completed the study on certain keys. For example: from hemlock import settings settings.update({'duplicate_keys': ['IPv4', 'workerId']}) This blocks participants who match existing participants on IP address (IPv4) or their MTurk workerId. Screenouts We may also want to screen out participants, e.g. if they've participated in similar studies we've run in the past. We do this by 1) uploading a file called screenouts.csv to the root directory of our hemlock project. The top row of the csv are keys on which we want to screen (much like the duplicate keys we saw above). Then modify the screenout_keys setting: from hemlock import settings settings.update({'screenout_keys': ['IPv4', 'workerId']}) Validation off During development and testing, we often want to be able to click through a survey quickly, ignoring validation. We can turn all validation off as follows: from hemlock import settings settings.update({'validate': False}) Google cloud buckets Hook up a Google cloud bucket to your app with: $ hlk gcloud-bucket <my-billing-account> Make sure you have a Google cloud computing account and Google Cloud SDK installed. If using WSL, you can install these with hemlock-CLI: $ hlk setup win --cloud-sdk Additionally, install the google cloud storage python API with: $ pip3 install google-cloud-storage # or hlk install google-cloud-storage (see below) Installing 3rd party packages We ordinarily install 3rd party packages with: $ pip install <requested-package> # or pip3 install <requested-package> If you're using heroku, you need to include these in a requirements.txt file. If you're sharing your hemlock project with collaborators, I recommend additionally adding these to a local-requirements.txt file. Hemlock-CLI has a shortcut for 1) installing 3rd party packages, 2) adding them to requirements.txt , and 3) adding them to local-requirements.txt : $ hlk install <requested-package> Redis Hemlock integrates seamlessly with Redis for running complex background processes during surveys. To run redis locally, use: $ hlk rq To spin up a redis server on heroku, set the REDIS_PLAN , WORKER_PROCTYPE , and WORKER_SCALE variables in env/production-scale.yml . See the API docs on workers for more details. Restarting your app If your app crashes in production and you don't have time to take it offline and debug it, you can reboot your app with: $ hlk restart This won't fix your bug, but it might keep it at bay for a little while.","title":"Bells and whistles"},{"location":"tutorial/extra/#bells-and-whistles","text":"You already know most of the important stuff. Here are some tips and tricks to make your life easier.","title":"Bells and whistles"},{"location":"tutorial/extra/#settings","text":"We've already used settings to set the password for the researcher dashboard. We can also use settings to change the default values of most attributes of most hemlock objects (see the API documentation for precise details). For example, let's add a back button to every page by default: from hemlock import Page, settings settings['Page'].update({'back': True}) path = Page().preview()","title":"Settings"},{"location":"tutorial/extra/#duplicates","text":"We often want to block the same participant from going through our survey multiple times. We do this with the duplicate_keys setting. This blocks visitors who match participants who've already completed the study on certain keys. For example: from hemlock import settings settings.update({'duplicate_keys': ['IPv4', 'workerId']}) This blocks participants who match existing participants on IP address (IPv4) or their MTurk workerId.","title":"Duplicates"},{"location":"tutorial/extra/#screenouts","text":"We may also want to screen out participants, e.g. if they've participated in similar studies we've run in the past. We do this by 1) uploading a file called screenouts.csv to the root directory of our hemlock project. The top row of the csv are keys on which we want to screen (much like the duplicate keys we saw above). Then modify the screenout_keys setting: from hemlock import settings settings.update({'screenout_keys': ['IPv4', 'workerId']})","title":"Screenouts"},{"location":"tutorial/extra/#validation-off","text":"During development and testing, we often want to be able to click through a survey quickly, ignoring validation. We can turn all validation off as follows: from hemlock import settings settings.update({'validate': False})","title":"Validation off"},{"location":"tutorial/extra/#google-cloud-buckets","text":"Hook up a Google cloud bucket to your app with: $ hlk gcloud-bucket <my-billing-account> Make sure you have a Google cloud computing account and Google Cloud SDK installed. If using WSL, you can install these with hemlock-CLI: $ hlk setup win --cloud-sdk Additionally, install the google cloud storage python API with: $ pip3 install google-cloud-storage # or hlk install google-cloud-storage (see below)","title":"Google cloud buckets"},{"location":"tutorial/extra/#installing-3rd-party-packages","text":"We ordinarily install 3rd party packages with: $ pip install <requested-package> # or pip3 install <requested-package> If you're using heroku, you need to include these in a requirements.txt file. If you're sharing your hemlock project with collaborators, I recommend additionally adding these to a local-requirements.txt file. Hemlock-CLI has a shortcut for 1) installing 3rd party packages, 2) adding them to requirements.txt , and 3) adding them to local-requirements.txt : $ hlk install <requested-package>","title":"Installing 3rd party packages"},{"location":"tutorial/extra/#redis","text":"Hemlock integrates seamlessly with Redis for running complex background processes during surveys. To run redis locally, use: $ hlk rq To spin up a redis server on heroku, set the REDIS_PLAN , WORKER_PROCTYPE , and WORKER_SCALE variables in env/production-scale.yml . See the API docs on workers for more details.","title":"Redis"},{"location":"tutorial/extra/#restarting-your-app","text":"If your app crashes in production and you don't have time to take it offline and debug it, you can reboot your app with: $ hlk restart This won't fix your bug, but it might keep it at bay for a little while.","title":"Restarting your app"},{"location":"tutorial/first_project/","text":"Your first project In the previous part of the tutorial, you installed the necessary software to get started with hemlock. By the end of this part of the tutorial, you'll be able to initialize a new hemlock project and create and preview hemlock survey pages. Initialize a new hemlock project From the hemlock template (recommended) I recommend starting hemlock projects from the hemlock template: $ hlk init my-first-project This will 'clone' the template into a folder my-first-project , set up a virtual environment, and pip install hemlock. Change into the project directory and activate the virtual environment. $ cd my-first-project $ source hemlock-venv/bin/activate It's good practice to use virtual environments and activate them whenever you're working on a project. Alternatively, from scratch Create a folder for your project and change into it: $ mkdir my-first-project $ cd my-first-project Create your virtual environment and activate it: $ python3 -m venv hemlock-venv $ source hemlock-venv/bin/activate Install hemlock: $ pip3 install hemlock-survey Preview a page in jupyter notebook Jupyter notebook is a great tool for iterating quickly on project designs. I recommend using it for most of your work. Open the jupyter dashboard with: $ jupyter notebook Jupyter will attempt to open the dashboard automatically in your browser. If this fails, the terminal window will show you links to the dashboard that you can manually copy and paste into your browser. Open the file named blackboard.ipynb . Run the first cell (Shift + Enter on windows) to set up the environment and application context. It's not important right now to understand exactly what it does. Now, create your first hemlock page. In a new code cell below the first one, enter the following: from hemlock import Page, Label p = Page(Label('<p>Hello, World!</p>')) p.preview() This opens a preview of your page in your browser. Previewing works by creating temporary preview files. When you're done previewing your files, it's good practice to delete them: os.remove(*app.tmpfiles) Modifications if using WSL If using Windows Subsystem for Linux (WSL), you'll need to specify your distribution as an environment variable. If using the hemlock template, open your local environment file: $ code env/local-env.yml And add the following line: WSL_DISTRIBUTION: Ubuntu # or other WSL distribution If not using the hemlock template, export the environment variable: $ export WSL_DISTRIBUTION=Ubuntu # or other WSL distribution Modifications if not using the template If you're not using the hemlock template, create a new python3 jupyter notebook and enter the following in the first cell: from hemlock import push_app_context app = push_app_context() This sets up your hemlock environment, including an application context , in the notebook. Code explanation The first line simply imports Page and Label objects. The next line, p = Page(Label('<p>Hello, World!</p>')) , creates a Page instance. A Page contains a list of 'questions' which it displays to participants. We set a page's questions by passing them as arguments to the constructor, or by setting the page's questions attribute, meaning that the following are equivalent: p = Page(Label('<p>Label 0</p>'), Label('<p>Label 1</p>')) p = Page() p.questions = [Label('<p>Label 0</p>'), Label('<p>Label 1</p>')] The Page 's question is a Label , although this is in some sense a misnomer because label objects only contains text. The first argument to Label is a string, written in html, which the label object displays on its page. Note. If you don't like writing html, you can easily find Word to html converters online. Summary In this part of the tutorial, you learned how to initialize a new hemlock project and create and preview a page. In the next part of the tutorial, you'll learn how to run a hemlock application locally.","title":"Your first project"},{"location":"tutorial/first_project/#your-first-project","text":"In the previous part of the tutorial, you installed the necessary software to get started with hemlock. By the end of this part of the tutorial, you'll be able to initialize a new hemlock project and create and preview hemlock survey pages.","title":"Your first project"},{"location":"tutorial/first_project/#initialize-a-new-hemlock-project","text":"","title":"Initialize a new hemlock project"},{"location":"tutorial/first_project/#from-the-hemlock-template-recommended","text":"I recommend starting hemlock projects from the hemlock template: $ hlk init my-first-project This will 'clone' the template into a folder my-first-project , set up a virtual environment, and pip install hemlock. Change into the project directory and activate the virtual environment. $ cd my-first-project $ source hemlock-venv/bin/activate It's good practice to use virtual environments and activate them whenever you're working on a project.","title":"From the hemlock template (recommended)"},{"location":"tutorial/first_project/#alternatively-from-scratch","text":"Create a folder for your project and change into it: $ mkdir my-first-project $ cd my-first-project Create your virtual environment and activate it: $ python3 -m venv hemlock-venv $ source hemlock-venv/bin/activate Install hemlock: $ pip3 install hemlock-survey","title":"Alternatively, from scratch"},{"location":"tutorial/first_project/#preview-a-page-in-jupyter-notebook","text":"Jupyter notebook is a great tool for iterating quickly on project designs. I recommend using it for most of your work. Open the jupyter dashboard with: $ jupyter notebook Jupyter will attempt to open the dashboard automatically in your browser. If this fails, the terminal window will show you links to the dashboard that you can manually copy and paste into your browser. Open the file named blackboard.ipynb . Run the first cell (Shift + Enter on windows) to set up the environment and application context. It's not important right now to understand exactly what it does. Now, create your first hemlock page. In a new code cell below the first one, enter the following: from hemlock import Page, Label p = Page(Label('<p>Hello, World!</p>')) p.preview() This opens a preview of your page in your browser. Previewing works by creating temporary preview files. When you're done previewing your files, it's good practice to delete them: os.remove(*app.tmpfiles)","title":"Preview a page in jupyter notebook"},{"location":"tutorial/first_project/#modifications-if-using-wsl","text":"If using Windows Subsystem for Linux (WSL), you'll need to specify your distribution as an environment variable. If using the hemlock template, open your local environment file: $ code env/local-env.yml And add the following line: WSL_DISTRIBUTION: Ubuntu # or other WSL distribution If not using the hemlock template, export the environment variable: $ export WSL_DISTRIBUTION=Ubuntu # or other WSL distribution","title":"Modifications if using WSL"},{"location":"tutorial/first_project/#modifications-if-not-using-the-template","text":"If you're not using the hemlock template, create a new python3 jupyter notebook and enter the following in the first cell: from hemlock import push_app_context app = push_app_context() This sets up your hemlock environment, including an application context , in the notebook.","title":"Modifications if not using the template"},{"location":"tutorial/first_project/#code-explanation","text":"The first line simply imports Page and Label objects. The next line, p = Page(Label('<p>Hello, World!</p>')) , creates a Page instance. A Page contains a list of 'questions' which it displays to participants. We set a page's questions by passing them as arguments to the constructor, or by setting the page's questions attribute, meaning that the following are equivalent: p = Page(Label('<p>Label 0</p>'), Label('<p>Label 1</p>')) p = Page() p.questions = [Label('<p>Label 0</p>'), Label('<p>Label 1</p>')] The Page 's question is a Label , although this is in some sense a misnomer because label objects only contains text. The first argument to Label is a string, written in html, which the label object displays on its page. Note. If you don't like writing html, you can easily find Word to html converters online.","title":"Code explanation"},{"location":"tutorial/first_project/#summary","text":"In this part of the tutorial, you learned how to initialize a new hemlock project and create and preview a page. In the next part of the tutorial, you'll learn how to run a hemlock application locally.","title":"Summary"},{"location":"tutorial/intro/","text":"Introduction This tutorial will guide you through the essentials of hemlock. By the end of it, you'll be able to initialize hemlock projects, create powerful experiments and surveys, and deploy them on the web. Start with the end product in mind When learning to program - or anything else - start with the end product in mind. This is my spin-off of Covey's start with the end in mind , where the end is something you've produced rather than knowledge you've acquired. I personally find that aiming at a product makes me more knowledgable about a topic than aiming at knowledge itself. In this spirit, our goal is to create a behavioral study in which participants play an ultimatum game with each other in real time. You can see the end product here: http://hemlock-tutorial.herokuapp.com/ . The complete survey code is here: https://github.com/dsbowen/Hemlock/blob/master/survey.py . The ultimatum game is famous; studied in hundreds of academic papers in disciplines such as game theory, behavioral economics, experimental economics, marketing, psychology, sociology, and neuroscience. It involves two players; a proposer and a responder . We begin by endowing the proposer with a 'pot' of (usually) money, e.g. $20. The proposer then proposes a 'split' of the pot between him/herself and the responder (e.g. I get $15, you get $5 ). The responder can accept or reject the proposed split. If the responder accepts, the pot is split according to the proposal (e.g. proposer gets $15, responder gets $5). If the responder rejects the proposal, both players get nothing. With nearly 2000 citations, this 1991 American Economic Review paper studies how play evolves over successive rounds. It finds that proposers usually make 'fair' offers (about a 50-50 split), and responders usually reject unfair offers, in early rounds. As the game continues, proposers make more unfair offers, and responders are more accepting of them. The study we'll make in the hemlock tutorial is designed to replicate this finding. Getting started On the next page, we'll download the necessary software to get started.","title":"Introduction"},{"location":"tutorial/intro/#introduction","text":"This tutorial will guide you through the essentials of hemlock. By the end of it, you'll be able to initialize hemlock projects, create powerful experiments and surveys, and deploy them on the web.","title":"Introduction"},{"location":"tutorial/intro/#start-with-the-end-product-in-mind","text":"When learning to program - or anything else - start with the end product in mind. This is my spin-off of Covey's start with the end in mind , where the end is something you've produced rather than knowledge you've acquired. I personally find that aiming at a product makes me more knowledgable about a topic than aiming at knowledge itself. In this spirit, our goal is to create a behavioral study in which participants play an ultimatum game with each other in real time. You can see the end product here: http://hemlock-tutorial.herokuapp.com/ . The complete survey code is here: https://github.com/dsbowen/Hemlock/blob/master/survey.py . The ultimatum game is famous; studied in hundreds of academic papers in disciplines such as game theory, behavioral economics, experimental economics, marketing, psychology, sociology, and neuroscience. It involves two players; a proposer and a responder . We begin by endowing the proposer with a 'pot' of (usually) money, e.g. $20. The proposer then proposes a 'split' of the pot between him/herself and the responder (e.g. I get $15, you get $5 ). The responder can accept or reject the proposed split. If the responder accepts, the pot is split according to the proposal (e.g. proposer gets $15, responder gets $5). If the responder rejects the proposal, both players get nothing. With nearly 2000 citations, this 1991 American Economic Review paper studies how play evolves over successive rounds. It finds that proposers usually make 'fair' offers (about a 50-50 split), and responders usually reject unfair offers, in early rounds. As the game continues, proposers make more unfair offers, and responders are more accepting of them. The study we'll make in the hemlock tutorial is designed to replicate this finding.","title":"Start with the end product in mind"},{"location":"tutorial/intro/#getting-started","text":"On the next page, we'll download the necessary software to get started.","title":"Getting started"},{"location":"tutorial/navigate/","text":"Navigate In the previous part of the tutorial, you implemented a confirmation page using compile functions. By the end of this part of the tutorial, you'll be able to set up navigation between branches. Why navigate functions? Navigate functions move participants through different branches of the survey. For example, participants in the control group might follow one branch, while participants in the treatment group follow another. In our case, we'll use a navigate function to bring participants from the demographics branch of our survey to a branch in which participants will an ultimatum game with each other. Basic syntax Open your jupter notebook and run the following: from hemlock import Branch, Navigate, Page, Participant def start(): return Navigate.end(Branch(Page(), Page())) @Navigate.register def end(start_branch): return Branch(Page(terminal=True)) part = Participant.gen_test_participant(start) part.view_nav() Out: <Branch 1> <Page 1> C <Page 2> C = current page T = terminal page Unlike validate, submit, and compile functions, there are no prebuilt navigate functions. We register a custom navigate function with the @Navigate.register decorator. The navigate function takes an 'origin' branch or page as its first argument (in this case, the branch returned by start ). Navigate functions return a Branch object. After registering end as a navigate function, Navigate.end adds the navigate function to a branch or page, then returns the branch or page to which it was added. Once the participant reaches the end of the branch returned by start , they are brought to the branch returned by end . part.view_nav() prints the participant's 'branch stack'. Right now the participant is on the branch created by start . Let's make our test participant navigate forward and view the navigation again: part.forward().view_nav() Out: <Branch 1> <Page 1> <Page 2> C C = current page T = terminal page And again: part.forward().view_nav() Out: <Branch 1> <Page 1> <Page 2> <Branch 2> <Page 3> C T What happened? Our participant reached the end of the start branch (branch 1) and navigated to the end branch (branch 2). It's currently on page 3, which is the last (terminal) page of the survey. Note. You won't call view_nav or forward in the survey; hemlock takes care of the navigation for you. These are just useful for debugging in jupyter. Branching off pages Branching off of branches allows us to navigate to a new branch at the end of our current branch. But occasionally, we'll want to navigate to a new branch from the middle of our current branch. To do this, we'll branch off of a page. This time, instead of attaching the navigate function to the branch, we'll attach it to the first page of the branch: from hemlock import Branch, Navigate, Page, Participant def start(): return Branch(Navigate.middle(Page()), Page(terminal=True)) @Navigate.register def middle(start_branch): return Branch(Page()) part = Participant.gen_test_participant(start) As before, run part.view_nav() and part.forward() a few times. This is what you'll see: <Branch 1> <Page 1> C <Page 2> T <Branch 1> <Page 1> <Branch 2> <Page 3> C <Page 2> T <Branch 1> <Page 1> <Branch 2> <Page 3> <Page 2> C T What happened? We started on the first page of the start branch (branch 1, page 1). Then, we branched off of page 1 to the middle branch (branch 2, page 3). At the end of the middle branch, we picked up where we left off on the start branch (branch 1, page 2). Note. Going back is just as easy. Simply use my_page.back=True . To play with this in the notebook, use my_participant.back() instead of my_participant.forward() . Navigation in our app Now that we've seen how to add navigate functions in our notebook, let's add it to our app. In survey.py : from hemlock import Branch, Check, Compile, Embedded, Input, Label, Navigate, Page, Range, Select, Submit, Validate, route from hemlock.tools import join from datetime import datetime @route('/survey') def start(): demographics_page = Page( # DEMOGRAPHICS PAGE HERE ) return Navigate.ultimatum_game(Branch( demographics_page, Page(Compile.confirm(Label(), demographics_page), back=True) )) ... @Navigate.register def ultimatum_game(start_branch): return Branch(Page( Label('<p>You are about to play an ultimatum game...</p>'), terminal=True )) Run the app again and navigate past the demographics page. You'll find yourself on our new ultimatum game branch. Summary In this part of the tutorial, you learned how to navigate between branches. In the next part of the tutorial, we'll tie together some of the things you've learned about page logic.","title":"Navigate"},{"location":"tutorial/navigate/#navigate","text":"In the previous part of the tutorial, you implemented a confirmation page using compile functions. By the end of this part of the tutorial, you'll be able to set up navigation between branches.","title":"Navigate"},{"location":"tutorial/navigate/#why-navigate-functions","text":"Navigate functions move participants through different branches of the survey. For example, participants in the control group might follow one branch, while participants in the treatment group follow another. In our case, we'll use a navigate function to bring participants from the demographics branch of our survey to a branch in which participants will an ultimatum game with each other.","title":"Why navigate functions?"},{"location":"tutorial/navigate/#basic-syntax","text":"Open your jupter notebook and run the following: from hemlock import Branch, Navigate, Page, Participant def start(): return Navigate.end(Branch(Page(), Page())) @Navigate.register def end(start_branch): return Branch(Page(terminal=True)) part = Participant.gen_test_participant(start) part.view_nav() Out: <Branch 1> <Page 1> C <Page 2> C = current page T = terminal page Unlike validate, submit, and compile functions, there are no prebuilt navigate functions. We register a custom navigate function with the @Navigate.register decorator. The navigate function takes an 'origin' branch or page as its first argument (in this case, the branch returned by start ). Navigate functions return a Branch object. After registering end as a navigate function, Navigate.end adds the navigate function to a branch or page, then returns the branch or page to which it was added. Once the participant reaches the end of the branch returned by start , they are brought to the branch returned by end . part.view_nav() prints the participant's 'branch stack'. Right now the participant is on the branch created by start . Let's make our test participant navigate forward and view the navigation again: part.forward().view_nav() Out: <Branch 1> <Page 1> <Page 2> C C = current page T = terminal page And again: part.forward().view_nav() Out: <Branch 1> <Page 1> <Page 2> <Branch 2> <Page 3> C T What happened? Our participant reached the end of the start branch (branch 1) and navigated to the end branch (branch 2). It's currently on page 3, which is the last (terminal) page of the survey. Note. You won't call view_nav or forward in the survey; hemlock takes care of the navigation for you. These are just useful for debugging in jupyter.","title":"Basic syntax"},{"location":"tutorial/navigate/#branching-off-pages","text":"Branching off of branches allows us to navigate to a new branch at the end of our current branch. But occasionally, we'll want to navigate to a new branch from the middle of our current branch. To do this, we'll branch off of a page. This time, instead of attaching the navigate function to the branch, we'll attach it to the first page of the branch: from hemlock import Branch, Navigate, Page, Participant def start(): return Branch(Navigate.middle(Page()), Page(terminal=True)) @Navigate.register def middle(start_branch): return Branch(Page()) part = Participant.gen_test_participant(start) As before, run part.view_nav() and part.forward() a few times. This is what you'll see: <Branch 1> <Page 1> C <Page 2> T <Branch 1> <Page 1> <Branch 2> <Page 3> C <Page 2> T <Branch 1> <Page 1> <Branch 2> <Page 3> <Page 2> C T What happened? We started on the first page of the start branch (branch 1, page 1). Then, we branched off of page 1 to the middle branch (branch 2, page 3). At the end of the middle branch, we picked up where we left off on the start branch (branch 1, page 2). Note. Going back is just as easy. Simply use my_page.back=True . To play with this in the notebook, use my_participant.back() instead of my_participant.forward() .","title":"Branching off pages"},{"location":"tutorial/navigate/#navigation-in-our-app","text":"Now that we've seen how to add navigate functions in our notebook, let's add it to our app. In survey.py : from hemlock import Branch, Check, Compile, Embedded, Input, Label, Navigate, Page, Range, Select, Submit, Validate, route from hemlock.tools import join from datetime import datetime @route('/survey') def start(): demographics_page = Page( # DEMOGRAPHICS PAGE HERE ) return Navigate.ultimatum_game(Branch( demographics_page, Page(Compile.confirm(Label(), demographics_page), back=True) )) ... @Navigate.register def ultimatum_game(start_branch): return Branch(Page( Label('<p>You are about to play an ultimatum game...</p>'), terminal=True )) Run the app again and navigate past the demographics page. You'll find yourself on our new ultimatum game branch.","title":"Navigation in our app"},{"location":"tutorial/navigate/#summary","text":"In this part of the tutorial, you learned how to navigate between branches. In the next part of the tutorial, we'll tie together some of the things you've learned about page logic.","title":"Summary"},{"location":"tutorial/page_logic/","text":"Page logic Now that you've seen compile, validate, submit, and navigate functions, it's time to discuss the logic of hemlock pages. It's not important to fully understand this now, as long as you have a rough sense of the order in which things happen. Compile. The page executes its compile functions. By default, a page's first compile function runs its questions' compile methods. A question's compile method, in turn, executes its compile functions. Render. The page html is rendered and displayed to the participant. Record responses. When the participant submits a page, we record their responses to every question on the page. This sets the questions' response attribute. Validate. After recording all responses, the page executes its validate functions. By default, a page's first validate function runs its questions' validate methods. A question's validate method, in turn, executes its validate functions. When a page or question executes its validate functions, it does so one by one, and if any of them uncover an error (i.e. return a string instead of None ), validation for that object stops. For example, suppose we attach two validate functions with Validate.is_type(Validate.require(Input()), float) . When the input question runs its validate method, the first validate function checks that the participant entered a response. Only if they entered a response does the second validate function check that the participant's response can by converted to float . Record data. The page records the data associated with the participant's responses to every question on the page. This sets the questions' data attribute. Submit. The page executes its submit functions. By default, a page's first submit function runs its questions' submit methods. A question's submit method, in turn, executes its submit functions. Navigate. If the page has a navigate function, execute the function and bring the participant to the start of the new branch the function returns. If the page has no navigate function, and the participant has reached the end a a branch, the branch executes its navigate function and brings the participant to the start of the new branch returned by the function. You can visualize compile functions (validate and submit functions are similar) as follows: Page 1 compile method Page 1 compile function 1 Question 1 compile method Question 1 compile function 1 Question 1 compile function 2 ... Question 2 compile method Question 2 compile function 1 Question 2 compile function 2 ... ... Page 1 compile function 2 ... In the next part of the tutorial, we'll give our participants instructions on how to play the ultimatum game and verify their understanding with a comprehension check.","title":"Page logic"},{"location":"tutorial/page_logic/#page-logic","text":"Now that you've seen compile, validate, submit, and navigate functions, it's time to discuss the logic of hemlock pages. It's not important to fully understand this now, as long as you have a rough sense of the order in which things happen. Compile. The page executes its compile functions. By default, a page's first compile function runs its questions' compile methods. A question's compile method, in turn, executes its compile functions. Render. The page html is rendered and displayed to the participant. Record responses. When the participant submits a page, we record their responses to every question on the page. This sets the questions' response attribute. Validate. After recording all responses, the page executes its validate functions. By default, a page's first validate function runs its questions' validate methods. A question's validate method, in turn, executes its validate functions. When a page or question executes its validate functions, it does so one by one, and if any of them uncover an error (i.e. return a string instead of None ), validation for that object stops. For example, suppose we attach two validate functions with Validate.is_type(Validate.require(Input()), float) . When the input question runs its validate method, the first validate function checks that the participant entered a response. Only if they entered a response does the second validate function check that the participant's response can by converted to float . Record data. The page records the data associated with the participant's responses to every question on the page. This sets the questions' data attribute. Submit. The page executes its submit functions. By default, a page's first submit function runs its questions' submit methods. A question's submit method, in turn, executes its submit functions. Navigate. If the page has a navigate function, execute the function and bring the participant to the start of the new branch the function returns. If the page has no navigate function, and the participant has reached the end a a branch, the branch executes its navigate function and brings the participant to the start of the new branch returned by the function. You can visualize compile functions (validate and submit functions are similar) as follows: Page 1 compile method Page 1 compile function 1 Question 1 compile method Question 1 compile function 1 Question 1 compile function 2 ... Question 2 compile method Question 2 compile function 1 Question 2 compile function 2 ... ... Page 1 compile function 2 ... In the next part of the tutorial, we'll give our participants instructions on how to play the ultimatum game and verify their understanding with a comprehension check.","title":"Page logic"},{"location":"tutorial/proposer_branch/","text":"Proposer branch In the previous part of the tutorial, you learned how to randomly assign participants to conditions. In this part of the tutorial, you'll implement the proposer branch of the ultimatum game. The proposal input First, we'll write a function to generate an input question where the proposer will input the proposed split. Enter the following in your jupyter notebook: from hemlock import Input, Label, Page, Submit, Validate N_ROUNDS = 5 POT = 20 def gen_proposal_input(round_): return Submit.data_type( Validate.range_val( Input( ''' <p><b>Round {} of {}</b></p> <p>You have ${} to split between you and the responder. How much money would you like to offer to the responder?</p> '''.format(round_, N_ROUNDS, POT), prepend='$', append='.00', var='Proposal' ), min_=0, max_=POT ), int ) path = Page(gen_proposal_input(1)).preview() This function generates an input which asks the proposer how much money they would like to offer to the responder. We record the data in a variable named 'Proposal' . We add range validation so that the proposer inputs an integer between 0 and the size of the pot. We also add a submit function which converts the data type to an integer. Note. For input questions, the data are recorded as strings. We want to reference this question's data as an integer, so we use Submit.data_type(Input(), int) to convert it when the page is submitted. Finding a responder We can use the SQLAlchemy Query API to pair the proposer with a random responder this round. In our notebook, we'll create an input question with the variable name 'Response' . We'll then use the Query API to get all input questions with that variable name and select the data from one of them at random: import random response_input = Input(var='Response', data=5) response_inputs = Input.query.filter( Input.var=='Response', Input.data!=None ).all() random.choice(response_inputs).data Out: 5 As expected, this matches the data from our response input. Displaying the proposer outcome Now we want to display the outcome of the round to the proposer. This calls for a compile function: from hemlock import Compile, Embedded from random import randint @Compile.register def proposer_outcome(outcome_label, proposal_input): # get the proposal proposal = POT-proposal_input.data, proposal_input.data # get all responses response_inputs = Input.query.filter( Input.var=='Response', Input.data!=None ).all() if response_inputs: # randomly choose a response response = random.choice(response_inputs).data else: # no responses are available # e.g. if this is the first participant response = randint(0, POT) # compute the payoff accept = response <= proposal[1] payoff = proposal if accept else (0, 0) # record results as embedded data outcome_label.page.embedded = [ Embedded('Response', response), Embedded('Accept', int(accept)), Embedded('ProposerPayoff', payoff[0]), Embedded('ResponderPayoff', payoff[1]) ] # describe the outcome of the round outcome_label.label = ''' <p>You proposed the following split:</p> <ul> <li>You: ${}</li> <li>Responder: ${}</li> </ul> <p>The responder said they will accept any proposal which gives them at least ${}.</p> <p><b>Your proposal was {}, giving you a payoff of ${}.</b></p> '''.format( *proposal, response, 'accepted' if accept else 'rejected', payoff[0] ) proposal_outcome_page = Page(Compile.proposer_outcome( Label(), Input(data=10) )) path = proposal_outcome_page._compile().preview() Let's go through this step by step. First, we get the proposal from the proposal input question. Remember that we converted the data for this input to an integer using a submit function. The data for this input is the amount of money the proposer offered to the responder, meaning that the proposed split is (POT-proposal_input.data, proposal_input.data) . Second, we use the Query API to randomly select a response input question. We modify our above code to account for the fact that, if the first participant is a proposer, there won't be any responses to choose from. So, if our query can't find any response input questions, we return a random response. Third, we compute the payoff and record the results of the round using embedded data. Finally, we set the outcome label's label attribute to display the outcome of the round. Notice that the outcome of the round is recorded in the proposer's outcome page's embedded data: [(e.var, e.data) for e in proposal_outcome_page.embedded] Out: [('Response', 5), ('Accept', 1), ('ProposerPayoff', 10), ('ResponderPayoff', 10)] Adding the proposer branch to our survey Navigating to the proposer branch We'll begin by modifying the ultimatum game branch to navigate to the proposer branch if the participant was assigned to be a proposer. In survey.py : ... @Navigate.register def ultimatum_game(start_branch): ... proposer = assigner.next()['Proposer'] branch.pages.append(Page( Label(''' <p>You are about to play an ultimatum game as a <b>{}</b>.</p> '''.format('proposer' if proposer else 'responder') ), # REMOVE terminal=True )) if proposer: return Navigate.proposer_branch(branch) else: # WE'LL IMPLEMENT THE RESPONDER BRANCH IN THE NEXT PART OF THE TUTORIAL return branch ... The proposer branch navigate function Next we'll add our proposer navigate function to the bottom of survey.py : from hemlock import Branch, Check, Compile, Embedded, Input, Label, Navigate, Page, Range, Select, Submit, Validate, route from hemlock.tools import Assigner, comprehension_check, join import random # ADD THIS IMPORT AT THE TOP OF THE FILE from datetime import datetime from random import randint ... @Navigate.register def proposer_branch(ultimatum_game_branch=None): branch = Branch() for round_ in range(N_ROUNDS): proposal_input = gen_proposal_input(round_+1) branch.pages.append(Page(proposal_input)) branch.pages.append(Page(Compile.proposer_outcome( Label(), proposal_input ))) branch.pages.append(Page( Label('<p>Thank you for completing the hemlock tutorial!</p>'), terminal=True )) return branch This navigate function simply adds two pages to the proposer branch for each of N_ROUNDS . The first page asks the proposer to propose a split. The second page displays the outcome of the round. Generating the proposal input and outcome label Finally, we'll add the gen_proposal_input and proposer_outcome functions we wrote in our notebook: ... def gen_proposal_input(round_): # AS IN THE NOTEBOOK @Compile.register def proposer_outcome(outcome_label, proposal_input): # AS IN THE NOTEBOOK Run the app and see what the survey looks like in the proposer condition. Summary In this part of the tutorial, you implemented the proposer branch. In the next part of the tutorial, you'll implement the responder branch.","title":"Proposer branch"},{"location":"tutorial/proposer_branch/#proposer-branch","text":"In the previous part of the tutorial, you learned how to randomly assign participants to conditions. In this part of the tutorial, you'll implement the proposer branch of the ultimatum game.","title":"Proposer branch"},{"location":"tutorial/proposer_branch/#the-proposal-input","text":"First, we'll write a function to generate an input question where the proposer will input the proposed split. Enter the following in your jupyter notebook: from hemlock import Input, Label, Page, Submit, Validate N_ROUNDS = 5 POT = 20 def gen_proposal_input(round_): return Submit.data_type( Validate.range_val( Input( ''' <p><b>Round {} of {}</b></p> <p>You have ${} to split between you and the responder. How much money would you like to offer to the responder?</p> '''.format(round_, N_ROUNDS, POT), prepend='$', append='.00', var='Proposal' ), min_=0, max_=POT ), int ) path = Page(gen_proposal_input(1)).preview() This function generates an input which asks the proposer how much money they would like to offer to the responder. We record the data in a variable named 'Proposal' . We add range validation so that the proposer inputs an integer between 0 and the size of the pot. We also add a submit function which converts the data type to an integer. Note. For input questions, the data are recorded as strings. We want to reference this question's data as an integer, so we use Submit.data_type(Input(), int) to convert it when the page is submitted.","title":"The proposal input"},{"location":"tutorial/proposer_branch/#finding-a-responder","text":"We can use the SQLAlchemy Query API to pair the proposer with a random responder this round. In our notebook, we'll create an input question with the variable name 'Response' . We'll then use the Query API to get all input questions with that variable name and select the data from one of them at random: import random response_input = Input(var='Response', data=5) response_inputs = Input.query.filter( Input.var=='Response', Input.data!=None ).all() random.choice(response_inputs).data Out: 5 As expected, this matches the data from our response input.","title":"Finding a responder"},{"location":"tutorial/proposer_branch/#displaying-the-proposer-outcome","text":"Now we want to display the outcome of the round to the proposer. This calls for a compile function: from hemlock import Compile, Embedded from random import randint @Compile.register def proposer_outcome(outcome_label, proposal_input): # get the proposal proposal = POT-proposal_input.data, proposal_input.data # get all responses response_inputs = Input.query.filter( Input.var=='Response', Input.data!=None ).all() if response_inputs: # randomly choose a response response = random.choice(response_inputs).data else: # no responses are available # e.g. if this is the first participant response = randint(0, POT) # compute the payoff accept = response <= proposal[1] payoff = proposal if accept else (0, 0) # record results as embedded data outcome_label.page.embedded = [ Embedded('Response', response), Embedded('Accept', int(accept)), Embedded('ProposerPayoff', payoff[0]), Embedded('ResponderPayoff', payoff[1]) ] # describe the outcome of the round outcome_label.label = ''' <p>You proposed the following split:</p> <ul> <li>You: ${}</li> <li>Responder: ${}</li> </ul> <p>The responder said they will accept any proposal which gives them at least ${}.</p> <p><b>Your proposal was {}, giving you a payoff of ${}.</b></p> '''.format( *proposal, response, 'accepted' if accept else 'rejected', payoff[0] ) proposal_outcome_page = Page(Compile.proposer_outcome( Label(), Input(data=10) )) path = proposal_outcome_page._compile().preview() Let's go through this step by step. First, we get the proposal from the proposal input question. Remember that we converted the data for this input to an integer using a submit function. The data for this input is the amount of money the proposer offered to the responder, meaning that the proposed split is (POT-proposal_input.data, proposal_input.data) . Second, we use the Query API to randomly select a response input question. We modify our above code to account for the fact that, if the first participant is a proposer, there won't be any responses to choose from. So, if our query can't find any response input questions, we return a random response. Third, we compute the payoff and record the results of the round using embedded data. Finally, we set the outcome label's label attribute to display the outcome of the round. Notice that the outcome of the round is recorded in the proposer's outcome page's embedded data: [(e.var, e.data) for e in proposal_outcome_page.embedded] Out: [('Response', 5), ('Accept', 1), ('ProposerPayoff', 10), ('ResponderPayoff', 10)]","title":"Displaying the proposer outcome"},{"location":"tutorial/proposer_branch/#adding-the-proposer-branch-to-our-survey","text":"","title":"Adding the proposer branch to our survey"},{"location":"tutorial/proposer_branch/#navigating-to-the-proposer-branch","text":"We'll begin by modifying the ultimatum game branch to navigate to the proposer branch if the participant was assigned to be a proposer. In survey.py : ... @Navigate.register def ultimatum_game(start_branch): ... proposer = assigner.next()['Proposer'] branch.pages.append(Page( Label(''' <p>You are about to play an ultimatum game as a <b>{}</b>.</p> '''.format('proposer' if proposer else 'responder') ), # REMOVE terminal=True )) if proposer: return Navigate.proposer_branch(branch) else: # WE'LL IMPLEMENT THE RESPONDER BRANCH IN THE NEXT PART OF THE TUTORIAL return branch ...","title":"Navigating to the proposer branch"},{"location":"tutorial/proposer_branch/#the-proposer-branch-navigate-function","text":"Next we'll add our proposer navigate function to the bottom of survey.py : from hemlock import Branch, Check, Compile, Embedded, Input, Label, Navigate, Page, Range, Select, Submit, Validate, route from hemlock.tools import Assigner, comprehension_check, join import random # ADD THIS IMPORT AT THE TOP OF THE FILE from datetime import datetime from random import randint ... @Navigate.register def proposer_branch(ultimatum_game_branch=None): branch = Branch() for round_ in range(N_ROUNDS): proposal_input = gen_proposal_input(round_+1) branch.pages.append(Page(proposal_input)) branch.pages.append(Page(Compile.proposer_outcome( Label(), proposal_input ))) branch.pages.append(Page( Label('<p>Thank you for completing the hemlock tutorial!</p>'), terminal=True )) return branch This navigate function simply adds two pages to the proposer branch for each of N_ROUNDS . The first page asks the proposer to propose a split. The second page displays the outcome of the round.","title":"The proposer branch navigate function"},{"location":"tutorial/proposer_branch/#generating-the-proposal-input-and-outcome-label","text":"Finally, we'll add the gen_proposal_input and proposer_outcome functions we wrote in our notebook: ... def gen_proposal_input(round_): # AS IN THE NOTEBOOK @Compile.register def proposer_outcome(outcome_label, proposal_input): # AS IN THE NOTEBOOK Run the app and see what the survey looks like in the proposer condition.","title":"Generating the proposal input and outcome label"},{"location":"tutorial/proposer_branch/#summary","text":"In this part of the tutorial, you implemented the proposer branch. In the next part of the tutorial, you'll implement the responder branch.","title":"Summary"},{"location":"tutorial/qpolymorphs/","text":"Question polymorphs In the previous part of the tutorial, you learned how to initialize a hemlock application and run it locally. By the end of this part of the tutorial, you'll be able to add a variety of question polymorphs to your survey pages. Creating a demographics page We'll use jupyter notebook as a blackboard to iterate on our demographics page design. After pushing the application context, we'll create the following page: from hemlock import Check, Input, Page, Label, Range, Select p = Page( Input( '<p>Enter your date of birth.</p>', placeholder='mm/dd/yyyy' ), Check( '<p>Indicate your gender.</p>', ['Male', 'Female', 'Other'] ), Check( '<p>Indicate your race or ethnicity. Check as many as apply.</p>', [ 'White', 'Black or African-American', 'Asian', 'Native Hawaiian or other Pacific Islander', 'Other', ], multiple=True ), Select( '<p>Select your current marital status.</p>', [ 'Married', 'Widowed', 'Divorced', 'Separated', 'Never married', ] ), Range( ''' <p>At the right end of the scale are the people who are the best off; those who have the most money, the most education, and the best jobs. On the left are the people who are the worst off; those who have the least money, the least education, and the worst jobs (or are unemployed). Please indicate where you think you stand on this scale.</p> ''', min=0, max=10 ), ) As usual, use p.preview() to preview the page and os.remove(*app.tmpfiles) when you're done. Code explanation Here we add several 'question polymorphs' (i.e. types of questions) to our page. The first is an input. We add placeholder='mm/dd/yyyy' , telling participants the expected format of their date of birth. The next two are check questions, which allow participants to check one or more choices. Notice that the first check question allows participants to check only one choice; we allow participants to check multiple choices in the second check question by passing multiple=True . The fourth question is a select (dropdown) question. If we wanted, we also could have passed multiple=True to its contructor to allow participants to select multiple options. Our final question is a range slider. By default, it goes from 0 to 100, but we set its range from 0 to 10 here. Adding the page to the survey Once we're satisfied with the preview, we incorporate the page into our survey. Our survey.py file should be: from hemlock import Branch, Check, Input, Page, Label, Range, Select, route @route('/survey') def start(): return Branch( Page( Input( '<p>Enter your date of birth.</p>', placeholder='mm/dd/yyyy' ), # INSERT THE REST OF THE DEMOGRAPHICS PAGE HERE ), Page( Label('<p>Thank you for completing this survey.</p>'), terminal=True ) ) Summary In this part of the tutorial, you learned how to create a demographics questionnaire using several question polymorphs. In the next part of the tutorial, you'll learn how to store and download survey data.","title":"Question polymorphs"},{"location":"tutorial/qpolymorphs/#question-polymorphs","text":"In the previous part of the tutorial, you learned how to initialize a hemlock application and run it locally. By the end of this part of the tutorial, you'll be able to add a variety of question polymorphs to your survey pages.","title":"Question polymorphs"},{"location":"tutorial/qpolymorphs/#creating-a-demographics-page","text":"We'll use jupyter notebook as a blackboard to iterate on our demographics page design. After pushing the application context, we'll create the following page: from hemlock import Check, Input, Page, Label, Range, Select p = Page( Input( '<p>Enter your date of birth.</p>', placeholder='mm/dd/yyyy' ), Check( '<p>Indicate your gender.</p>', ['Male', 'Female', 'Other'] ), Check( '<p>Indicate your race or ethnicity. Check as many as apply.</p>', [ 'White', 'Black or African-American', 'Asian', 'Native Hawaiian or other Pacific Islander', 'Other', ], multiple=True ), Select( '<p>Select your current marital status.</p>', [ 'Married', 'Widowed', 'Divorced', 'Separated', 'Never married', ] ), Range( ''' <p>At the right end of the scale are the people who are the best off; those who have the most money, the most education, and the best jobs. On the left are the people who are the worst off; those who have the least money, the least education, and the worst jobs (or are unemployed). Please indicate where you think you stand on this scale.</p> ''', min=0, max=10 ), ) As usual, use p.preview() to preview the page and os.remove(*app.tmpfiles) when you're done.","title":"Creating a demographics page"},{"location":"tutorial/qpolymorphs/#code-explanation","text":"Here we add several 'question polymorphs' (i.e. types of questions) to our page. The first is an input. We add placeholder='mm/dd/yyyy' , telling participants the expected format of their date of birth. The next two are check questions, which allow participants to check one or more choices. Notice that the first check question allows participants to check only one choice; we allow participants to check multiple choices in the second check question by passing multiple=True . The fourth question is a select (dropdown) question. If we wanted, we also could have passed multiple=True to its contructor to allow participants to select multiple options. Our final question is a range slider. By default, it goes from 0 to 100, but we set its range from 0 to 10 here.","title":"Code explanation"},{"location":"tutorial/qpolymorphs/#adding-the-page-to-the-survey","text":"Once we're satisfied with the preview, we incorporate the page into our survey. Our survey.py file should be: from hemlock import Branch, Check, Input, Page, Label, Range, Select, route @route('/survey') def start(): return Branch( Page( Input( '<p>Enter your date of birth.</p>', placeholder='mm/dd/yyyy' ), # INSERT THE REST OF THE DEMOGRAPHICS PAGE HERE ), Page( Label('<p>Thank you for completing this survey.</p>'), terminal=True ) )","title":"Adding the page to the survey"},{"location":"tutorial/qpolymorphs/#summary","text":"In this part of the tutorial, you learned how to create a demographics questionnaire using several question polymorphs. In the next part of the tutorial, you'll learn how to store and download survey data.","title":"Summary"},{"location":"tutorial/random_ass/","text":"Random assignment In the previous part of the tutorial, you leanred how to add comprehension checks to your studies. By the end of this part of the tutorial, you'll be able to randomly assign your participants to conditions. Basic syntax Open your jupyter notebook and run the following: from hemlock import Participant from hemlock.tools import Assigner part = Participant.gen_test_participant() conditions = {'Treatment': (0,1), 'Level': ('low','med','high')} assigner = Assigner(conditions) assigner.next() Out: {'Treatment': 0, 'Level': 'low'} The Assigner randomly and evenly assigns participants to conditions, and easily handles factorial designs. It automatically records the assignment in the participant's embedded data: [(e.var, e.data) for e in part.embedded] Out: [('Treatment', 0), ('Level', 'low')] Random assignment in our app In survey.py : from hemlock import Branch, Check, Compile, Embedded, Input, Label, Navigate, Page, Range, Select, Submit, Validate, route from hemlock.tools import Assigner, comprehension_check, join from datetime import datetime from random import randint N_ROUNDS = 5 POT = 20 assigner = Assigner({'Proposer': (0,1)}) ... @Navigate.register def ultimatum_game(start_branch): branch = comprehension_check( # COMPREHENSION CHECK HERE ) proposer = assigner.next()['Proposer'] branch.pages.append(Page( Label(''' <p>You are about to play an ultimatum game as a <b>{}</b>.</p> '''.format('proposer' if proposer else 'responder') ), terminal=True )) return branch Run your app and pass the comprehenion check to see which condition you've been assigned to. Summary In this part of the tutorial, you learned how to assign participants to conditions. In the next part of the tutorial, you'll implement the proposer branch of the ultimatum game.","title":"Random assignment"},{"location":"tutorial/random_ass/#random-assignment","text":"In the previous part of the tutorial, you leanred how to add comprehension checks to your studies. By the end of this part of the tutorial, you'll be able to randomly assign your participants to conditions.","title":"Random assignment"},{"location":"tutorial/random_ass/#basic-syntax","text":"Open your jupyter notebook and run the following: from hemlock import Participant from hemlock.tools import Assigner part = Participant.gen_test_participant() conditions = {'Treatment': (0,1), 'Level': ('low','med','high')} assigner = Assigner(conditions) assigner.next() Out: {'Treatment': 0, 'Level': 'low'} The Assigner randomly and evenly assigns participants to conditions, and easily handles factorial designs. It automatically records the assignment in the participant's embedded data: [(e.var, e.data) for e in part.embedded] Out: [('Treatment', 0), ('Level', 'low')]","title":"Basic syntax"},{"location":"tutorial/random_ass/#random-assignment-in-our-app","text":"In survey.py : from hemlock import Branch, Check, Compile, Embedded, Input, Label, Navigate, Page, Range, Select, Submit, Validate, route from hemlock.tools import Assigner, comprehension_check, join from datetime import datetime from random import randint N_ROUNDS = 5 POT = 20 assigner = Assigner({'Proposer': (0,1)}) ... @Navigate.register def ultimatum_game(start_branch): branch = comprehension_check( # COMPREHENSION CHECK HERE ) proposer = assigner.next()['Proposer'] branch.pages.append(Page( Label(''' <p>You are about to play an ultimatum game as a <b>{}</b>.</p> '''.format('proposer' if proposer else 'responder') ), terminal=True )) return branch Run your app and pass the comprehenion check to see which condition you've been assigned to.","title":"Random assignment in our app"},{"location":"tutorial/random_ass/#summary","text":"In this part of the tutorial, you learned how to assign participants to conditions. In the next part of the tutorial, you'll implement the proposer branch of the ultimatum game.","title":"Summary"},{"location":"tutorial/responder_branch/","text":"Responder branch In the previous part of the tutorial, you implemented the proposer branch. In this part of the tutorial, you'll implement the responder branch. Because the responder branch is similar to the proposer branch, we'll skip the notebook and work straight in survey.py . I'll point out the differences as we go along. Adding the responder branch to our survey First, let's add a navigate function to the end of our ultimatum game branch to bring us to the responder branch: ... @Navigate.register def ultimatum_game(start_branch): ... if proposer: return Navigate.proposer_branch(branch) else: return Navigate.responder_branch(branch) ... @Navigate.register def responder_branch(ultimatum_game_branch=None): branch = Branch() for round_ in range(N_ROUNDS): response_input = gen_response_input(round_+1) branch.pages.append(Page(response_input)) branch.pages.append(Page(Compile.responder_outcome( Label(), response_input ))) branch.pages.append(Page( Label('<p>Thank you for completing the hemlock tutorial!</p>'), terminal=True )) return branch Like in the proposer branch, we add two pages to the responder branch for each of N_ROUNDS . Just as the first of these two pages asked the proposer for the proposal in the proposer branch, the first of these two pages asks the responder for their response in the responder branch. Like in the proposer branch, the second of these pages displays the outcome of the round. The responder input Just as the proposer's input was created with gen_proposal_input , the responder's input is created with gen_response_input : ... def gen_response_input(round_): return Submit.data_type( Validate.range_val( Input( ''' <p><b>Round {} of {}</b></p> <p>The proposer has ${} to split between him/herself and you. Complete this sentence:</p> <p>I will accept any proposal which gives me at least</p> '''.format(round_, N_ROUNDS, POT), prepend='$', append='.00', var='Response' ), min_=0, max_=POT ), int ) As before, we add valiation so that the input must be between 0 and the size of the pot, and a submit function which converts the data to an integer. Displaying the responder outcome We register a compile function to display the responder outcome. ... @Compile.register def responder_outcome(outcome_label, responder_input): # get the response response = responder_input.data # randomly select a proposal proposal_inputs = Input.query.filter( Input.var=='Proposal', Input.data!=None ).all() if proposal_inputs: # randomly choose a proposal n = random.choice(proposal_inputs).data else: # no proposals are available # e.g. if this is the first participant n = randint(0, POT) proposal = POT-n, n # compute the payoff accept = response <= proposal[1] payoff = proposal if accept else (0, 0) # record results as embedded data outcome_label.page.embedded = [ Embedded('Proposal', proposal[1]), Embedded('Accept', int(accept)), Embedded('ProposerPayoff', payoff[0]), Embedded('ResponderPayoff', payoff[1]) ] # describe the outcome of the round outcome_label.label = ''' <p>The proposer proposed the following split:</p> <ul> <li>Proposer: ${}</li> <li>You: ${}</li> </ul> <p>You said you will accept any proposal which gives you at least ${}.</p> <p><b>You {} the proposal, giving you a payoff of ${}.</b></p> '''.format( *proposal, response, 'accepted' if accept else 'rejected', payoff[1] ) This is similar to the proposer_outcome compile function. First, it gets the responder's response. Second, it matches the responder with a random proposer. If no proposer is avaiable (e.g. if the responder is the first participant in the survey), it generates a random proposal. Third, we compute the payoff for the round and record it using embedded data. Finally, we update the label to display the outcome of the round to the proposer. Run the app to see what the survey looks like in the responder condition. Summary In this part of the tutorial, you implemented the responder branch. In the next part of the tutorial, you'll learn how to use hemlock's cutom debugger to make sure everything is running smoothly.","title":"Responder branch"},{"location":"tutorial/responder_branch/#responder-branch","text":"In the previous part of the tutorial, you implemented the proposer branch. In this part of the tutorial, you'll implement the responder branch. Because the responder branch is similar to the proposer branch, we'll skip the notebook and work straight in survey.py . I'll point out the differences as we go along.","title":"Responder branch"},{"location":"tutorial/responder_branch/#adding-the-responder-branch-to-our-survey","text":"First, let's add a navigate function to the end of our ultimatum game branch to bring us to the responder branch: ... @Navigate.register def ultimatum_game(start_branch): ... if proposer: return Navigate.proposer_branch(branch) else: return Navigate.responder_branch(branch) ... @Navigate.register def responder_branch(ultimatum_game_branch=None): branch = Branch() for round_ in range(N_ROUNDS): response_input = gen_response_input(round_+1) branch.pages.append(Page(response_input)) branch.pages.append(Page(Compile.responder_outcome( Label(), response_input ))) branch.pages.append(Page( Label('<p>Thank you for completing the hemlock tutorial!</p>'), terminal=True )) return branch Like in the proposer branch, we add two pages to the responder branch for each of N_ROUNDS . Just as the first of these two pages asked the proposer for the proposal in the proposer branch, the first of these two pages asks the responder for their response in the responder branch. Like in the proposer branch, the second of these pages displays the outcome of the round.","title":"Adding the responder branch to our survey"},{"location":"tutorial/responder_branch/#the-responder-input","text":"Just as the proposer's input was created with gen_proposal_input , the responder's input is created with gen_response_input : ... def gen_response_input(round_): return Submit.data_type( Validate.range_val( Input( ''' <p><b>Round {} of {}</b></p> <p>The proposer has ${} to split between him/herself and you. Complete this sentence:</p> <p>I will accept any proposal which gives me at least</p> '''.format(round_, N_ROUNDS, POT), prepend='$', append='.00', var='Response' ), min_=0, max_=POT ), int ) As before, we add valiation so that the input must be between 0 and the size of the pot, and a submit function which converts the data to an integer.","title":"The responder input"},{"location":"tutorial/responder_branch/#displaying-the-responder-outcome","text":"We register a compile function to display the responder outcome. ... @Compile.register def responder_outcome(outcome_label, responder_input): # get the response response = responder_input.data # randomly select a proposal proposal_inputs = Input.query.filter( Input.var=='Proposal', Input.data!=None ).all() if proposal_inputs: # randomly choose a proposal n = random.choice(proposal_inputs).data else: # no proposals are available # e.g. if this is the first participant n = randint(0, POT) proposal = POT-n, n # compute the payoff accept = response <= proposal[1] payoff = proposal if accept else (0, 0) # record results as embedded data outcome_label.page.embedded = [ Embedded('Proposal', proposal[1]), Embedded('Accept', int(accept)), Embedded('ProposerPayoff', payoff[0]), Embedded('ResponderPayoff', payoff[1]) ] # describe the outcome of the round outcome_label.label = ''' <p>The proposer proposed the following split:</p> <ul> <li>Proposer: ${}</li> <li>You: ${}</li> </ul> <p>You said you will accept any proposal which gives you at least ${}.</p> <p><b>You {} the proposal, giving you a payoff of ${}.</b></p> '''.format( *proposal, response, 'accepted' if accept else 'rejected', payoff[1] ) This is similar to the proposer_outcome compile function. First, it gets the responder's response. Second, it matches the responder with a random proposer. If no proposer is avaiable (e.g. if the responder is the first participant in the survey), it generates a random proposal. Third, we compute the payoff for the round and record it using embedded data. Finally, we update the label to display the outcome of the round to the proposer. Run the app to see what the survey looks like in the responder condition.","title":"Displaying the responder outcome"},{"location":"tutorial/responder_branch/#summary","text":"In this part of the tutorial, you implemented the responder branch. In the next part of the tutorial, you'll learn how to use hemlock's cutom debugger to make sure everything is running smoothly.","title":"Summary"},{"location":"tutorial/run_local/","text":"Running hemlock locally In the previous part of the tutorial, you learned how to initialize a hemlock project and create and preview a hemlock page. By the end of this part of the tutorial, you'll be able to initialize a hemlock application and run it locally. Note. Running an app 'locally' means that you can play with it on your own computer, but it won't be available on the internet. We'll cover deployment later. Why run locally? In the previous part of the tutorial, we created and previewed a page in a jupyter notebook. Hemlock + jupyter notebook is great for trying out ideas and iterating quickly, like working on a blackboard. However, it won't create a fully responsive application (survey). For that, we're going to need to run our app locally. Running the application Create a python file called survey.py in the root directory of your project. If you're working with Visual Studio Code, enter the following in your terminal: $ code survey.py Enter the following code in survey.py : from hemlock import Branch, Page, Label, route @route('/survey') def start(): return Branch( Page( Label('<p>Hello, World!</p>'), terminal=True ) ) To preview your survey, go back to your terminal window and enter: $ hlk serve Then navigate to http://localhost:5000/ in your browser. Modifications if not using hemlock-CLI or the hemlock template The hemlock template comes with an app.py file which creates the application instace. Create app.py in your root directory with the following code: import survey from hemlock import create_app app = create_app() if __name__ == '__main__': from hemlock.app import socketio socketio.run(app, debug=True) Instead of running with hlk serve , use: $ python3 app.py Code explanation After our imports, we use the @route('/survey') decorator to register our first 'navigate' function. This essentially tells our application, 'start here'. Navigate functions direct the 'survey flow'. All navigate functions return Branch objects. A branch contains a list of pages which it displays to participants. We set a branch's pages by passing them as arguments the constructor, or by setting a branch's pages attribute, meaning that the following are equivalent: b = Branch(Page(Label('<p>Label 0</p>')), Page(Label('<p>Label 1</p>'))) b = Branch() b.pages = [Page(Label('<p>Label 0</p>')), Page(Label('<p>Label 1</p>'))] We also passed a keyword (named) argument to the page constructor, terminal=True . This tells the application 'end here'. Summary In this part of the tutorial, you learned how to initialize a hemlock application and run it locally. In the next part of the tutorial, you'll learn how to use question polymorphs to add a demographics questionnaire to your survey.","title":"Running hemlock locally"},{"location":"tutorial/run_local/#running-hemlock-locally","text":"In the previous part of the tutorial, you learned how to initialize a hemlock project and create and preview a hemlock page. By the end of this part of the tutorial, you'll be able to initialize a hemlock application and run it locally. Note. Running an app 'locally' means that you can play with it on your own computer, but it won't be available on the internet. We'll cover deployment later.","title":"Running hemlock locally"},{"location":"tutorial/run_local/#why-run-locally","text":"In the previous part of the tutorial, we created and previewed a page in a jupyter notebook. Hemlock + jupyter notebook is great for trying out ideas and iterating quickly, like working on a blackboard. However, it won't create a fully responsive application (survey). For that, we're going to need to run our app locally.","title":"Why run locally?"},{"location":"tutorial/run_local/#running-the-application","text":"Create a python file called survey.py in the root directory of your project. If you're working with Visual Studio Code, enter the following in your terminal: $ code survey.py Enter the following code in survey.py : from hemlock import Branch, Page, Label, route @route('/survey') def start(): return Branch( Page( Label('<p>Hello, World!</p>'), terminal=True ) ) To preview your survey, go back to your terminal window and enter: $ hlk serve Then navigate to http://localhost:5000/ in your browser.","title":"Running the application"},{"location":"tutorial/run_local/#modifications-if-not-using-hemlock-cli-or-the-hemlock-template","text":"The hemlock template comes with an app.py file which creates the application instace. Create app.py in your root directory with the following code: import survey from hemlock import create_app app = create_app() if __name__ == '__main__': from hemlock.app import socketio socketio.run(app, debug=True) Instead of running with hlk serve , use: $ python3 app.py","title":"Modifications if not using hemlock-CLI or the hemlock template"},{"location":"tutorial/run_local/#code-explanation","text":"After our imports, we use the @route('/survey') decorator to register our first 'navigate' function. This essentially tells our application, 'start here'. Navigate functions direct the 'survey flow'. All navigate functions return Branch objects. A branch contains a list of pages which it displays to participants. We set a branch's pages by passing them as arguments the constructor, or by setting a branch's pages attribute, meaning that the following are equivalent: b = Branch(Page(Label('<p>Label 0</p>')), Page(Label('<p>Label 1</p>'))) b = Branch() b.pages = [Page(Label('<p>Label 0</p>')), Page(Label('<p>Label 1</p>'))] We also passed a keyword (named) argument to the page constructor, terminal=True . This tells the application 'end here'.","title":"Code explanation"},{"location":"tutorial/run_local/#summary","text":"In this part of the tutorial, you learned how to initialize a hemlock application and run it locally. In the next part of the tutorial, you'll learn how to use question polymorphs to add a demographics questionnaire to your survey.","title":"Summary"},{"location":"tutorial/setup/","text":"Setup Essential Google Chrome . Python3 and pip3 , recommended version 3.6. This is hemlock's primary language. A way to open and edit python files. Recommended Visual Studio Code . Windows users I recommend installing Windows Subsystem for Linux (WSL) with the Ubuntu Linux distribution. This comes with python and pip. After you've installed Ubuntu, open a terminal window (WIN + R, then enter 'ubuntu'). You will be prompted to create a username and password. Verify your python installation with: $ python3 Python 3.6.x Note. You don't type $ in the terminal window; it simply denotes the beginning of a terminal command. Update your package lists with: $ sudo apt-get update Install pip3 with: $ sudo apt install -f -y python3-pip Respond 'Yes' if asked whether you want to restart services automatically. Verify your pip3 installation: $ pip3 --version pip x.x.x from /usr/lib/python3/dist-packages (python 3.6) Note. When installing python packages, use pip3 instead of pip : pip3 install <the-package-I-want> # instead of pip install <the-package-I-want> Finally, I recommend setting your BROWSER environment variable after installing hemlock-CLI (see below). Recommended The following aren't necessary to use hemlock, but they will make your life easier. The rest of the tutorial assumes you have these. Hemlock-CLI Use pip to install the hemlock command line interface (CLI). $ pip3 install hemlock-cli Verify your installation: $ hlk --version hlk, version x.x.x If using WSL To set chrome as your default browser from WSL, run: $ hlk setup win --chrome Close and re-open your terminal, then verify your BROWSER variable: $ echo $BROWSER /mnt/c/program files (x86)/google/chrome/application/chrome.exe Git Git and github are version control tools for sharing, downloading, and collaborating on software, including hemock projects. If using WSL If you're operating on Ubuntu/WSL, run: $ hlk setup win --git Jupyter Jupyter allows you to quickly iterate on project designs. For no good reason, I personally use Jupyter Notebook, not JupyterLab.","title":"Setup"},{"location":"tutorial/setup/#setup","text":"","title":"Setup"},{"location":"tutorial/setup/#essential","text":"Google Chrome . Python3 and pip3 , recommended version 3.6. This is hemlock's primary language. A way to open and edit python files. Recommended Visual Studio Code .","title":"Essential"},{"location":"tutorial/setup/#windows-users","text":"I recommend installing Windows Subsystem for Linux (WSL) with the Ubuntu Linux distribution. This comes with python and pip. After you've installed Ubuntu, open a terminal window (WIN + R, then enter 'ubuntu'). You will be prompted to create a username and password. Verify your python installation with: $ python3 Python 3.6.x Note. You don't type $ in the terminal window; it simply denotes the beginning of a terminal command. Update your package lists with: $ sudo apt-get update Install pip3 with: $ sudo apt install -f -y python3-pip Respond 'Yes' if asked whether you want to restart services automatically. Verify your pip3 installation: $ pip3 --version pip x.x.x from /usr/lib/python3/dist-packages (python 3.6) Note. When installing python packages, use pip3 instead of pip : pip3 install <the-package-I-want> # instead of pip install <the-package-I-want> Finally, I recommend setting your BROWSER environment variable after installing hemlock-CLI (see below).","title":"Windows users"},{"location":"tutorial/setup/#recommended","text":"The following aren't necessary to use hemlock, but they will make your life easier. The rest of the tutorial assumes you have these.","title":"Recommended"},{"location":"tutorial/setup/#hemlock-cli","text":"Use pip to install the hemlock command line interface (CLI). $ pip3 install hemlock-cli Verify your installation: $ hlk --version hlk, version x.x.x","title":"Hemlock-CLI"},{"location":"tutorial/setup/#if-using-wsl","text":"To set chrome as your default browser from WSL, run: $ hlk setup win --chrome Close and re-open your terminal, then verify your BROWSER variable: $ echo $BROWSER /mnt/c/program files (x86)/google/chrome/application/chrome.exe","title":"If using WSL"},{"location":"tutorial/setup/#git","text":"Git and github are version control tools for sharing, downloading, and collaborating on software, including hemock projects.","title":"Git"},{"location":"tutorial/setup/#if-using-wsl_1","text":"If you're operating on Ubuntu/WSL, run: $ hlk setup win --git","title":"If using WSL"},{"location":"tutorial/setup/#jupyter","text":"Jupyter allows you to quickly iterate on project designs. For no good reason, I personally use Jupyter Notebook, not JupyterLab.","title":"Jupyter"},{"location":"tutorial/submit/","text":"Submit In the previous part of the tutorial, you learned how to validate participant responses. By the end of this part of the tutorial, you'll be able to run functions to handle form submission. Why submit functions? Our demographics page asks participants to enter their date of birth. In addition to date of birth, we also want to record the participant's age. Submit functions run after a participant submits a page and their responses are validated. We're going to attach a submit function to our date of birth input question to record our participants' age as embedded data. Basic syntax Open your jupyter notebook and run the following: from hemlock import Input, Submit inpt = Submit.match(Input('<p>Enter \"hello world\"</p>'), 'hello world') inpt Out: <Input 1> Submit.match adds a submit function to a question, then returns the question. In this case, the submit function changes its question's data to 1 if the data matches a pattern, 'hello world' , and 0 if it does not. Submit functions are available in the question's submit_functions attribute: inpt.submit_functions Out: [<Submit 1>] Let's set the input question's reponse and watch our submit function work: inpt.data = 'hello world' inpt._submit() print(inpt.data) inpt.data = 'something other than hello world' inpt._submit() print(inpt.data) Out: 1 0 match is just one of many prebuilt submit functions . Custom submission We're going to use a custom submit function to record our participants' age. from hemlock import Embedded, Page from datetime import datetime @Submit.register def record_age(inpt): # calculate age in years date_of_birth = datetime.strptime(inpt.data, '%m/%d/%Y') age = (datetime.utcnow() - date_of_birth).days / 365.25 # record age as embedded data inpt.page.embedded = [Embedded('Age', age, data_rows=-1)] page = Page(Submit.record_age(Input('<p>Enter your date of birth.</p>'))) inpt = page.questions[0] inpt.data = '10/26/1992' inpt._submit() page.embedded[0].data Out: 27.698836413415467 Code explanation We register a new submit function with the @Submit.register decorator. The submit function takes the input question as its argument. It converts the input's data to a datetime object, computes the participant's age, and records it as embedded data. Submission in our app Now that we've seen how to add submit functions in our notebook, let's add it to our app. In survey.py : from hemlock import Branch, Check, Embedded, Input, Label, Page, Range, Select, Submit, Validate, route from datetime import datetime @route('/survey') def start(): return Branch( Page( Submit.record_age(Validate.validate_date_format(Input( '<p>Enter your date of birth.</p>', placeholder='mm/dd/yyyy', var='DoB', data_rows=-1 ))), # REST OF THE DEMOGRAPHICS PAGE HERE ), Page( Label('<p>Thank you for completing the survey!</p>'), terminal=True ) ) ... @Submit.register def record_age(inpt): # calculate age in years date_of_birth = datetime.strptime(inpt.data, '%m/%d/%Y') age = (datetime.utcnow() - date_of_birth).days / 365.25 # record age as embedded data inpt.page.embedded = [Embedded('Age', age, data_rows=-1)] Run the app again, fill in the demographics page, and download the data. You'll now see a variable 'Age' in the data frame. Summary In this part of the tutorial, you learned how create and run submit functions. In the next part of the tutorial, you'll implement a confirmation page using compile functions.","title":"Submit"},{"location":"tutorial/submit/#submit","text":"In the previous part of the tutorial, you learned how to validate participant responses. By the end of this part of the tutorial, you'll be able to run functions to handle form submission.","title":"Submit"},{"location":"tutorial/submit/#why-submit-functions","text":"Our demographics page asks participants to enter their date of birth. In addition to date of birth, we also want to record the participant's age. Submit functions run after a participant submits a page and their responses are validated. We're going to attach a submit function to our date of birth input question to record our participants' age as embedded data.","title":"Why submit functions?"},{"location":"tutorial/submit/#basic-syntax","text":"Open your jupyter notebook and run the following: from hemlock import Input, Submit inpt = Submit.match(Input('<p>Enter \"hello world\"</p>'), 'hello world') inpt Out: <Input 1> Submit.match adds a submit function to a question, then returns the question. In this case, the submit function changes its question's data to 1 if the data matches a pattern, 'hello world' , and 0 if it does not. Submit functions are available in the question's submit_functions attribute: inpt.submit_functions Out: [<Submit 1>] Let's set the input question's reponse and watch our submit function work: inpt.data = 'hello world' inpt._submit() print(inpt.data) inpt.data = 'something other than hello world' inpt._submit() print(inpt.data) Out: 1 0 match is just one of many prebuilt submit functions .","title":"Basic syntax"},{"location":"tutorial/submit/#custom-submission","text":"We're going to use a custom submit function to record our participants' age. from hemlock import Embedded, Page from datetime import datetime @Submit.register def record_age(inpt): # calculate age in years date_of_birth = datetime.strptime(inpt.data, '%m/%d/%Y') age = (datetime.utcnow() - date_of_birth).days / 365.25 # record age as embedded data inpt.page.embedded = [Embedded('Age', age, data_rows=-1)] page = Page(Submit.record_age(Input('<p>Enter your date of birth.</p>'))) inpt = page.questions[0] inpt.data = '10/26/1992' inpt._submit() page.embedded[0].data Out: 27.698836413415467","title":"Custom submission"},{"location":"tutorial/submit/#code-explanation","text":"We register a new submit function with the @Submit.register decorator. The submit function takes the input question as its argument. It converts the input's data to a datetime object, computes the participant's age, and records it as embedded data.","title":"Code explanation"},{"location":"tutorial/submit/#submission-in-our-app","text":"Now that we've seen how to add submit functions in our notebook, let's add it to our app. In survey.py : from hemlock import Branch, Check, Embedded, Input, Label, Page, Range, Select, Submit, Validate, route from datetime import datetime @route('/survey') def start(): return Branch( Page( Submit.record_age(Validate.validate_date_format(Input( '<p>Enter your date of birth.</p>', placeholder='mm/dd/yyyy', var='DoB', data_rows=-1 ))), # REST OF THE DEMOGRAPHICS PAGE HERE ), Page( Label('<p>Thank you for completing the survey!</p>'), terminal=True ) ) ... @Submit.register def record_age(inpt): # calculate age in years date_of_birth = datetime.strptime(inpt.data, '%m/%d/%Y') age = (datetime.utcnow() - date_of_birth).days / 365.25 # record age as embedded data inpt.page.embedded = [Embedded('Age', age, data_rows=-1)] Run the app again, fill in the demographics page, and download the data. You'll now see a variable 'Age' in the data frame.","title":"Submission in our app"},{"location":"tutorial/submit/#summary","text":"In this part of the tutorial, you learned how create and run submit functions. In the next part of the tutorial, you'll implement a confirmation page using compile functions.","title":"Summary"},{"location":"tutorial/validate/","text":"Validation In the previous part of the tutorial, you learned how to store and download data. By the end of this part of the tutorial, you'll be able to validate participant responses. Why validation? I often run studies where I elicit numerical estimates. Early on, I noticed that a small but annoying faction of participants, rather than entering actual numbers (e.g. 50), answered the question in full sentences: I believe the answer is fifty. We often need to make sure participants are entering the right kind of answer, whether it's typing the same password twice, answering a comprehension check by clicking on the correct choice, or entering a number instead of a word. Basic syntax Open your jupyter notebook and run the following: from hemlock import Input, Validate inpt = Validate.require(Input('<p>You must respond to this question.</p>')) inpt Out: <Input 1> Validate.require adds a validate function to a question, then returns the question. In this case, we require a response from the participant. Validate functions are available in the question's validate_functions attribute: inpt.validate_functions Out: [<Validate 1>] We can see that there is currently no response or error associated with the input question: not inpt.response and not inpt.error Out: True Because the validate function requires a response, and because there is no response, running the validate functions sets the input question's error message as follows: inpt._validate() inpt.error Out: Please respond to this question. You don't need to run _validate() yourself in the survey; hemlock takes care of this automatically for you. require is just one of many prebuilt validate functions . Custom validation This is a good start, but what happens when someone enters a nonsense response for date of birth? For this, we're going to need a custom validate function. Let's see how to do this in our notebook: from datetime import datetime @Validate.register def validate_date_format(inpt): try: # try to convert to a datetime object datetime.strptime(inpt.response, '%m/%d/%Y') except: # if this fails, the participant entered an invalid response return '<p>Format your date of birth as mm/dd/yyyy.</p>' inpt = Validate.validate_date_format(inpt) inpt.response = ''' I, George Thaddeus Thatch the Third, was born in the first fortnight of August 1792. ''' inpt._validate() inpt.error Out: Format your date of birth as mm/dd/yyyy. Code explanation First, we import datetime , a native python package for handling dates and times. Next, we register a new validate function with the @Validate.register decorator. The validate function takes the input question as its argument. In general, validate functions (and, as we will see, their cousins, submit, compile, and navigate functions) take their 'parent' (usually a branch, page, or question) as their first argument. The validate function tries to convert the input question's response to a datetime object and returns an error message if this fails. In general, validate functions return an error message (a string) if there is a problem, and None if the response is valid. Validation in our app Now that we've seen how to add validation in our notebook, let's add it to our app. In survey.py : from hemlock import Branch, Check, Input, Label, Page, Range, Select, Validate, route from datetime import datetime @route('/survey') def start(): return Branch( Page( Validate.validate_date_format(Input( '<p>Enter your date of birth.</p>', placeholder='mm/dd/yyyy', var='DoB', data_rows=-1 )), Validate.require(Check( '<p>Indicate your gender.</p>', ['Male', 'Female', 'Other'], var='Gender', data_rows=-1 )), # REST OF THE DEMOGRAPHICS PAGE HERE ), Page( Label('<p>Thank you for completing the survey!</p>'), terminal=True ) ) @Validate.register def validate_date_format(inpt): try: # try to convert to a datetime object datetime.strptime(inpt.response, '%m/%d/%Y') except: # if this fails, the participant entered an invalid response return '<p>Format your date of birth as mm/dd/yyyy.</p>' Run the app again and try to continue past the demographics page; enter and invalid date of birth, leave some questions blank, and see your validation at work. Note. You can attack multiple validation functions to a single page or question. Validate functions run in the order in which you add them, stopping with the first validate function which returns an error. Summary In this part of the tutorial, you learned how to validate participant responses. In the next part of the tutorial, you'll learn how to run submit functions to modify participant data after they submit a page.","title":"Validate"},{"location":"tutorial/validate/#validation","text":"In the previous part of the tutorial, you learned how to store and download data. By the end of this part of the tutorial, you'll be able to validate participant responses.","title":"Validation"},{"location":"tutorial/validate/#why-validation","text":"I often run studies where I elicit numerical estimates. Early on, I noticed that a small but annoying faction of participants, rather than entering actual numbers (e.g. 50), answered the question in full sentences: I believe the answer is fifty. We often need to make sure participants are entering the right kind of answer, whether it's typing the same password twice, answering a comprehension check by clicking on the correct choice, or entering a number instead of a word.","title":"Why validation?"},{"location":"tutorial/validate/#basic-syntax","text":"Open your jupyter notebook and run the following: from hemlock import Input, Validate inpt = Validate.require(Input('<p>You must respond to this question.</p>')) inpt Out: <Input 1> Validate.require adds a validate function to a question, then returns the question. In this case, we require a response from the participant. Validate functions are available in the question's validate_functions attribute: inpt.validate_functions Out: [<Validate 1>] We can see that there is currently no response or error associated with the input question: not inpt.response and not inpt.error Out: True Because the validate function requires a response, and because there is no response, running the validate functions sets the input question's error message as follows: inpt._validate() inpt.error Out: Please respond to this question. You don't need to run _validate() yourself in the survey; hemlock takes care of this automatically for you. require is just one of many prebuilt validate functions .","title":"Basic syntax"},{"location":"tutorial/validate/#custom-validation","text":"This is a good start, but what happens when someone enters a nonsense response for date of birth? For this, we're going to need a custom validate function. Let's see how to do this in our notebook: from datetime import datetime @Validate.register def validate_date_format(inpt): try: # try to convert to a datetime object datetime.strptime(inpt.response, '%m/%d/%Y') except: # if this fails, the participant entered an invalid response return '<p>Format your date of birth as mm/dd/yyyy.</p>' inpt = Validate.validate_date_format(inpt) inpt.response = ''' I, George Thaddeus Thatch the Third, was born in the first fortnight of August 1792. ''' inpt._validate() inpt.error Out: Format your date of birth as mm/dd/yyyy.","title":"Custom validation"},{"location":"tutorial/validate/#code-explanation","text":"First, we import datetime , a native python package for handling dates and times. Next, we register a new validate function with the @Validate.register decorator. The validate function takes the input question as its argument. In general, validate functions (and, as we will see, their cousins, submit, compile, and navigate functions) take their 'parent' (usually a branch, page, or question) as their first argument. The validate function tries to convert the input question's response to a datetime object and returns an error message if this fails. In general, validate functions return an error message (a string) if there is a problem, and None if the response is valid.","title":"Code explanation"},{"location":"tutorial/validate/#validation-in-our-app","text":"Now that we've seen how to add validation in our notebook, let's add it to our app. In survey.py : from hemlock import Branch, Check, Input, Label, Page, Range, Select, Validate, route from datetime import datetime @route('/survey') def start(): return Branch( Page( Validate.validate_date_format(Input( '<p>Enter your date of birth.</p>', placeholder='mm/dd/yyyy', var='DoB', data_rows=-1 )), Validate.require(Check( '<p>Indicate your gender.</p>', ['Male', 'Female', 'Other'], var='Gender', data_rows=-1 )), # REST OF THE DEMOGRAPHICS PAGE HERE ), Page( Label('<p>Thank you for completing the survey!</p>'), terminal=True ) ) @Validate.register def validate_date_format(inpt): try: # try to convert to a datetime object datetime.strptime(inpt.response, '%m/%d/%Y') except: # if this fails, the participant entered an invalid response return '<p>Format your date of birth as mm/dd/yyyy.</p>' Run the app again and try to continue past the demographics page; enter and invalid date of birth, leave some questions blank, and see your validation at work. Note. You can attack multiple validation functions to a single page or question. Validate functions run in the order in which you add them, stopping with the first validate function which returns an error.","title":"Validation in our app"},{"location":"tutorial/validate/#summary","text":"In this part of the tutorial, you learned how to validate participant responses. In the next part of the tutorial, you'll learn how to run submit functions to modify participant data after they submit a page.","title":"Summary"},{"location":"tutorial/archive/setup_general/","text":"Setup Here are the prerequisites I recommend to take advantage of the full range of tools Hemlock offers. Unless otherwise specified, I recommend you download the latest stable version of the following: Essential Python3 and pip3 . Python is Hemlock's primary language. pip allows you to install Python packages, including Hemlock itself. I recommend Python3.6 , the version you will use for Heroku deployment (see below). Additionally, you should be able to create virtual environments . Code editor . I work in Visual Studio (VS) Code with the Remote-WSL extension, but any code editor will do. Strongly recommended Heroku and Heroku-CLI . Heroku is an inexpensive and accessible service for deploying web applications. The Hemlock command line interface builds on the Heroku command line interface (CLI) . Git . Git is a version control system which I use to 'push' applications to Heroku. Relatedly, I recommend Github for backing up Hemlock projects and sharing them with collaborators. With the above software, you are ready to create, share, and deploy Hemlock projects. The software below is encouraged for debugging, file storage, and Redis testing. They are not essential. If you're eager to get started with Hemlock, you can come back to these if and when you need them. Encouraged Google Chrome and Chromedriver . Hemlock's custom debugging tool requires Google Chrome and Chromedriver to run locally. Google Cloud and Cloud SDK . Hemlock easily integrates with Google Cloud for storing statics (such as images to display during a survey) and user uploaded files. The Hemlock command line interface builds on Cloud Software Development Kit (SDK) . Advanced Redis . Hemlock seamlessly interfaces with Redis to run complex background processes during surveys. Redis runs natively on Mac and Linux. For Windows users, I recommend Ubuntu on Windows Subsystem for Linux (WSL) . Instructions for Windows Overview: Install Google Chrome . Install Ubuntu and Windows Subsystem for Linux (WSL). Install Python3 and pip3 on Ubuntu. Use pip3 to install Hemlock-CLI. Use Hemlock-CLI to install other recommended software (Visual Studio Code, Google Chrome, etc.) Ubuntu and WSL Follow the Microsoft documentation to enable WSL and install the latest version of Ubuntu. Open an Ubuntu terminal (WIN + R, then enter 'ubuntu'). You will be prompted to create a username and password. Python3 and pip3 Ubuntu should include Python3.6. Verify your Python installation with: $ python3 --version Python 3.6.x Update your package lists with: $ sudo apt-get update Install pip3 with: $ sudo apt install -f -y python3-pip Respond 'Yes' if asked whether you want to restart services automatically. Finally, verify pip3 installation: $ pip3 --version pip x.x.x from /usr/lib/python3/dist-packages (python 3.6) Hemlock-CLI pip install the Hemlock command line interface (CLI): $ pip3 install hemlock-cli Verify hemlock-cli installation: $ hlk --version hlk, version x.x.x Recommended software Install other Hemlock utilities and recommended software with hlk setup win [options] . The options specify which recommended software tools you want to download. To download all recommended software, run: $ hlk setup --all This is equivalent to: $ hlk setup --vscode --heroku-cli --git --chromedriver --cloud-sdk VS Code and Cloud SDK will open setup executables automatically. Follow the directions when prompted. You will also be prompted to login or create accounts for Heroku-CLI, Git, and Cloud SDK. To verify the installations, close and re-open the Ubuntu terminal, then enter: $ code --version $ heroku --version $ git --version $ chromedriver --version $ gcloud --version Finally, if you are using Cloud SDK, you will need the alpha component: $ gcloud components install alpha Instructions for Mac and Linux in progress","title":"Setup"},{"location":"tutorial/archive/setup_general/#setup","text":"Here are the prerequisites I recommend to take advantage of the full range of tools Hemlock offers. Unless otherwise specified, I recommend you download the latest stable version of the following: Essential Python3 and pip3 . Python is Hemlock's primary language. pip allows you to install Python packages, including Hemlock itself. I recommend Python3.6 , the version you will use for Heroku deployment (see below). Additionally, you should be able to create virtual environments . Code editor . I work in Visual Studio (VS) Code with the Remote-WSL extension, but any code editor will do. Strongly recommended Heroku and Heroku-CLI . Heroku is an inexpensive and accessible service for deploying web applications. The Hemlock command line interface builds on the Heroku command line interface (CLI) . Git . Git is a version control system which I use to 'push' applications to Heroku. Relatedly, I recommend Github for backing up Hemlock projects and sharing them with collaborators. With the above software, you are ready to create, share, and deploy Hemlock projects. The software below is encouraged for debugging, file storage, and Redis testing. They are not essential. If you're eager to get started with Hemlock, you can come back to these if and when you need them. Encouraged Google Chrome and Chromedriver . Hemlock's custom debugging tool requires Google Chrome and Chromedriver to run locally. Google Cloud and Cloud SDK . Hemlock easily integrates with Google Cloud for storing statics (such as images to display during a survey) and user uploaded files. The Hemlock command line interface builds on Cloud Software Development Kit (SDK) . Advanced Redis . Hemlock seamlessly interfaces with Redis to run complex background processes during surveys. Redis runs natively on Mac and Linux. For Windows users, I recommend Ubuntu on Windows Subsystem for Linux (WSL) .","title":"Setup"},{"location":"tutorial/archive/setup_general/#instructions-for-windows","text":"Overview: Install Google Chrome . Install Ubuntu and Windows Subsystem for Linux (WSL). Install Python3 and pip3 on Ubuntu. Use pip3 to install Hemlock-CLI. Use Hemlock-CLI to install other recommended software (Visual Studio Code, Google Chrome, etc.)","title":"Instructions for Windows"},{"location":"tutorial/archive/setup_general/#ubuntu-and-wsl","text":"Follow the Microsoft documentation to enable WSL and install the latest version of Ubuntu. Open an Ubuntu terminal (WIN + R, then enter 'ubuntu'). You will be prompted to create a username and password.","title":"Ubuntu and WSL"},{"location":"tutorial/archive/setup_general/#python3-and-pip3","text":"Ubuntu should include Python3.6. Verify your Python installation with: $ python3 --version Python 3.6.x Update your package lists with: $ sudo apt-get update Install pip3 with: $ sudo apt install -f -y python3-pip Respond 'Yes' if asked whether you want to restart services automatically. Finally, verify pip3 installation: $ pip3 --version pip x.x.x from /usr/lib/python3/dist-packages (python 3.6)","title":"Python3 and pip3"},{"location":"tutorial/archive/setup_general/#hemlock-cli","text":"pip install the Hemlock command line interface (CLI): $ pip3 install hemlock-cli Verify hemlock-cli installation: $ hlk --version hlk, version x.x.x","title":"Hemlock-CLI"},{"location":"tutorial/archive/setup_general/#recommended-software","text":"Install other Hemlock utilities and recommended software with hlk setup win [options] . The options specify which recommended software tools you want to download. To download all recommended software, run: $ hlk setup --all This is equivalent to: $ hlk setup --vscode --heroku-cli --git --chromedriver --cloud-sdk VS Code and Cloud SDK will open setup executables automatically. Follow the directions when prompted. You will also be prompted to login or create accounts for Heroku-CLI, Git, and Cloud SDK. To verify the installations, close and re-open the Ubuntu terminal, then enter: $ code --version $ heroku --version $ git --version $ chromedriver --version $ gcloud --version Finally, if you are using Cloud SDK, you will need the alpha component: $ gcloud components install alpha","title":"Recommended software"},{"location":"tutorial/archive/setup_general/#instructions-for-mac-and-linux-in-progress","text":"","title":"Instructions for Mac and Linux in progress"},{"location":"tutorial/archive/win_setup/","text":"Instructions for Windows Overview: Install Google Chrome . Install Ubuntu and Windows Subsystem for Linux (WSL). Install Python3 and pip3 on Ubuntu. Use pip3 to install Hemlock-CLI. Use Hemlock-CLI to install other recommended software (Visual Studio Code, Chromedriver, etc.) Ubuntu and WSL Follow the Microsoft documentation to enable WSL and install the latest version of Ubuntu. Open an Ubuntu terminal (WIN + R, then enter 'ubuntu'). You will be prompted to create a username and password. Python3 and pip3 Ubuntu should include Python3.6. Verify your Python installation with: $ python3 --version Python 3.6.x Note. You don't type $ in the terminal window; it simply denotes the beginning of a terminal command. Update your package lists with: $ sudo apt-get update Install pip3 with: $ sudo apt install -f -y python3-pip Respond 'Yes' if asked whether you want to restart services automatically. Finally, verify pip3 installation: $ pip3 --version pip x.x.x from /usr/lib/python3/dist-packages (python 3.6) Hemlock-CLI pip install the Hemlock command line interface (CLI): $ pip3 install hemlock-cli Verify hemlock-cli installation: $ hlk --version hlk, version x.x.x Recommended software Install other Hemlock utilities and recommended software with hlk setup win [options] . The options specify which recommended software tools you want to download. To download all recommended software, run: $ hlk setup --all This is equivalent to: $ hlk setup --vscode --heroku-cli --git --chromedriver --cloud-sdk VS Code and Cloud SDK will open setup executables automatically. Follow the directions when prompted. You will also be prompted to login or create accounts for Heroku-CLI, Git, and Cloud SDK. To verify the installations, close and re-open the Ubuntu terminal, then enter: $ code --version $ heroku --version $ git --version $ chromedriver --version $ gcloud --version Finally, if you are using Cloud SDK, you will need the alpha component: $ gcloud components install alpha Chromedriver note The Chromedriver version downloaded by the Hemlock CLI is compatible with Chrome 83. While Chrome upgrades automatically, Chromedriver does not. When Chrome updates, you will experience errors due to Chrome-Chromedriver incompatibility. To fix this, you will need to manually upgrade Chromedriver: Download the appropriate Chromedriver version from https://chromedriver.chromium.org/downloads . Rename the Chromedriver executable from chromedriver.exe to chromedriver . Store the Chromedriver executable in C:/users/my-username/webdrivers/ , replacing my-username with your Windows username.","title":"Instructions for Windows"},{"location":"tutorial/archive/win_setup/#instructions-for-windows","text":"Overview: Install Google Chrome . Install Ubuntu and Windows Subsystem for Linux (WSL). Install Python3 and pip3 on Ubuntu. Use pip3 to install Hemlock-CLI. Use Hemlock-CLI to install other recommended software (Visual Studio Code, Chromedriver, etc.)","title":"Instructions for Windows"},{"location":"tutorial/archive/win_setup/#ubuntu-and-wsl","text":"Follow the Microsoft documentation to enable WSL and install the latest version of Ubuntu. Open an Ubuntu terminal (WIN + R, then enter 'ubuntu'). You will be prompted to create a username and password.","title":"Ubuntu and WSL"},{"location":"tutorial/archive/win_setup/#python3-and-pip3","text":"Ubuntu should include Python3.6. Verify your Python installation with: $ python3 --version Python 3.6.x Note. You don't type $ in the terminal window; it simply denotes the beginning of a terminal command. Update your package lists with: $ sudo apt-get update Install pip3 with: $ sudo apt install -f -y python3-pip Respond 'Yes' if asked whether you want to restart services automatically. Finally, verify pip3 installation: $ pip3 --version pip x.x.x from /usr/lib/python3/dist-packages (python 3.6)","title":"Python3 and pip3"},{"location":"tutorial/archive/win_setup/#hemlock-cli","text":"pip install the Hemlock command line interface (CLI): $ pip3 install hemlock-cli Verify hemlock-cli installation: $ hlk --version hlk, version x.x.x","title":"Hemlock-CLI"},{"location":"tutorial/archive/win_setup/#recommended-software","text":"Install other Hemlock utilities and recommended software with hlk setup win [options] . The options specify which recommended software tools you want to download. To download all recommended software, run: $ hlk setup --all This is equivalent to: $ hlk setup --vscode --heroku-cli --git --chromedriver --cloud-sdk VS Code and Cloud SDK will open setup executables automatically. Follow the directions when prompted. You will also be prompted to login or create accounts for Heroku-CLI, Git, and Cloud SDK. To verify the installations, close and re-open the Ubuntu terminal, then enter: $ code --version $ heroku --version $ git --version $ chromedriver --version $ gcloud --version Finally, if you are using Cloud SDK, you will need the alpha component: $ gcloud components install alpha","title":"Recommended software"},{"location":"tutorial/archive/win_setup/#chromedriver-note","text":"The Chromedriver version downloaded by the Hemlock CLI is compatible with Chrome 83. While Chrome upgrades automatically, Chromedriver does not. When Chrome updates, you will experience errors due to Chrome-Chromedriver incompatibility. To fix this, you will need to manually upgrade Chromedriver: Download the appropriate Chromedriver version from https://chromedriver.chromium.org/downloads . Rename the Chromedriver executable from chromedriver.exe to chromedriver . Store the Chromedriver executable in C:/users/my-username/webdrivers/ , replacing my-username with your Windows username.","title":"Chromedriver note"}]}